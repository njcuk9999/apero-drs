%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
\ifdevguide
\chapter{Variables}
\else
\chapter{User modifiable variables}
\fi
\label{ch:variables}
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


To better understand the variables in the DRS we have laid out each variable in the following way:

\begin{itemize}
\item \label{text:variable} \ParameterEntry{Variable title}
{Description of the variable}
{VARIABLE\_NAME}
{Default Value}{The recipe used the variable is used in.}
{The place where the variable is defined.}
{The code (module + function) where variable is used.}
{
Who should be able to change this variable, levels are as follows:
\begin{itemize}
	\item Public: Everyone (including the user)
	\item Private: Only the developer
\end{itemize}
}

\end{itemize}

\ifdevguide
\begin{note}
All variable from all configuration files are (and should be) loaded into the main parameter dictionary `p' in all recipes and thus are accessed via: 
\begin{pythonbox}
variable = p["(*\textcolor{red}{VARIABLE\_NAME}*)"]
\end{pythonbox}
\end{note}
\fi





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
\section{Variable file locations}
\label{ch:variables:location}
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\ifdevguide
\subsection{User modifiable variables}
\fi

The variables are currently stored in two places. The first (\configtxtfile) contains constants that deal with initial set up. These were mentioned in Section \ref{ch:install:setup} and are located in \configtxtfilepath. \\

\noindent The other variables modify how the DRS runs. These are located in \constantsfile\, (located at \constantsfilepath).  \\


\ifdevguide
\subsection{Private variables}

\noindent In addition to the above (user modifiable public variable files) there are several files that will contain all constants that should not be changed by a user (i.e. static variables that are set and changed only in development). These are described below:

\begin{itemize}

	\item \textbf{Keywords:} The keywords for header input and output are stored in \spirouKeywords. This contains keyword definitions in the form of a python list:  \\

	\begin{pythonbox}
	kw_VARIABLE = ['KEYWORD', 'Default value', 'Comment']
	\end{pythonbox}

	\noindent where the 'KEYWORD' is the key in the FITs REC header file, with the value and comment defined in the next positions. i.e. in a FITs REC header reader one would expect

	\begin{thighlight}
	\begin{tabular}{l c r c l}
	KEYWORD & = & Default value & / Comment \\
	\end{tabular}
	\end{thighlight}


	\item \textbf{Constants and Pseudo-constants:} These are stored in \spirouConst, they range from simple objects (strings, integers, float, lists, python dictionaries etc) to more complicated `pseudo-constants' that are constructed themselves from other constants. These are kept private (i.e. no mentioned in the user manual) as they should not need be changed by the average user.

\end{itemize}

\fi





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
\section{Global variables}
\label{ch:variables:global}
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{itemize}
% DRS_NAME
\ifdevguide
\item \label{text:drs_name} \ParameterEntry{DRS Name}
{Defines the data reduction software name. Value must be a valid string.}
{DRS\_NAME}{SPIROU}
{\AllRecipes}{\spirouConst.NAME()}{\AllRecipes}{Private}
\fi

% DRS_VERSION
\ifdevguide
\item \label{text:drs_version} \ParameterEntry{DRS Version}
{Defines the data reduction software version. Value must be a valid string.}
{DRS\_VERSION}{0.0.1}
{\AllRecipes}{\spirouConst.VERSION()}{\AllRecipes}{Private}
\fi


% DRS_RELEASE
\ifdevguide
\item \ParameterEntry{Release type}
{Defines the current release type or state of the DRS. Value must be a valid string. This could explain the current state or just distinguish between alpha, beta and full releases.}
{release}{'alpha'}
{\AllRecipes}{\spirouConst.RELEASE()}{\AllRecipes}{Private}
\fi

% package
\ifdevguide
\item \ParameterEntry{Package name}
{Defines the name of the python package that all sub-modules are located in. Value must be a string and be the name of a valid python package.}
{package}{SpirouDRS}
{\AllRecipes}{\spirouConst.PACKAGE()}{\AllRecipes}{Private}
\fi

% authors
\ifdevguide
\item \ParameterEntry{authors}
{Defines the authors of the DRS. Value must be a string, author names separated by a comma.}
{authors}{N. Cook, F. Bouchy, E. Artigau, I. Boisse, M. Hobson, C. Moutou}
{\AllRecipes}{\spirouConst.AUTHORS()}{\AllRecipes}{Private}
\fi


% date
\ifdevguide
\item \ParameterEntry{date}
{Defines the last edited date for the DRS. Value must be a string in format YYYY-MM-DD format.}
{date}{2017-11-17}
{None}{\spirouConst.LATEST\_EDIT()}{None}{Private}
\fi


% DRS_PLOT
\item \label{text:drs_plot} \ParameterEntry{Plotting switch}
{Defines whether to show plots (A value of 1 to show plots, a value of 0 to not show plots). Value must be an integer (0 or 1) or boolean (True or False)}
{DRS\_PLOT}{1}
{\AllRecipes}{\configtxtfile}{\AllRecipes}{Public}

% interactive_plots
\ifdevguide
\item \ParameterEntry{Use matplotlib interactive plot environment}
{Defines whether to use the matplotlib interactive plot environment. If True or 1 uses `plot.ion()' and plots do not interrupt the running of code. If False or 0 all plots are run and `plt.show(), plt.close()' is used after each plot (pausing the code and destroying the plots after they are manually closed). This is mostly useful for debugging.}
{interactive\_plots}{True}
{\spirouPlot}{\spirouConst.INTERACITVE\_PLOTS\_ENABLED()}{\spirouPlot variable definition}{Private}
\fi

% DRS_DEBUG
\item \label{text:drs_debug} \ParameterEntry{Debug mode}
{Defines whether we should run the DRS in debug mode. Certain print/log statements and certain graphs only plot in debug mode. On an error the option to enter the python debugger is asked (allows user to look into functions/current memory and see what variables are currently defined. Value must be an integer. Value must be an integer where:
\begin{itemize}
\item 0 = No debug
\item 1 = Level 1 debug \begin{todo}Define level 1 debug\end{todo}
\item 2 = Level 2 debug \begin{todo}Define level 2 debug\end{todo}
\end{itemize}
}
{DRS\_DEBUG}{0}
{\AllRecipes}{\configtxtfile}{\AllRecipes}{Public}

% DEBUG
\ifdevguide
\item \PseudoParamEntry{Debugging mode controller}
{Controls the debug level (from \definevariable{text:drs_debug}{DRS\_DEBUG})}
{debug}
{\AllRecipes}{\spirouConst.DEBUG()}{\AllRecipes}
\fi

% ic_display_timeout
\item \ParameterEntry{Plot interval}
{Set the interval between plots in seconds (for certain interactive graphs). Value must be a valid float larger than zero.}
{ic\_display\_timeout}{0.5}{\callocRAW}{\constantsfile}{}{Public}
\DevNote{Should this be public?}

\end{itemize}






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
\section{Directory variables}
\label{ch:variables:directory}
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{itemize}

\item \label{text:tdata} \ParameterEntry{The data directory}
{Defines the path to the data directory. Value must be a string containing a valid file location.}
{TDATA}{/drs/data/}{\AllRecipes}{\configtxtfile}{\spirouConst}{Public}

\item \label{text:drs_root} \ParameterEntry{The installation directory}
{Defines the installation directory (\InstallDIR). Value must be a string containing a valid file location.}
{DRS\_ROOT}{/drs/INTROOT/}{\AllRecipes}{\configtxtfile}{\spirouConst}{Public}


\item \label{text:drs_data_raw} \ParameterEntry{The raw data directory}
{Defines the directory that the reduced data will be saved to/read from. Value must be a string containing a valid file location.}
{DRS\_DATA\_RAW}{/drs/data/raw}{\AllRecipes}{\configtxtfile}{\spirouConst}{Public}


\item \label{text:drs_data_reduc} \ParameterEntry{The reduced data directory}
{Defines the directory that the reduced data will be saved to/read from. Value must be a string containing a valid file location.}
{DRS\_DATA\_REDUC}{/drs/data/reduced}{\AllRecipes}{\configtxtfile}{\spirouConst}{Public}


\item \label{text:drs_calib_db} \ParameterEntry{The calibration database and calibration file directory}
{Defines the directory that the calibration files and database will be saved to/read from. Value must be a string containing a valid file location.}
{DRS\_CALIB\_DB}{/drs/data/calibDB}{\AllRecipes}{\configtxtfile}{\spirouConst}{Public}


\item \label{text:drs_data_msg} \ParameterEntry{The log directory}
{Defines the directory that the log messages are stored in. Value must be a string containing a valid file location.}
{DRS\_DATA\_MSG}{/drs/data/msg}{\AllRecipes}{\configtxtfile}{\spirouConst}{Public}


\item \label{text:drs_data_working} \ParameterEntry{The working directory}
{Defines the working directory. Value must be a string containing a valid file location.}
{DRS\_DATA\_WORKING}{/drs/data/tmp/}{\AllRecipes}{\configtxtfile}{\spirouConst}{Public}


\end{itemize}





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
\section{Image variables}
\label{ch:variables:image}
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{itemize}

% Resize blue window (has to be defined manually)
\item 
\begin{minipage}[t]{\textwidth}
\textbf{Resizing blue window (\textcolor{red}{ic\_ccd\{x/y\}\_blue\_\{low/high\}})}

\begin{thighlight}
\textcolor{brown}{The blue window used in \calDARK. Each value must be a integer between 0 and the maximum array size in each dimension.} 

\begin{tabular}{>{\color{red}}l c l}
&&\\
ic\_ccdx\_blue\_low &=& 2048-200 \\
ic\_ccdx\_blue\_high &=& 2048-1500 \\
ic\_ccdy\_blue\_low &=& 2048-20 \\
ic\_ccdy\_blue\_high &=& 2048-350 \\
&&\\
\textcolor{blue}{Used in:}  & \multicolumn{2}{p{10cm}}{\calDARK} \\
\textcolor{blue}{Defined in:} & \multicolumn{2}{p{10cm}}{\constantsfile} \\
\ifdevguide
\textcolor{blue}{Called in:} & \multicolumn{2}{p{10cm}}{\textcolor{codegreen}{\calDARK.\progMAIN}} \\
\textcolor{blue}{Level:} & \multicolumn{2}{p{10cm}}{Public} \\
\fi
\end{tabular}
\end{thighlight}
\end{minipage}


% Resize red window (has to be defined manually)
\item 
\begin{minipage}[t]{\textwidth}
\textbf{Resizing red window (\textcolor{red}{ic\_ccd\{x/y\}\_red\_\{low/high\}})}

\begin{thighlight}
\textcolor{brown}{The blue window used in \calDARK. Each value must be a integer between 0 and the maximum array size in each dimension.} 

\begin{tabular}{>{\color{red}}l c l}
&&\\
ic\_ccdx\_red\_low  & =  & 2048-20 \\
ic\_ccdx\_red\_high &  = &  2048-1750 \\
ic\_ccdy\_red\_low  & =  & 2048-1570 \\
ic\_ccdy\_red\_high &  = &  2048-1910 \\
&&\\
\textcolor{blue}{Used in:}  & \multicolumn{2}{p{10cm}}{\calDARK} \\
\textcolor{blue}{Defined in:} & \multicolumn{2}{p{10cm}}{\constantsfile} \\
\ifdevguide
\textcolor{blue}{Called in:} & \multicolumn{2}{p{10cm}}{\textcolor{codegreen}{\calDARK.\progMAIN}} \\
\textcolor{blue}{Level:} & \multicolumn{2}{p{10cm}}{Public} \\
\fi
\end{tabular}
\end{thighlight}
\end{minipage}



% Resize image (has to be defined manually)
\item 
\begin{minipage}[t]{\textwidth}
\textbf{Resizing red window (\textcolor{red}{ic\_ccd\{x/y\}\_\{low/high\}})}

\begin{thighlight}
\textcolor{brown}{The blue window used in \calDARK. Each value must be a integer between 0 and the maximum array size in each dimension.} 

\begin{tabular}{>{\color{red}}l c l}
&&\\
ic\_ccdx\_low &=& 5 \\
ic\_ccdx\_high &=& 2040 \\
ic\_ccdy\_low &=& 5 \\
ic\_ccdy\_high &=& 1935 \\
&&\\
\textcolor{blue}{Used in:}  & \multicolumn{2}{p{10cm}}{\callocRAW, \calSLIT, \calFFraw, \calextractRAW, \calDRIFTRAW} \\
\textcolor{blue}{Defined in:} & \multicolumn{2}{p{10cm}}{\constantsfile} \\
\ifdevguide
\textcolor{blue}{Called in:} & \multicolumn{2}{p{10cm}}{\textcolor{codegreen}{\callocRAW\progMAIN, \calSLIT\progMAIN, \calFFraw\progMAIN, \calextractRAW\progMAIN, \calDRIFTRAW.\progMAIN}} \\
\textcolor{blue}{Level:} & \multicolumn{2}{p{10cm}}{Public} \\
\fi
\end{tabular}
\end{thighlight}
\end{minipage}


% Avaiable fiber types
\item \label{text:fiber_types} \ParameterEntry{Available fiber types}
{Defines the type of fiber we have (used in various codes). Theses are define in a python list of string, where the earlier a fiber is in the list the more it takes priority in searches (i.e. AB over A or B if AB is first)}
{fiber\_types}
{\lstinline[style=pythoninline]| ['AB', 'A', 'B', 'C'] |}
{\calextractRAW, \calDRIFTE}{\constantsfile}{\calextractRAW.\progMAIN, \spirouStartup.get\_fiber\_type()}{Public}


\end{itemize}






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
\clearpage
\newpage
\section{Fiber variables}
\label{ch:variables:fiber}
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

These variables are defined for each type of fiber and thus are defined as a python dictionary of values \ifdevguide (read using the python `eval' function) \fi. As such they all must contain the same dictionary keys (currently `AB', `A', `B' and `C'). 

\DevNote{For python to combine these at run time the suffix `\_fpall' must be used (thus once a fiber is defined the code will know to extract the key before the suffix). i.e. for variable `nbfib\_fpall' and a fiber `AB' the extracted parameter will be `nbfib' with the value in the dictionary corresponding to the `AB' key.}

\begin{itemize}

% nbfib
\item \ParameterEntry{Number of fibers}
{This describes the number of fibers of a given type. Must be a python dictionary with identical keys to all other fiber parameters (each value must be an integer).}
{nbfib\_fpall}
{\lstinline[style=pythoninline]| \{'AB':2, 'A':1, 'B':1, 'C':1\} |}
{\callocRAW}{\constantsfile}
{\callocRAW.\progMAIN}{Public}

% ic_first_order_jump_fpall
\item \ParameterEntry{Order skip number}
{Describes the number of orders to skip at the start of an image. Must be a python dictionary with identical keys to all other fiber parameters (each value must be an integer).}
{ic\_first\_order\_jump\_fpall}
{\lstinline[style=pythoninline]| \{'AB':2, 'A':0, 'B':0, 'C':0\} |}
{\callocRAW}{\constantsfile}
{\callocRAW.\progMAIN}{Public}

% ic_locnbmaxo_fpall
\item \ParameterEntry{Maximum order numbers}
{Describes the maximum allowed number of orders. Must be a python dictionary with identical keys to all other fiber parameters (each value must be an integer).}
{ic\_locnbmaxo\_fpall}
{\lstinline[style=pythoninline]| \{'AB':72, 'A':36, 'B':36, 'C':36\} |}
{\callocRAW}{\constantsfile}
{\callocRAW.\progMAIN}{Public}

% qc_loc_nbo_fpall
\item \ParameterEntry{Number of orders to fit (QC)}
{Quality control parameter for the number of orders on fiber to fit. Must be a python dictionary with identical keys to all other fiber parameters (each value must be an integer).}
{qc\_loc\_nbo\_fpall}
{\lstinline[style=pythoninline]| \{'AB':72, 'A':36, 'B':36, 'C':36\} |}
{\callocRAW}{\constantsfile}
{\callocRAW.\progMAIN}{Public}
\DevNote{Should this be merged with `ic\_locnbmaxo\_fpall'?}


% fib_type_fpall
\item \ParameterEntry{Fiber types for this fiber}
{The fiber type(s) -- as a list -- for this fiber. Must be a python dictionary with identical keys to all other fiber parameters (each value must be a list of strings).}
{fib\_type\_fpall}
{\lstinline[style=pythoninline]| \{'AB':["AB"], 'A':["A"], 'B':["B"], 'C':["C"]\} |}
{\calFFraw}{\constantsfile}
{\calFFraw.\progMAIN}{Public}
\DevNote{This is not be needed but is in here due to a loop in \calFFraw}

% ic_ext_range1_fpall
\item \ParameterEntry{Half-zone extraction width (left/top)}
{The pixels are extracted from the center of the order out to the edges in the row direction (y-axis), i.e. defines the illuminated part of the order - this number defines the \textbf{top} side (if one requires a symmetric extraction around the order fit both range 1 and range 2 -- below -- should be the same). This can also be used to extract A and B separately (where the fit order is defined at the center of the AB pair). Must be a python dictionary with identical keys to all other fiber parameters.}
{ic\_ext\_range1\_fpall}
{\lstinline[style=pythoninline]| \{'AB':14.5, 'A':0.0, 'B':14.5, 'C':7.5\} |}
{\calFFraw}{\constantsfile}
{\calextractRAW.\progMAIN, \spirouEXTOR.extract\_tilt\_weight\_order2(), \spirouPlot.ff\_sorder\_fit\_edges()}{Public}
\DevNote{Formally this was called `plage1' in \calFFraw}

% ic_ext_range2_fpall
\item \ParameterEntry{Half-zone extraction width (right/bottom)}
{The pixels are extracted from the center of the order out to the edges in the row direction (y-axis), i.e. defines the illuminated part of the order - this number defines the \textbf{bottom} side (if one requires a symmetric extraction around the order fit both range 1 and range 2 -- below -- should be the same). This can also be used to extract A and B separately (where the fit order is defined at the center of the AB pair). Must be a python dictionary with identical keys to all other fiber parameters.}
{ic\_ext\_range2\_fpall}
{\lstinline[style=pythoninline]| \{'AB':14.5, 'A':14.5, 'B':0.0, 'C':7.5\} |}
{\calFFraw, \calextractRAW}{\constantsfile}
{\calFFraw.\progMAIN, \calextractRAW.\progMAIN, \spirouEXTOR.extract\_tilt\_weight\_order2(), \spirouPlot.ff\_sorder\_fit\_edges()}{Public}
\DevNote{Formally this was called `plage2' in \calFFraw}

% ic_ext_range_fpall
\item \ParameterEntry{Half-zone extraction width for full extraction}
{The pixels are extracted from the center of the order out to the edges in the row direction (y-axis), i.e. defines the illuminated part of the order. In \calextractRAW both sides of the fit order are extracted at with the same width (symmetric). Must be a python dictionary with identical keys to all other fiber parameters.}
{ic\_ext\_range\_fpall}
{\lstinline[style=pythoninline]| \{'AB':14.5, 'A':14.5, 'B':14.5, 'C':7.5\} |}
{\calextractRAW}{\constantsfile}
{\spirouEXTOR.extract\_order(), \spirouEXTOR.extract\_tilt\_order(), \spirouEXTOR.extract\_tilt\_weight\_order(), \spirouEXTOR.extract\_weight\_order()}{Public}
\DevNote{Formally this was called `plage' in \calextractRAW}

% loc_file_fpall
\item \ParameterEntry{Localization fiber for extraction  }
{Defines the localization fiber to use for each fiber type. This is the file in calibDB that is used i.e. the keyword \masterCALIBDBfile used will be \`LOC\_\{loc\_file\_fpall\}' (e.g. for fiber=`AB' use `LOC\_AB'). Must be a python dictionary with identical keys to all other fiber parameters.}
{loc\_file\_fpall}
{\lstinline[style=pythoninline]| \{'AB':'AB', 'A':'AB', 'B':'AB', 'C':'C'\} |}
{\calextractRAW}{\constantsfile}
{\spirouLOCOR.get\_loc\_coefficients()}{Public}

% orderp_file_fpall
\item \ParameterEntry{Order profile fiber for extraction}
{Defines the order profile fiber to use for each fiber type. This is the file in calibDB that is used i.e. the keyword \masterCALIBDBfile used will be \`ORDER\_PROFILE\_\{orderp\_file\_fpall\}' (e.g. for fiber=`AB' use `ORDER\_PROFILE\_AB'). Must be a python dictionary with identical keys to all other fiber parameters.}
{orderp\_file\_fpall}
{\lstinline[style=pythoninline]| \{'AB':'AB', 'A':'AB', 'B':'AB', 'C':'C'\} |}
{\calextractRAW}{\constantsfile}
{\spirouFITS.read\_order\_profile\_superposition()}{Public}

% ic_ext_d_range_fpall
\item \ParameterEntry{Half-zone extract width \calDRIFTRAW}
{The size in pixels of the extraction away from the order localization fit (to the top and bottom) - defines the illuminated area of the order for extraction. Must be a python dictionary with identical keys to all other fiber parameters.}
{ic\_ext\_d\_range\_fpall}
{\lstinline[style=pythoninline]| \{'AB':14.0, 'A':14.0, 'B':14.0, 'C':7.0\} |}
{\calDRIFTRAW}{\constantsfile}
{\calDRIFTRAW.\progMAIN}{Public}
\DevNote{Formally this was called `ic\_extnbsig' in \calDRIFTRAW}

\end{itemize}






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
\clearpage
\newpage
\section{Dark calibration variables}
\label{ch:variables:dark}
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{itemize}

% dark_qmin
\item \ParameterEntry{Lower percentile for dead pixel stats}
{This defines the lower percentile to be logged for the fraction of dead pixels statistics. Value must be an integer between 0 and 100 (1 sigma below the mean is $\sim$16).}
{dark\_qmin}{5}
{\calDARK}{\constantsfile}
{\spirouImage.measure\_dark()}{Public}

% dark_qmax
\item \ParameterEntry{Upper percentile for dead pixel stats}
{This defines the upper percentile to be logged for the fraction of dead pixels statistics. Value must be an integer between 0 and 100 (1 sigma above the mean is $\sim$84).}
{dark\_qmax}{95}
{\calDARK}{\constantsfile}
{\spirouImage.measure\_dark()}{Public}

% histo\_bins
\item \ParameterEntry{Dark stat histogram bins}
{Defines the number of bins to use in the dark histogram plot. Value must be a positive integer.}
{histo\_bins}{200}
{\calDARK}{\constantsfile}
{\spirouImage.measure\_dark()}{Public}

% histo_range_low
\item \ParameterEntry{Lower bound for the Dark stat histogram}
{Defines the lower bound for the dark statistic histogram. Value must be a float less than (no equal to) the value of `histo\_range\_high'}
{histo\_range\_low}{-0.5}
{\calDARK}{\constantsfile}
{\spirouImage.measure\_dark()}{Public}

% histo_range_high
\item \ParameterEntry{Upper bound for the Dark stat histogram}
{Defines the upper bound for the dark statistic histogram. Value must be a float greater than (not equal to) the value of `histo\_range\_low'}
{histo\_range\_high}{5}
{\calDARK}{\constantsfile}
{\spirouImage.measure\_dark()}{Public}

% dark_cutlimit
\item \label{text:dark_cutlimit} \ParameterEntry{Bad pixel cut limit}
{Defines the bad pixel cut limit in ADU/s. 
\begin{equation}
badpixels = (image > \text{dark\_cut\_limit}) \text{ OR } (\text{non-finite})
\end{equation}}
{dark\_cutlimit}{100.0}
{\calDARK}{\constantsfile}
{\calDARK.\progMAIN}{Public}

\end{itemize}






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
\clearpage
\newpage
\section{Localization calibration variables}
\label{ch:variables:localization}
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{itemize}

% loc_box_size
\item \ParameterEntry{Order profile smoothed box size}
{Defines the size of the order profile smoothing box (from the central pixel minus size to the central pixel plus size). Value must be an integer larger than zero.}
{loc\_box\_size}{10}
{\callocRAW}{\constantsfile}
{\callocRAW.\progMAIN}{Public}


% ic_offset
\item \ParameterEntry{Image row offset}
{The row number (y axis) of the image to start localization at (below this row orders will not be fit). Value must be an integer equal to or larger than zero.}
{ic\_offset}{40}
{\callocRAW}{\constantsfile}
{\callocRAW.\progMAIN }{Public}

% ic_cent_col
\item \ParameterEntry{Central column of the image}
{The column which is to be used as the central column (x-axis), this is the column that is initially used to find the order locations. Value must be an integer between 0 and the number of columns (x-axis dimension).}
{ic\_cent\_col}{1000}
{\callocRAW, \calFFraw, \calextractRAW}{\constantsfile}
{\callocRAW.\progMAIN, \calFFraw.\progMAIN, \calextractRAW.\progMAIN, \spirouBACK.measure\_background\_{\hskip 0pt}and\_get\_central\_pixels(), \spirouPlot.slit\_sorder\_plot(), \spirouEXTOR.extract\_AB\_order(), \spirouLOCOR.find\_order\_centers(), \spirouLOCOR.initial\_order\_fit()}{Public}

% ic_ext_window
\item \ParameterEntry{Localization window row size}
{Defines the size of the localization window in rows (y-axis). Value must be an integer larger than zero and less than the number of rows (y-axis dimension).}
{ic\_ext\_window}{12}
{\callocRAW}{\constantsfile}
{\spirouLOCOR.find\_order\_centers}{Public}
\DevNote{Formally this was called `ic\_ccdcolc' in \callocRAW}

% ic_locstepc
\item \ParameterEntry{Localization window column step}
{For the initial localization procedure interval points along the order (x-axis) are defined and the centers are found, this is used as the first estimate of the order shape. This parameter defines that interval step in columns (x-axis). Value must be an integer larger than zero and less than the number of columns (x-axis dimension).}
{ic\_locstepc}{12}
{\callocRAW}{\constantsfile}
{\spirouLOCOR.find\_order\_centers}{Public}

% ic_image_gap
\item \ParameterEntry{Image gap index}
{Defines the image gap index. The order is skipped if the top of the row (row number - ic\_ext\_window) or bottom of the row (row number + ic\_ext\_window) is inside this image gap index. i.e. a order is skipped if:
\begin{equation}
(\text{top of the row} < \text{ic\_image\_gap})
\text{ OR } 
(\text{bottom of the row} > \text{ic\_image\_gap})
\end{equation}
Value must be an integer between zero and the number of rows (y-axis dimension).
}
{ic\_image\_gap}{0}
{\callocRAW}{\constantsfile}
{\spirouLOCOR.find\_order\_centers}{Public}
\DevNote{This is set to zero and never used in a meaningful way, should it be removed?}


% ic_widthmin
\item \ParameterEntry{Minimum order row size}
{Defines the minimum row width (width in y-axis) to accept an order as valid. If below this threshold order is not recorded. Value must be an integer between zero and the number of rows (y-axis dimension).}
{ic\_widthmin}{5}
{\callocRAW}{\constantsfile}
{\spirouLOCOR.find\_order\_centers}{Public}

% ic_locnbpix
\item \ParameterEntry{Min/Max smoothing box size}
{Defines the half-size of the rows to use when smoothing the image to work out the minimum and maximum pixel values. This defines the half-spacing between orders and is used to estimate background and the maximum signal. Value must be greater than zero and less than the number of rows (y-axis dimension).}
{ic\_locnbpix}{45}
{\callocRAW}{\constantsfile}
{\spirouBACK.measure\_min\_max()}{Public}

% ic_min_amplitude
\item \ParameterEntry{Minimum signal amplitude}
{Defines a cut off (in e-) where below this point the central pixel values will be set to zero. Value must be a float greater than zero.}
{ic\_min\_amplitude}{100.0}
{\callocRAW}{\constantsfile}{\spirouBACK.measure\_background\_{\hskip 0pt}and\_get\_central\_pixels()}
{Public}

% ic_locseuil
\item \ParameterEntry{Normalized background amplitude threshold}
{Defines the normalized amplitude threshold to accept pixels for background calculation (pixels below this normalized value will be used for the background calculation). Value must be a float between zero and one.}
{ic\_locseuil}{0.2}
{\callocRAW}{\constantsfile}{\spirouBACK.measure\_background\_{\hskip 0pt}and\_get\_central\_pixels()}
{Public}

% ic_satseuil
\item \ParameterEntry{Saturation threshold on the order profile plot}
{Defines the saturation threshold on the order profile plot, pixels above this value will be set this value (ic\_satseuil). Value must be a float greater than zero.}
{ic\_satseuil}{64536}
{\callocRAW}{\constantsfile}{\callocRAW.\progMAIN}{Public}


% ic_locdfitc
\item \label{text:ic_locdfitc} \ParameterEntry{Degree of the fitting polynomial for localization position}
{Defines the degree of the fitting polynomial for locating the positions of each order i.e. if value is 1 is a linear fit, if the value is 2 is a quadratic fit. The value must be a positive integer equal to or greater than zero (zero would lead to a constant fit along the column direction (x-axis direction).}
{ic\_locdfitc}{5}
{\callocRAW}{\constantsfile}{\spirouLOCOR.initial\_order\_fit(), \spirouLOCOR.sigmaclip\_order\_fit()}{Public}


% ic_locdfitw
\item \ParameterEntry{Degree of the fitting polynomial for localization width}
{Defines the degree of the fitting polynomial for measuring the width of each order i.e. if value is 1 is a linear fit, if the value is 2 is a quadratic fit. The value must be a positive integer equal to or greater than zero (zero would lead to a constant fit along the row direction (y-axis direction).}
{ic\_locdfitw}{5}
{\callocRAW}{\constantsfile}{\spirouLOCOR.initial\_order\_fit(), \spirouLOCOR.sigmaclip\_order\_fit()}{Public}


% ic_locdfitp
\item \ParameterEntry{Degree of the fitting polynomial for localization position error}
{Defines the degree of the fitting polynomial for locating the positions error of each order i.e. if value is 1 is a linear fit, if the value is 2 is a quadratic fit. The value must be a positive integer equal to or greater than zero (zero would lead to a constant fit along the column direction (x-axis direction).}
{ic\_locdfitp}{3}
{\callocRAW}{\constantsfile}{\spirouKeywords, \callocRAW.\progMAIN, \spirouLOCOR.sigmaclip\_order\_fit()}{Public}
\DevNote{This is only currently used to add the value to the localization file (`\_loco\_\definevariable{text:fiber_types}{fiber}.fits') but not used in any calculation. It could be removed?}


% ic_max_rms_center
\item \ParameterEntry{Maximum RMS for sigma-clipping order fit (positions)}
{Defines the maximum RMS allowed for an order, if RMS is above this value the position with the highest residual is removed and the fit is recalculated without that position (sigma-clipped). Value must be a positive float.
\vspace{0.5cm}
i.e. position fit is recalculated if: 
\begin{equation}
max(RMS) > \text{ic\_max\_rms\_center}
\end{equation}
}
{ic\_max\_rms\_center}{0.2}
{\callocRAW}{\constantsfile}
{\spirouLOCOR.sigmaclip\_order\_fit()}{Public}


% ic_max_ptp_center
\item \ParameterEntry{Maximum peak-to-peak for sigma-clipping order fit (positions)}
{Defines the maximum peak-to-peak value allowed for an order, if the peak to peak is above this value the position with the highest residual is removed and the fit is recalculated without that position (sigma-clipped). Value must be a positive float.
\vspace{0.5cm}
i.e. position fit is recalculated if: 
\begin{equation}
max(|\text{residuals}|) > \text{ic\_max\_ptp\_center}
\end{equation}
}
{ic\_max\_ptp\_center}{0.2}
{\callocRAW}{\constantsfile}{\spirouLOCOR.sigmaclip\_order\_fit()}{Public}


% ic_ptporms_center
\item \ParameterEntry{Maximum peak-to-peak-RMS ratio for sigma-clipping order fit(positions)}
{Defines the maximum ratio of peak-to-peak residuals and rms value allowed for an order, if the ratio is above this value the position with the highest residual is removed and the fit is recalculated without that position (sigma-clipped). Value must be a positive float.
\vspace{0.5cm}
i.e. position fit is recalculated if: 
\begin{equation}
max(|\text{residuals}|)/\text{RMS} > \text{ic\_ptporms\_center}
\end{equation}
}
{ic\_ptporms\_center}{8.0}
{\callocRAW}{\constantsfile}{\spirouLOCOR.sigmaclip\_order\_fit()}{Public}


% ic_max_rms_fwhm
\item \ParameterEntry{Maximum RMS for sigma-clipping order fit (width)}
{Defines the maximum RMS allowed for an order, if RMS is above this value the width with the highest residual is removed and the fit is recalculated without that width (sigma-clipped). Value must be a positive float.
\vspace{0.5cm}
i.e. width fit is recalculated if: 
\begin{equation}
max(RMS) > \text{ic\_max\_rms\_width}
\end{equation}
}
{ic\_max\_rms\_fwhm}{1.0}
{\callocRAW}{\constantsfile}{\spirouLOCOR.sigmaclip\_order\_fit()}{Public}


% ic_max_ptp_fracfwhm
\item \ParameterEntry{Maximum peak-to-peak for sigma-clipping order fit (widths)}
{Defines the maximum peak-to-peak value allowed for an order, if the peak to peak is above this value the width with the highest residual is removed and the fit is recalculated without that width (sigma-clipped). Value must be a positive float.
\vspace{0.5cm}
i.e. width fit is recalculated if: 
\begin{equation}
max(|\text{residuals/data}|)\times100 > \text{ic\_max\_ptp\_fracfwhm}
\end{equation}
}
{ic\_max\_ptp\_fracfwhm}{1.0}
{\callocRAW}{\constantsfile}{\spirouLOCOR.sigmaclip\_order\_fit()}{Public}


% ic_loc_delta_width
\item \ParameterEntry{Delta width 3 convolve shape model}
{Defines the delta width in pixels for the 3 convolve shape model - currently not used. Value must be a positive float.}
{ic\_loc\_delta\_width}{1.85}
{\callocRAW}{\constantsfile}{\callocRAW.\progMAIN, \spirouKeywords}{Public}
\DevNote{This is currently not used (other than saving in the calibDB loco file. Can it be removed?).}


% ic_locopt1
\item \ParameterEntry{Localization archiving option}
{Whether we save the location image with the superposition of the fit (zeros). If this option is 1 or True it will save the file to `\_with-order\_\definevariable{text:fiber_types}{fiber}.fits' if 0 or False it will not save this file. Value must be 1, 0, True or False.}
{ic\_locopt1}{1}
{\callocRAW}{\constantsfile}{\callocRAW.\progMAIN}{Public}


\end{itemize}






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
\clearpage
\newpage
\section{Slit calibration variables}
\label{ch:variables:slit}
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{itemize}

% ic_tilt_coi
\item \ParameterEntry{Tilt oversampling factor}
{Defines the oversampling factor used to work out the tilt of the slit. Value must be an integer value larger than zero.}
{ic\_tilt\_coi}{10}
{\calSLIT}{\constantsfile}{\spirouImage.get\_tilt()}{Public}
\DevNote{Formally this was called `coi' in \calSLIT.}


% ic_facdec
\item \ParameterEntry{Slit fit order plot offset factor}
{Defines an offset of the position fit to show the edges of the illuminated area. (Final offset is $\pm \times$ 2 of this offset away from the order fit. Value must be a positive float.)}
{ic\_facdec}{1.6}
{\calSLIT}{\constantsfile}{\spirouPlot.slit\_sorder\_plot()}{Public}


% ic_tilt_fit
\item \ParameterEntry{Degree of the fitting polynomial for the tilt}
{Defines the degree of the fitting polynomial for determining the tilt i.e. i.e. if value is 1 is a linear fit, if the value is 2 is a quadratic fit.  The value must be a positive integer equal to or greater than zero (zero would lead to a constant fit).}
{ic\_tilt\_fit}{4}
{\calSLIT}{\constantsfile}{\spirouImage.fit\_tilt()}{Public}


% ic_slit_order_plot
\item \ParameterEntry{Selected order in Slit fit order plot}
{Defines the selected order to plot the fit for in the Slit fir order plot. Value must be between zero and the maximum number of orders.}
{ic\_slit\_order\_plot}{10}
{\calSLIT}{\constantsfile}{\spirouPlot.slit\_sorder\_plot()}{Public}


\end{itemize}






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
\clearpage
\newpage
\section{Flat fielding calibration variables}
\label{ch:variables:flatfielding}
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{itemize}

% ic_do_bkgr_subtraction
\item \ParameterEntry{Measure background}
{Define whether to measure the background and do a background subtraction. Value must be True or 1 to do the background measurement and subtraction or be False or 0 to not do the background measurement and subtraction.}
{ic\_do\_bkgr\_subtraction}{0}
{\calFFraw}{\constantsfile}{\calFFraw.\progMAIN}{Public}
\DevNote{Currently even if True or 1 the background is not calculated as the interpol function has not been converted to python.}


% ic_bkgr_window
\item \ParameterEntry{Half-size of background window}
{Defines the half-size (in pixels) of the background window to create a sub-frame to find the minimum $2\times$ ic\_bkgr\_window pixels for which to calculate the background from. Size is used in both row and column (y and x) direction. Value must be an integer between zero and the minimum(row number, column number) (minimum(x-axis dimension, y-axis dimension)).}
{ic\_bkgr\_window}{100}
{\calFFraw}{\constantsfile}{\spirouBACK.measure\_background\_flatfield()}{Public}


% ic_tilt_nbo
\item \ParameterEntry{Number of orders in tilt measurement}
{Defines the number of orders in the tilt measurement file (TILT key in the \masterCALIBDBfile). This is the number of tilts that will be extracted. Value must be an integer larger than zero and smaller than or equal to the total number of orders present in the TILT file.}
{ic\_tilt\_nbo}{36}
{\calFFraw}{\constantsfile}{\spirouFITS.read\_tilt\_file()}{Public}
\DevNote{This can probably be removed and replaced with a check to the TILT file - to automatically determine how many orders there should be.}
\DevNote{This was formally called `nbo' and was hard coded in \calFFraw.}


% ic_ff_sigdet
\item \ParameterEntry{The manually set sigdet for flat fielding.}
{This defines the sigdet to use in the weighted tilt extraction. Set to -1 to use from the input file (`fitsfilename') HEADER. Value must be either -1 or a positive float.}
{ic\_ff\_sigdet}{100.0}
{\calFFraw}{\constantsfile}{\calFFraw.\progMAIN}{Public}


% ic_extfblaz
\item \ParameterEntry{Half size blaze window}
{Defines the distance from the central column that should be used to measure the blaze for each order. Value must be an integer greater than zero and less than half the number of columns (x-axis dimension).}
{ic\_extfblaz}{50}
{\calFFraw}{\constantsfile}{\calFFraw.\progMAIN}{Public}


% ic_blaze_fitn
\item \ParameterEntry{Fit degree for the blaze polynomial fit}
{Defines the degree of the fitting polynomial for fitting the blaze function of each order i.e. if value is 1 is a linear fit, if the value is 2 is a quadratic fit. The value must be a positive integer equal to or greater than zero (zero would lead to a constant fit along the column direction (x-axis direction).}
{ic\_blaze\_fitn}{5}
{\calFFraw}{\constantsfile}{\calFFraw.\progMAIN}{Public}


% ic_ff_order_plot
\item \ParameterEntry{Selected order for flat fielding plot}
{Defines the selected order to plot on the flat fielding image plot. Value must be a integer between zero and the number of orders.}
{ic\_ff\_order\_plot}{5}
{\calFFraw}{\constantsfile}{\spirouPlot.ff\_sorder\_fit\_edges}{Public}
\DevNote{This was formally called `ic\_plot\_order' in \calFFraw.}

% ic_ff_plot_all_orders
\item \ParameterEntry{Plot all order fits for flat fielding plot}
{If True or 1, instead of plotting the selected order from ic\_ff\_order\_plot will plot the order fits (and edges) for all orders. This is slower than just plotting one. Value must be True or 1 or False or 0.}
{ic\_ff\_plot\_all\_orders}{0}
{\calFFraw}{\constantsfile}{\calFFraw.\progMAIN}{Public}
\DevNote{This is a new plot, instead of plotting one selected order plots all orders - this is obviously slightly slower than just plotting one example order.}

\end{itemize}








%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
\clearpage
\newpage
\section{Extraction calibration variables}
\label{ch:variables:extraction}
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{itemize}

% ic_extopt
\item \ParameterEntry{Extraction option - rough extraction}
{Extraction option for rough extraction:
\begin{itemize}
\item if 0 extraction by summation over a constant range
\item if 1 extraction by summation over constants sigma (not currently available)
\item if 2 horne extraction without cosmic elimination (not currently available)
\item if 3 horne extraction with cosmic elimination (not currently available)
\end{itemize}
 Used for estimating the slit tilt and in calculating the blaze/flat fielding. Value must be a integer between 0 and 3.
}
{ic\_extopt}{0}
{\calSLIT, \calFFraw}{\constantsfile}
{\spirouEXTOR.extract\_AB\_order(), \spirouEXTOR.extract\_order}{Public}

% ic_extnbsig
\item \ParameterEntry{Extraction distance - rough extraction}
{The pixels are extracted from the center of the order out to the edges in the row direction (y-axis), i.e. defines the illuminated part of the order). Used for estimating the slit tilt and in calculating the blaze/flat fielding. Value must be a positive float between 0 and the total number of rows (y-axis dimension).}
{ic\_extnbsig}{2.5}
{\calSLIT, \calFFraw}{\constantsfile}{\spirouEXTOR.extract\_AB\_order}{Public}


% ic_ext_all
\item \ParameterEntry{Extraction type}
{Defines which type of extract should be used in \calextractRAW. This variable is overwritten if using \calextractRAWAB or \calextractRAWC. The value must be one of the following:
\begin{itemize}
\item simple \dotfill just does extraction as is.
\item tilt \dotfill does the extraction and corrects for tilt
\item weight \dotfill does the extraction with a weighting for bad pixels
\item tiltweight \dotfill does the extraction + `tilt' + `weight'
\item all \dotfill performs all extractions (saves separately). The E2DS file=`weight'.
\end{itemize}
Value should be a python string with one of the above values only. Any other value will cause an error and a recipe to exit.
}
{ic\_extact\_type}{tiltweight}
{\calextractRAW}{\constantsfile}{\calextractRAW.\progMAIN}{Public}
\DevNote{For all we should probably use tiltweight but as \calextractRAWAB and \calextractRAWC currently use weight for the E2DS this is set to reproduce this.}

\item \ParameterEntry{Manually set the extraction sigdet}
{Set the sigdet used in the extraction process instead of using the sigdet in the FITS rec HEADER file. If the value is set to -1 the sigdet from the HEADER is used instead.}
{ic\_ext\_sigdet}{100}
{\calextractRAW}{\constantsfile}{\calextractRAW.\progMAIN}{Public}
\DevNote{Why is this value used and not the value in the header file?}

% ic_drift_order_plot
\item \ParameterEntry{Selected order in extract fit order plot}
{Defines the selected order to plot the fit for in the extract fit order plot. Value must be between zero and the maximum number of orders.}
{ic\_ext\_order\_plot}{20}
{\calextractRAW}{\constantsfile}{\spirouPlot. ext\_selected\_order\_plot()}{Public}

\end{itemize}







%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
\clearpage
\newpage
\section{Drift calibration variables}
\label{ch:variables:drift}
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{itemize}


% ic_drift_noise
\item \ParameterEntry{Noise value for SNR drift calculation}
{Define the noise value for the signal to noise ratio in the drift calculation.
\begin{equation}
snr = flux/\sqrt(\text{flux} + \text{noise}^2)
\end{equation}
Value must be a float larger than zero.
}
{ic\_drift\_noise}{100.0}
{\calDRIFTRAW}{\constantsfile}{\calDRIFTRAW.\progMAIN}{Public}


% ic_drift_maxflux
\item \ParameterEntry{The maximum flux for a good (unsaturated) pixel}
{Defines the maximum flux to define a good pixel. This pixels and those that surround it will not be used in determining the RV parameters. Value must be a float greater than zero.}
{ic\_drift\_maxflux}{1.e9}
{\calDRIFTRAW}{\constantsfile}{\calDRIFTRAW.\progMAIN}{Public}


% ic_drift_boxsize
\item \ParameterEntry{Saturated pixel flag size}
{Defines the number of pixels around a saturated pixel to flag as unusable (and hence not used in determining the RV parameters). Value must be a integer larger than zero.}
{ic\_drift\_boxsize}{12}
{\calDRIFTRAW}{\constantsfile}{\calDRIFTRAW.\progMAIN}{Public}


% drift_nlarge
\item \ParameterEntry{Large number of files for skip}
{Defines the number of files that is large enough to require the `drift\_file\_skip' parameter (only uses one file in every `drift\_file\_skip' files). This is done to speed up the code and avoid a bug. Value must be an integer larger than zero.}
{drift\_nlarge}{300}
{\calDRIFTRAW, \calDRIFTE, \calDRIFTPEAK}{\constantsfile}{\calDRIFTRAW.\progMAIN, \calDRIFTE.\progMAIN, \calDRIFTPEAK.\progMAIN}{Public}
\DevNote{Has this bug been fixed, do we need to skip for a large number of files?}


% drift_file_skip
\item \ParameterEntry{Large number of files skip parameter (\calDRIFTRAW)}
{Defines how many files we skip. This is done by selecting one file every `drift\_file\_skip' files. i.e. if skip is 3 the code uses every 3rd file to calculate the drift. Value must be an integer larger than zero. A value of 1 is equivalent to no skipping of files regardless of the file number.}
{drift\_file\_skip}{3}
{\calDRIFTRAW}{\constantsfile}{\calDRIFTRAW.\progMAIN}{Public}


% drift_e2ds_file_skip
\item \ParameterEntry{Large number of files skip parameter (\calDRIFTE)}
{Defines how many files we skip. This is done by selecting one file every `drift\_file\_skip' files. i.e. if skip is 3 the code uses every 3rd file to calculate the drift. Value must be an integer larger than zero. A value of 1 is equivalent to no skipping of files regardless of the file number.}
{drift\_e2ds\_file\_skip}{1}
{\calDRIFTE}{\constantsfile}{\calDRIFTE.\progMAIN}{Public}


% ic_drift_cut_raw
\item \ParameterEntry{Number of sigmas to cut in cosmic renormalization (\calDRIFTRAW)}
{Defines the number of standard deviations to remove fluxes at (and replace with the reference flux) for \calDRIFTRAW. Value must be a float larger than zero.}
{ic\_drift\_cut\_raw}{3}
{\calDRIFTRAW}{\constantsfile}{\calDRIFTRAW.\progMAIN}{Public}


% ic_drift_cut_e2ds
\item \ParameterEntry{Number of sigmas to cut in cosmic renormalization (\calDRIFTE)}
{Defines the number of standard deviations to remove fluxes at (and replace with the reference flux) for \calDRIFTE. Value must be a float larger than zero.}
{ic\_drift\_cut\_e2ds}{4.5}
{\calDRIFTE}{\constantsfile}{\calDRIFTE.\progMAIN}{Public}


% ic_drift_n_order_max
\item \ParameterEntry{Number of orders to use in drift}
{Defines the number of orders to use (starting from zero to maximum number). This is used to get the median drift. Value must be an integer between 0 and the maximum number of orders.}
{ic\_drift\_n\_order\_max}{28}
{\calDRIFTRAW}{\constantsfile}{\calDRIFTRAW.\progMAIN}{Public}


% ic_drift_type_raw
\item \ParameterEntry{Define the way to combine orders for drift (for \calDRIFTRAW)}
{Defines the way to calculate the combine order drifts (to one drift per image) should either be 'weighted mean' (Equation \ref{equation:drift_type_wmean_1}) or 'median' (Equation \ref{equation:drift_type_median_1}) for \calDRIFTRAW.
\begin{equation}
\label{equation:drift_type_wmean_1}
\text{drift} = \frac{\sum{(\text{drift}_i * w_i)}}{\sum{w_i}}
\end{equation}
\noindent where $w_i$ is $1/\Delta v_{rms}$
\begin{equation}
\label{equation:drift_type_median_1}
\text{drift} = \text{median}(\text{drift}_i)
\end{equation}
\noindent Value should be a valid python string either `median' or `weighted mean'.
}
{ic\_drift\_type\_raw}{median}
{\calDRIFTRAW}{\constantsfile}{\calDRIFTRAW.\progMAIN}{Public}


% ic_drift_type_e2ds
\item \ParameterEntry{Define the way to combine orders for drift \calDRIFTE)}
{Defines the way to calculate the combine order drifts (to one drift per image) should either be 'weighted mean' (Equation \ref{equation:drift_type_wmean_2}) or 'median' (Equation \ref{equation:drift_type_median_2}) for \calDRIFTE.
\begin{equation}
\label{equation:drift_type_wmean_2}
\text{drift} = \frac{\sum{(\text{drift}_i * w_i)}}{\sum{w_i}}
\end{equation}
\noindent where $w_i$ is $1/\Delta v_{rms}$
\begin{equation}
\label{equation:drift_type_median_2}
\text{drift} = \text{median}(\text{drift}_i)
\end{equation}
\noindent Value should be a valid python string either `median' or `weighted mean'.
}
{ic\_drift\_type\_e2ds}{weighted mean}
{\calDRIFTE}{\constantsfile}{\calDRIFTE.\progMAIN}{Public}

% ic_drift_order_plot
\item \ParameterEntry{Selected order in drift fit order plot}
{Defines the selected order to plot the fit for in the drift fit order plot. Value must be between zero and the maximum number of orders.}
{ic\_drift\_order\_plot}{20}
{\calDRIFTRAW, \calDRIFTE}{\constantsfile}{\spirouPlot. drift\_plot\_selected\_wave\_ref()}{Public}

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
\clearpage
\newpage
\section{Drift-Peak calibration variables}
\label{ch:variables:driftpeak}
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{itemize}

% ic_drift_peak_n_order_min
\item \label{text:ic_drift_peak_n_order_min} \ParameterEntry{First order to use in drift-peak}
{Defines the first order to use (from this to \definevariable{text:ic_drift_peak_n_order_max}{ic\_drift\_peak\_n\_order\_max}). This is used to get the median drift. Value must be an integer greater than or equal to 0 and less than \definevariable{text:ic_drift_peak_n_order_max}{ic\_drift\_peak\_n\_order\_max}.}
{ic\_drift\_peak\_n\_order\_min}{2}
{\calDRIFTPEAK}{\constantsfile}{\calDRIFTPEAK.\progMAIN}{Public}

% ic_drift_peak_n_order_max
\item \label{text:ic_drift_peak_n_order_max} \ParameterEntry{Last order to use in drift-peak}
{Defines the last order to use (from \definevariable{text:ic_drift_peak_n_order_min}{ic\_drift\_peak\_n\_order\_min} to this). This is used to get the median drift. Value must be an integer greater than \definevariable{text:ic_drift_peak_n_order_min}{ic\_drift\_peak\_n\_order\_min} and less than or equal to the maximum number of orders.}
{ic\_drift\_peak\_n\_order\_max}{30}
{\calDRIFTPEAK}{\constantsfile}{\calDRIFTPEAK.\progMAIN}{Public}

% drift_peak_file_skip
\item \ParameterEntry{Large number of files skip parameter (\calDRIFTE)}
{Defines how many files we skip. This is done by selecting one file every `drift\_file\_skip' files. i.e. if skip is 3 the code uses every 3rd file to calculate the drift. Value must be an integer larger than zero. A value of 1 is equivalent to no skipping of files regardless of the file number.}
{drift\_e2ds\_file\_skip}{1}
{\calDRIFTPEAK}{\constantsfile}{\calDRIFTPEAK.\progMAIN}{Public}

% drift_peak_minmax_boxsize
\item \ParameterEntry{Minimum box size for min max smoothing}
{Defines the minimum size of the box used to get the minimum and maximum pixel values (specifically minimum pixel values). Each box (defined as the pixel position $\pm$box size) is used to work out the background value for that pixel. Value must be an integer larger than zero and less than half the number of columns (x-dimension).}
{drift\_peak\_minmax\_boxsize}{6}
{\calDRIFTPEAK}{\constantsfile}{\calDRIFTPEAK.\progMAIN}{Public}

% drift_peak_border_size
\item \label{text:drift_peak_border_size} \ParameterEntry{Image column (x-dim) border size}
{Defines the number of pixels on either side of an image that should not be used to find FP peaks. This size must be larger to or equal to \definevariable{text:drift_peak_fpbox_size}{drift\_peak\_fpbox\_size}, therefore the fit to an individual FP does not go off the edge of the image. Value must be an integer larger to or equal to \definevariable{text:drift_peak_fpbox_size}{drift\_peak\_fpbox\_size} and less than and less than half the number of columns (x-dimension).}
{drift\_peak\_border\_size}{3}
{\calDRIFTPEAK}{\constantsfile}{\spirouRV.create\_drift\_file()}{Public}

% drift_peak_fpbox_size
\item \label{text:drift_peak_fpbox_size} \ParameterEntry{Box size for fitting individual FP peak.}
{Defines the half-box size (i.e. central position $\pm$box size) of the box used to fit an individual FP peak. This size must be large enough to fit a peak but not too large as to encompass multiple FP peaks. The value must be an integer larger than zero and smaller than or equal to \definevariable{text:drift_peak_border_size}{drift\_peak\_border\_size} (to avoid fitting off the edges of the image).}
{drift\_peak\_fpbox\_size}{3}
{\calDRIFTPEAK}{\constantsfile}{\spirouRV.create\_drift\_file(), \spirouRV.get\_drift()}{Public}

% drift_peak_min_nfp_peak
% \item \ParameterEntry{Minimum normalized flux for valid FP peak}
% {Defines the minimum normalized flux a valid FP peak must have in order to be recognized as an FP peak (before the peak fitting is done). At this point the FP peak is normalised so the maximum is around a value of 1.0. If a peaks maximum is below this threshold it will not be used as a valid FP in finding the drifts. Value must be a float larger than zero and less than 1.0}
% {drift\_peak\_min\_nfp\_peak}{0.25}
% {\calDRIFTPEAK}{\constantsfile}{\spirouRV.create\_drift\_file()}{Public}


% drift_peak_peak_sig_lim
\item \ParameterEntry{Minimum sigma above median for valid peak}
{Defines the flux a valid peak must have in order to be recognized as a valid peak (before the peak fitting is done). If a peaks meaximum is below this threshold it will not be used as a valid peak in finding the drifts. Value is a dictionary containing keys equivalient to the lamp types (currently this is 'fp' and 'hc'. The values of each must be a float greater than 1 for above the median and, between zero and 1 for below the median).}
{drift\_peak\_peak\_sig\_lim}
{\lstinline[style=pythoninline]| {'fp':1.0, 'hc':7.0} |}
{\calDRIFTPEAK}{\constantsfile}{\spirouRV.create\_drift\_file()}{Public}


% drift_peak_inter_peak_spacing
\item \ParameterEntry{Minimum spacing between valid peaks}
{Defines the minimum spacing peaks must have (between neighbouring peaks) in order to recognized as valid peaks (before the peak fitting is done). If peak is closer than this sepration to a previous peak the peak will not be used as a valid peak in finding the drifts. Value must be an integer greater than zero.}
{drift\_peak\_inter\_peak\_spacing}{5}
{\calDRIFTPEAK}{\constantsfile}{\spirouRV.create\_drift\_file()}{Public}


% drift_peak_exp_width
\item \label{text:drift_peak_exp_width} \ParameterEntry{Expected width of FP peaks}
{Defines the expected width of the FP peaks. Parameter is used to `normalise' the peaks which are then subsequently removed if:
\begin{equation}
\text{normalized FP FWHM} > \text{drift\_peak\_norm\_width\_cut}
\end{equation}
this is equivalent to:
\begin{equation}
\text{FP FWHM} > (\text{drift\_peak\_exp\_width} + \text{drift\_peak\_norm\_width\_cut})
\end{equation}
Value must be a float larger than zero and less than the number of columns (x-dimension).
}
{drift\_peak\_exp\_width}{0.8}
{\calDRIFTPEAK}{\constantsfile}{\spirouRV.remove\_wide\_peaks(), \spirouRV.get\_drift()}{Public}

% drift_peak_norm_width_cut
\item \ParameterEntry{Normalized FP width threshold}
{Defines the maximum `normalized' width of FP peaks that is acceptable for a valid FP peak. i.e. widths above this threshold are rejected as valid FP peaks.
This works as follows:
\begin{equation}
\text{normalized FP FWHM} > \text{drift\_peak\_norm\_width\_cut}
\end{equation}
this is equivalent to:
\begin{equation}
\text{FP FWHM} > (\text{drift\_peak\_exp\_width} + \text{drift\_peak\_norm\_width\_cut})
\end{equation}
Value must be a float larger than zero and less than the number of columns (x-dimension) but if \definevariable{text:drift_peak_exp_width}{drift\_peak\_exp\_width} is defined sensibly then this number should be small.
}
{drift\_peak\_norm\_width\_cut}{0.2}
{\calDRIFTPEAK}{\constantsfile}{\spirouRV.remove\_wide\_peaks()}{Public}

% drift_peak_getdrift_gaussfit
\item \ParameterEntry{Get drift via a Gaussian fitting process}
{Defines whether the drift is calculated via a Gaussian fitting process (fitting the targeted order with a Gaussian) -- $\sim\times$10 slower, or adjusts a barycenter to get the drift. Value must be True or 1 to do the Gaussian fit, or False or 0 to use the barycenter adjustment.}
{drift\_peak\_getdrift\_gaussfit}{False}
{\calDRIFTPEAK}{\constantsfile}{\calDRIFTPEAK.\progMAIN}{Public}

% drift_peak_pearsonr_cut
\item \ParameterEntry{Pearson R coefficient (between reference and image)}
{Defines the threshold below which a image is deemed to dissimilar from the reference image to be used. A Pearson R test is performed between the reference image (e2ds file) and the current iteration image (e2ds file), the minimum of all usable orders is then tested. If any order does not pass the criteria:
\begin{equation}
\text{coefficient}_{\text{order}} > \text{drift\_peak\_pearsonr\_cut}
\end{equation}
then the whole image (e2ds file) is rejected. Value must be a float larger than zero and less than 1.0, values should be close to unity for a good fit i.e. 0.97.
}
{drift\_peak\_pearsonr\_cut}{0.9}
{\calDRIFTPEAK}{\constantsfile}{\calDRIFTPEAK.\progMAIN}{Public}
\DevNote{This value is currently set below a recommended level and should be set back to 0.97 as soon as possible, even coefficients at 0.95 are from very bad orders, and orders should be removed. A plot currently is made when a bad file is found (i.e. when the above cut is not met).}

% drift_peak_sigmaclip
\item \ParameterEntry{Sigma clip for found FP peaks}
{Defines the number of sigmas above the median that is used to remove bad FP peaks from the drift calculation process. Value must be a float larger than zero.}
{drift\_peak\_sigmaclip}{1.0}
{\calDRIFTPEAK}{\constantsfile}{\calDRIFTPEAK.\progMAIN}{Public}

% drift_peak_plot_line_log_amp
\item \ParameterEntry{Plot linelist vs log Amplitude}
{Defines whether we plot the line list against log amplitude. Value must be 1 or True to plot, or 0 or False to not plot}
{drift\_peak\_plot\_line\_log\_amp}{False}
{\calDRIFTPEAK}{\constantsfile}{\calDRIFTPEAK.\progMAIN}{Public}


\end{itemize}





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
\clearpage
\newpage
\section{Bad pixel calibration variables}
\label{ch:variables:badpix}
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{itemize}

	% badpix_flat_med_wid
	\item \label{text:badpix_flat_med_wid} \ParameterEntry{Bad pixel median image box width}
	{A similar flat is produced by taking the running median of the flat in the column direction (x-dimension) over a boxcar width of \definevariable{text:badpix_flat_med_wid}{badpix\_flat\_med\_wid}. This assumes that the flux level varies only by a small amount over \definevariable{text:badpix_flat_med_wid}{badpix\_flat\_med\_wid} pixels and that the bad pixels are isolated enough that the median along that box will be representative of the flux they should have if they were not bad. Value should be an integer larger than zero and less than the number of columns (x-axis dimension).}
	{badpix\_flat\_med\_wid}{7}
	{\calbadpix}{\constantsfile}{\spirouImage.normalise\_median\_flat(), \spirouImage.locate\_bad\_pixels()}{Public}
	\DevNote{Formally this was called wmed in \calbadpix}

	% badpix_illum_cut
	\item \ParameterEntry{Bad pixel illumination cut parameter}
	{Threshold below which a pixel is considered unilluminated. As we cut the pixels that fractionally deviate by more than a certain amount (\definevariable{text:badpix_flat_cut_ratio}{badpix\_flat\_cut\_ratio}) this would lead to lots of bad pixels in unilluminated regions of the array. This parameter stops this, as the pixels are normalised this value must be a float greater than zero and less than 1.}
	{badpix\_illum\_cut}{0.05}
	{\calbadpix}{\constantsfile}{\spirouImage.locate\_bad\_pixels()}{Public}
	\DevNote{Formally this was called illum\_cut in \calbadpix}

	% badpix_flat_cut_ratio
	\item \label{text:badpix_flat_cut_ratio} \ParameterEntry{Bad pixel maximum differential pixel cut ratio}{This sets the maximum differential pixel response relative to the expected value. Value must be a float larger than zero.}
	{badpix\_flat\_cut\_ratio}{0.5}
	{\calbadpix}{\constantsfile}{\spirouImage.locate\_bad\_pixels()}{Public}
	\DevNote{Formally this was called cut\_ratio in \calbadpix}

	% badpix_max_hotpix
	\item \ParameterEntry{Bad pixel maximum flux to considered too hot}
	{Defines the maximum flux value to be considered too hot to user.}
	{badpix\_max\_hotpix}{100.0}
	{\calbadpix}{\constantsfile}{\spirouImage.locate\_bad\_pixels()}{Public}
	\DevNote{Formally this was called max\_hotpix in \calbadpix}

\end{itemize}









%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
\clearpage
\newpage
\section{Quality control variables}
\label{ch:variables:qualitycontrol}
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{itemize}

% qc_max_darklevel
\item \ParameterEntry{Maximum dark median level}
{Defines the maximum dark median level in ADU/s. If this is greater than median flux it does not pass the quality control criteria:
\begin{equation}
\text{Median Flux} < \text{qc\_max\_darklevel}
\end{equation}
Value must be a float equal to or larger than zero. 
}
{qc\_max\_darklevel}{0.5}
{\calDARK}{\constantsfile}{\calDARK.\progMAIN}{Public}


% qc_max_dead
\item \ParameterEntry{Maximum percentage of dead pixels}
{Defines the maximum allowed percentage of dead pixels in a dark image. If the number of dead pixels is greater than this it does not pass the quality control criteria:
\begin{equation}
\text{dead pixels} = (\text{pixel value} > \text{dark\_cutlimit}) \text{ and } (\text{pixel value} \neq \text{NaN})
\end{equation}
\begin{equation}
\text{Percentage of dead pixels} < \text{qc\_max\_dead}
\end{equation}
}
{qc\_max\_dead}{20.0}
{\calDARK}{\constantsfile}{\calDARK.\progMAIN}{Public}


% qc_max_dark
\item \ParameterEntry{Maximum percentage of bad dark pixels}
{Defines the maximum allowed percentage of bad dark pixels in a dark image. If the number of dead pixels is greater than this it does not pass the quality control criteria:
\begin{equation}
\text{bad dark pixels} = \text{pixel value} > \text{dark\_cutlimit}
\end{equation}
\begin{equation}
\text{Percentage of bad dark pixels} < \text{qc\_max\_dead}
\end{equation}
}
{qc\_max\_dark}{6.0}
{\calDARK}{\constantsfile}{\calDARK.\progMAIN}{Public}


% qc_dark_time
\item \ParameterEntry{Minimum dark exposure time}
{Defines the minimum dark exposure time. If exposure time (from FITS rec HEADER) is below this the code will exit with `Dark exposure time too short' message. Value must be a float greater than zero.}
{qc\_dark\_time}{599.0}
{\calDARK}{\constantsfile}{\calDARK.\progMAIN}{Public}


% qc_loc_maxlocfit_removed_ctr
\item \ParameterEntry{Maximum points removed in localization position fit}
{Defines the maximum allowed number of points removed in the position fitting process (during localization). If number is more than this it does not pass the quality control criteria: 
\begin{equation}
\text{Number of rejected orders in center fit} >\text{qc\_loc\_maxlocfit\_removed\_ctr}
\end{equation}
Value must be a integer greater than zero.
}
{qc\_loc\_maxlocfit\_removed\_ctr}{1500}
{\callocRAW}{\constantsfile}{\callocRAW.\progMAIN}{Public}


% qc_loc_maxlocfit_removed_wid
\item \ParameterEntry{Maximum points removed in localization width fit}
{Defines the maximum allowed number of points removed in the width fitting process (during localization). If number is more than this it does not pass the quality control criteria: 
\begin{equation}
\text{Number of rejected orders in width fit} >\text{qc\_loc\_maxlocfit\_removed\_width}
\end{equation}
Value must be a integer greater than zero.
}
{qc\_loc\_maxlocfit\_removed\_wid}{105}
{\callocRAW}{\constantsfile}{\callocRAW.\progMAIN}{Public}


% qc_loc_rmsmax_center
\item \ParameterEntry{Maximum allowed RMS in fitting in localization position fit}
{Defines the maximum RMS allowed in the position fitting process (during localization). If the RMs is higher than this value it does not pass the quality control criteria: 
\begin{equation}
\text{Mean rms center fit} > \text{qc\_loc\_rmsmax\_center}
\end{equation}
Value must be a float greater than zero.
}
{qc\_loc\_rmsmax\_center}{100}
{\callocRAW}{\constantsfile}{\callocRAW.\progMAIN}{Public}


% qc_loc_rmsmax_fwhm
\item \ParameterEntry{Maximum allowed RMS in fitting in localization width fit}
{Defines the maximum RMS allowed in the width fitting process (during localization). If the RMs is higher than this value it does not pass the quality control criteria: 
\begin{equation}
\text{Mean rms width fit} > \text{qc\_loc\_rmsmax\_fwhm}
\end{equation}
Value must be a float greater than zero.
}
{qc\_loc\_rmsmax\_fwhm}{500}
{\callocRAW}{\constantsfile}{\callocRAW.\progMAIN}{Public}

% qc_ff_rms
\item \ParameterEntry{Maximum allowed RMS}
{Defines the maximum RMS allowed to accept a flat-field for calibration. Value must be a float greater than zero.}
{qc\_ff\_rms}{0.12}
{\calFFraw}{\constantsfile}{\calFFraw.\progMAIN}{Public}

% qc_loc_flumax 
\item \ParameterEntry{Saturation level reached warning}
{Defines the level above which a warning is generated in the form `SATURATION LEVEL REACHED on Fiber \definevariable{text:fiber_types}{fiber}'. Value must be a float greater than zero.}
{qc\_loc\_flumax}{64500}
{\calFFraw}{\constantsfile}{\calFFraw.\progMAIN}{Public}

% qc_slit_rms
\item \ParameterEntry{Maximum RMS allowed for slit TILT}
{Defines the maximum allowed RMS in the calculated TILT to add TILT profile to the calibration database. Value must be a float larger than zero.}
{qc\_slit\_rms}{0.1}
{\calSLIT}{\constantsfile}{\calSLIT.\progMAIN}{Public}

% qc_slit_min
\item \label{text:c_slit_min} \ParameterEntry{Minimum angle allowed for slit TILT}
{Defines the minimum tilt angle allowed to add TILT profile to the calibration databse. Value must be a float and must be less than \definevariable{text:c_slit_max}{qc\_slit\_max}}
{qc\_slit\_min}{-8.0}
{\calSLIT}{\constantsfile}{\calSLIT.\progMAIN}{Public}

% qc_slit_max
\item \label{text:c_slit_max} \ParameterEntry{Maximum angle allowed for slit TILT}
{Defines the maximum tiult angle allowed to add TILT profile to the calibration databse. Value must be a float and must be greater than \definevariable{text:c_slit_min}{qc\_slit\_min}}
{qc\_slit\_max}{0.0}
{\calSLIT}{\constantsfile}{\calSLIT.\progMAIN}{Public}

% qc_max_signal
\item \label{text:qc_max_signal} \ParameterEntry{Saturation point}
{Defines the maximum signal allowed (when defining saturation limit). Currently this does not contribute to failing the quality test. Value must be a float greater than zero.}
{qc\_max\_signal}{65500}
{\calextractRAW}{\constantsfile}{\calextractRAW.\progMAIN}{Public}
\DevNote{Currently this does not stop the file from passing the quality control criteria, it either should fail or should be removed.}


\end{itemize}







%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
\clearpage
\newpage
\section{Calibration database variables}
\label{ch:variables:calibdb}
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{itemize}

% ic_calibDB_filename
\item \label{text:ic_calibDB_filename} \ParameterEntry{The calibration database master filename}
{Defines the name of the master calibration database text file for use in all calibration database operation.}
{ic\_calibDB\_filename}{master\_calib{\hskip 0pt}\_SPIROU.txt}
{\AllRecipes}{\constantsfile}{\spirouConst.CALIBDB\_MASTERFILE()}{Public}
\DevNote{This should probably be private, unless we want the user to be able to change calibDB files.}


% calib_max_wait
\item \ParameterEntry{Maximum wait time for locked calibration database}
{Defines the maximum time the code waits for the calibration database when it is locked. A locked file is created every time the calibration database is open (and subsequently closed when reading of the database was successful). If a lock file is present the code will wait a maximum of this many seconds and keep checking whether the lock file has been removed. After which time the code will exit with an error. Value must be a positive float greater than zero. Measured in seconds.}
{calib\_max\_wait}{3600}
{\AllRecipes}{\constantsfile}{\spirouCDB.get\_check\_lock\_file()}{Public}


% calib_db_match
\item \ParameterEntry{Calibration database duplicate key handler}
{Defines the mechanism to use in deciding between duplicate keys in the calibration database file. Value must be a string and must be either 'older' or 'closest'. If 'older' the calibration database will only use keys that are older than the timestamp in the input fits file (first argument) using the key \defineinkeyword{text:acqtime1}{kw\_ACQTIME\_KEY}}
{calib\_db\_match}{'closest'}
{\AllRecipes}{\constantsfile}{\spirouCDB.get\_check\_lock\_file()}{Public}

\end{itemize}








\ifdevguide
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
\clearpage
\newpage
\section{Startup variables}
\label{ch:variables:startup}
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{itemize}


% config_folder
\item \label{text:config_folder} \ParameterEntry{Configuration Folder Path}
{Defines the location of the configuration directory relative to the module directory (defined in variable = `package'). Value must be a string containing a valid directory location.}
{config\_folder}{\configdirrelpath}
{\AllRecipes}{\spirouConst.CONFIGFOLDER()}{\AllRecipes}{Private}


% config_file
\item \label{text:config_file} \ParameterEntry{Configuration file name}
{Defines the main configuration (containing the data directories etc).  Value must be a string containing a valid file name i.e. the main configuration file should be at \definevariable{text:tdata}{TDATA}/\definevariable{text:config_folder}{config\_folder}/\definevariable{text:config_file}{config\_file}.}
{config\_file}{\configtxtfile}
{\AllRecipes}{\spirouConst.CONFIGFILE()}{\AllRecipes}{Private}


% arg_file_names
\item \PseudoParamEntry{Filenames from run time arguments}
{Gets the filenames from run time arguments.}
{arg\_file\_names}
{\AllRecipes}{\spirouConst.ARG\_FILE\_NAMES()}{\spirouStartup.run\_time\_args()}


% arg_night_name
\item \PseudoParamEntry{Night name from run time arguments}
{Gets the night name from run time arguments.}
{arg\_night\_name}
{\AllRecipes}{\spirouConst.ARG\_NIGHT\_NAME()}{\spirouStartup.run\_time\_args()}


% calibdb_masterfile
\item \PseudoParamEntry{Calibration database file path}
{Gets the full calibration database file path}
{masterfilepath}
{\AllRecipes}{\spirouConst.CALIBDB\_MASTERFILE()}{\spirouCDB.write\_files\_to\_master(), \spirouCDB.read\_master\_file(), \spirouImage.correct\_for\_dark()}


% calibdb_lockfile
\item \PseudoParamEntry{Calibration database lock file path}
{Gets the full calibration database lock file path}
{lockfilepath}
{\AllRecipes}{\spirouConst.CALIBDB\_LOCKFILE()}{\spirouCDB.get\_check\_lock\_file()}


% calib_prefix
\item \PseudoParamEntry{Calibration database file prefix}
{Defines the prefix for calibration database files. Value must be a string.}
{calib\_prefix}
{\AllRecipes}{\spirouConst.CALIB\_PREFIX(()}{\calDARK.\progMAIN, \callocRAW.\progMAIN, \calSLIT.\progMAIN, \calFFraw.\progMAIN}


% fitsfilename
\item \PseudoParamEntry{Fits file name}
{Gets the full file path of the first file in `arg\_file\_names'}
{fitsfilename}
{\AllRecipes}{\spirouConst.FITSFILENAME()}{\spirouStartup.run\_time\_args()}


% log_opt
\item \PseudoParamEntry{Log program name}
{Chooses the display format for the program in the logging system.}
{log\_opt}
{\AllRecipes}{\spirouConst.LOG\_OPT()}{\spirouStartup.run\_time\_args()}


% manual_file
\item \PseudoParamEntry{Documentation info manual file path}
{Gets the full documentation info manual file path}
{manual\_file}
{\AllRecipes}{\spirouConst.MANUAL\_FILE()}{\spirouStartup.display\_help\_file()}


% nbframes
\item \PseudoParamEntry{Number of frames}
{Gets the number of frames from the list of files (`arg\_file\_names').}
{nbframes}
{\AllRecipes}{\spirouConst.NBFRAMES}{\spirouStartup.run\_time\_args()}


% program
\item \PseudoParamEntry{Program name from run time}
{Gets the run program name from run time.}
{program}
{\AllRecipes}{\spirouConst.PROGRAM()}{\spirouStartup.run\_time\_args()}


% raw_dir
\item \PseudoParamEntry{Full path of raw data directory}
{Gets the full path of the raw data directory.}
{raw\_dir}
{\AllRecipes}{\spirouConst.RAW\_DIR()}{\spirouFITS.math\_controller(), \spirouImage.get\_all\_similar\_files(), \spirouStartup.display\_run\_files()}


% reduced_dir
\item \PseudoParamEntry{Full path of reduced data directory}
{Gets the full path of the reduced data directory.}
{reduced\_dir}
{\AllRecipes}{\spirouConst.REDUCED\_DIR()}{\spirouStartup.run\_time\_args()}

\end{itemize}

\fi








\ifdevguide
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
\clearpage
\newpage
\section{Formatting variables}
\label{ch:variables:formatting}
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{itemize}

% date_fmt_header
\item \ParameterEntry{Header date format}
{Defines the format of the date in the FITS rec header files}
{date\_fmt\_header}{\%Y-\%m-\%d-\%H:\%M:\%S.\%f}
{\spirouCDB}{\spirouConst.DATE\_FMT\_HEADER()}{\spirouCDB.update\_database(), \spirouCDB.get\_database()}{Private}


% date_fmt_header
\item \ParameterEntry{Calibration database date format}
{Defines the format of the date in the calibration database file}
{date\_fmt\_calibdb}{\%Y-\%m-\%d-\%H:\%M:\%S.\%f}
{\spirouCDB}{\spirouConst.DATE\_FMT\_CALIBDB()}{\spirouCDB.update\_database(), \spirouCDB.get\_database()}{Private}

\end{itemize}

\fi







\ifdevguide
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
\clearpage
\newpage
\section{FITS rec variables}
\label{ch:variables:fitsrec}
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{itemize}

% forbidden_keys
\item 
\begin{minipage}[t]{\textwidth}
\textbf{Forbidden copy keys}

\begin{thighlight}

\textcolor{brown}{Lists the keys that should not be copied when call to copy all FITS rec keys is made. Should be a list of python strings.} \\

\begin{pythonboxblank}
forbidden_keys = ['SIMPLE', 'BITPIX', 'NAXIS', 'NAXIS1', 'NAXIS2', 'EXTEND', 
                  'COMMENT', 'CRVAL1', 'CRPIX1', 'CDELT1', 'CRVAL2', 'CRPIX2', 
                  'CDELT2', 'BSCALE', 'BZERO', 'PHOT_IM', 'FRAC_OBJ', 'FRAC_SKY', 
                  'FRAC_BB']
\end{pythonboxblank}
\begin{tabular}{>{\color{red}}l c l}
&&\\
\textcolor{blue}{Used in:}  & \multicolumn{2}{p{10cm}}{\AllRecipes} \\
\textcolor{blue}{Defined in:} & \multicolumn{2}{p{10cm}}{\spirouConst.FORBIDDEN\_COPY\_KEYS()} \\
\ifdevguide
\textcolor{blue}{Called in:} & \multicolumn{2}{p{10cm}}{\textcolor{codegreen}{\spirouFITS}} \\
\textcolor{blue}{Level:} & \multicolumn{2}{p{10cm}}{Private} \\
\fi
\end{tabular}
\end{thighlight}
\end{minipage}

\end{itemize}

\fi






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
\clearpage
\newpage
\section{Logging and printing variables}
\label{ch:variables:log_print}
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{itemize}

% PRINT_LEVEL
\item \label{text:print_level} \ParameterEntry{Print message level}
{The level of messages to print, values can be as follows:
\begin{itemize}
	\item "all" -- prints all events
	\item "info" -- prints info, warning and error events
	\item "warning" -- prints warning and error events
	\item "error" -- print only error events
\end{itemize}
Value must be a valid string. \ifdevguide See section \ref{ch:rules:drs_specific:logger} for more details. \fi}
{PRINT\_LEVEL}{all}{\AllRecipes}{\configtxtfile}{\spirouConfig.check\_params()}{Public}

% LOG_LEVEL
\item \label{text:log_level} \ParameterEntry{Log message level}
{The level of messages to print, values can be as follows:
\begin{itemize}
	\item "all" -- prints all events
	\item "info" -- prints info, warning and error events
	\item "warning" -- prints warning and error events
	\item "error" -- print only error events
\end{itemize}
Value must be a valid string. \ifdevguide See section \ref{ch:rules:drs_specific:logger} for more details. \fi}
{LOG\_LEVEL}{all}{\AllRecipes}{\configtxtfile}{\spirouConfig.writelog()}{Public}


% trig_keys
\ifdevguide

\item \label{text:trig_keys}
\begin{minipage}[t]{\textwidth}
\ParameterEntry{Logging keys}
{Defines the logging keys to use for each logging levels. Value should be a dictionary of key value pairs (where all keys and values are strings). When using the \spirouLog.logger() (aliases to \WLOG in recipes) the first argument must be one of these keys and the returned string is the corresponding value. The keys of \definevariable{text:write_level}{write\_level} and \definevariable{text:trig_keys}{trig\_key} must be identical. See section \ref{ch:rules:drs_specific:logger} for more details.}
{trig\_key}
{\lstinline[style=pythoninline]| dict(all=' ', error='!', warning='@', info='*', graph='~') |}
{\AllRecipes}{\spirouConst.LOG\_TRIG\_KEYS()}{\AllRecipes}{Private}
\vspace{-0.25cm}
\begin{thighlight}
i.e.: 
\begin{pythonbox}
trig_key = dict(error='!')
WLOG('error', 'program', 'Message')
\end{pythonbox}
returns
\begin{cmdboxprint}
HH:MM:SS.s - ! |program|Message
\end{cmdboxprint}
\end{thighlight}
\end{minipage}
\fi

% write_level
\ifdevguide

\item \label{text:write_level}
\begin{minipage}[t]{\textwidth}
\ParameterEntry{Write level}
{Defines the write levels to use for each write level. A write level is defined by a number. The higher the number to more exclusive the level i.e. if A and B are write levels and A $>$ B and write level is set to A, any log or print messages at level B will not be logged/printed. Printing is controlled by variable \definevariable{text:print_level}{PRINT\_LEVEL} and logging by variable \definevariable{text:log_level}{LOG\_LEVEL}. The keys of \definevariable{text:write_level}{write\_level} and \definevariable{text:trig_keys}{trig\_key} must be identical. See section \ref{ch:rules:drs_specific:logger} for more details.}
{write\_level}
{\lstinline[style=pythoninline]| dict(error=3, warning=2, info=1, graph=0, all=0) |}
{\AllRecipes}{\spirouConst.LOG\_TRIG\_KEYS()}{\AllRecipes}{Private}
\vspace{-0.25cm}
\begin{thighlight}
i.e.: 
\begin{pythonbox}
write_level = dict(error=3, warning=2, info=1)
trig_key = dict(all=' ', error='!', warning='@', info='*', graph='~')
PRINT_LEVEL = 'warning'

WLOG('error', 'program', 'Error message')
WLOG('warning', 'program', 'Warning message')
WLOG('info', 'program', 'Info message')
\end{pythonbox}
returns
\begin{cmdboxprint}
HH:MM:SS.s - ! |program|Error message
HH:MM:SS.s - @ |program|Warning message
\end{cmdboxprint}
\begin{note}
Note the info message was not shown as info=1 and \definevariable{text:print_level}{PRINT\_LEVEL} is set to warning=2.
\end{note}
\end{thighlight}
\end{minipage}
\fi


% log_exit_type
\ifdevguide
\item \label{text:log_exit_type} \ParameterEntry{Logger exit type}
{What to do when a logging `error' is raise. Options are: 'None', 'os' or 'sys'. If 'None' the code continues on an `error', if 'os' then python executes a `os.\_exit' command (a hard exit), if 'sys' then python executes a 'sys.exit' command (a soft exit).}
{log\_exit\_type}{sys}
{\AllRecipes}{\spirouConst.LOG\_EXIT\_TYPE()}{\spirouConst.EXIT() which is called in \spirouLog}{Private}
\fi

% exit controller
\ifdevguide
\item \label{text:exit_controller} \PseudoParamEntry{Exit controller}
{Controls the exit type from `log\_exit\_type' and \definevariable{text:log_exit_type}{\spirouConst.LOG\_EXIT\_TYPE()}.}
{exit}
{\AllRecipes}{\spirouConst.EXIT()}{\spirouLog}
\fi


% exit levels
\ifdevguide
\item \label{text:exit_levels} \PseudoParamEntry{Exit levels}
{Controls which levels (defined in \definevariable{text:write_level}{write\_level} and \definevariable{text:trig_keys}{trig\_key}) will lead to the exit statement (given in \definevariable{text:exit_controller}{exit} and \definevariable{text:log_exit_type}{log\_exit\_type}). Values must be a list of strings where each entry must be in \definevariable{text:write_level}{write\_level} and \definevariable{text:trig_keys}{trig\_key}.}
{exit\_levels}
{\AllRecipes}{\spirouConst.EXIT\_LEVELS()}{\spirouLog}
\fi


% log_caught_warnings
\ifdevguide
\item \ParameterEntry{Log caught warnings}
{If True or 1, then if warnings are passed to \spirouLog.warninglogger() and there are warnings present, will attempt to log these warnings using the \spirouLog.logger function. i.e. will print the warning to screen/log file depending on logging settings.}
{log\_caught\_warnings}{True}
{\AllRecipes}{\spirouConst.LOG\_CAUGHT\_WARNINGS()}{\spirouLog}{Private}
\fi

% cmsg
\ifdevguide
\item \PseudoParamEntry{Configuration key error message}
{Defines the message that is used when a configuration key is missing}
{cerrmsg}
{\AllRecipes}{\spirouConst.CONFIG\_KEY\_ERROR}{\spirouLog.get\_logfilepath()}
\fi

% colouredlevels
\ifdevguide
\item \label{text:colouredlevels} \ParameterEntry{Colour of levels text}
{The text colour for each level in \definevariable{{text:trig_keys}}{trig\_key} and \definevariable{text:write_level}{write\_level}. Value must be a dictionary with the keys identical to the keys in \definevariable{{text:trig_keys}}{trig\_key} and \definevariable{text:write_level}{write\_level}. One can use \definevariable{text:redcolour}{REDCOLOUR()}, \definevariable{text:yellowcolour}{YELLOWCOLOUR()}, \definevariable{text:greencolour}{GREENCOLOUR()} to access the predefined values of red, yellow and green respectively. The default colour is given by \definevariable{text:normalcolour}{NORMALCOLOUR()}.}
{clevels}
{\lstinline[style=pythoninline]| dict(error=red, warning=yellow, info=green, graph=norm, all=green) |}
{\AllRecipes}{\spirouConst.COLOUREDLEVELS()}{\spirouLog.debug\_start(), \spirouLog.printlog()}
\fi

% normalcolour
\ifdevguide
\item \label{text:normalcolour} \ParameterEntry{Default text colour}
{Defines the string that describes the default text colour (retrieves colour from user). This in turn is turned into the colour defined by the python console/terminal that is default for that user. Value must be a string. This is used at the end of any colour change to set the text colour back to default (otherwise colour will remain until changed).}
{norm}{\lstinline[style=pythoninline]| "\\033[0;37;40m"|}
{\AllRecipes}{\spirouConst.NORMALCOLOUR()}{\spirouConst.COLOUREDLEVELS(), \spirouLog.debug\_start(), \spirouLog.printlog()}
\fi

% redcolour
\ifdevguide
\item \label{text:redcolour} \ParameterEntry{Red text colour}
{Defines the string that describes the colour "red".}
{red}{\lstinline[style=pythoninline]| "\\033[0;31;48m"|}
{\AllRecipes}{\spirouConst.REDCOLOUR()}{\spirouConst.COLOUREDLEVELS()}
\fi

% yellowcolour
\ifdevguide
\item \label{text:yellowcolour} \ParameterEntry{Yellow text colour}
{Defines the string that describes the colour "yellow".}
{yellow}{\lstinline[style=pythoninline]| "\\033[0;33;48m"|}
{\AllRecipes}{\spirouConst.YELLOWCOLOUR()}{\spirouConst.COLOUREDLEVELS()}
\fi

% greencolour
\ifdevguide
\item \label{text:greencolour} \ParameterEntry{Green text colour}
{Defines the string that describes the colour "green".}
{green}{\lstinline[style=pythoninline]| "\\033[0;32;48m"|}
{\AllRecipes}{\spirouConst.GREENCOLOUR()}{\spirouConst.COLOUREDLEVELS()}
\fi

% coloured_log
\item \ParameterEntry{Toggle coloured log}
{Defines whether the log (printed to the standard output) is coloured \ifdevguide according to \definevariable{text:colouredlevels}{clevels} \fi. Value must be True or 1 to colour the log or False or 0 to use the default console colour throughout.}
{COLOURED\_LOG}{True}
{\AllRecipes}{\configtxtfile}{\spirouLog.debug\_start(), \spirouLog.printlog()}{Public}

% coloured_log
\ifdevguide
\item \ParameterEntry{Coloured log controller}
{Defines whether the log (printed to the standard output) is coloured \ifdevguide according to \definevariable{text:colouredlevels}{clevels} \fi. Value is set through 
{clog}{True}
{\AllRecipes}{\spirouConst.COLOURED\_LOG()}{\spirouLog.debug\_start(), \spirouLog.printlog()}
\fi

\end{itemize}



