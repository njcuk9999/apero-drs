


<!doctype html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>Localization calibration &#8212; APERO 0.8.001 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/bizstyle.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/images/fonta/css/font-awesome.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/apero.css" />
    
    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/sphinx_highlight.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../../../_static/bizstyle.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:300,400,700'
          rel='stylesheet' type='text/css' />
    <link rel="stylesheet" href="_static/images/fonta/css/font-awesome.min.css">



    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <!--[if lt IE 9]>
    <script src="_static/css3-mediaqueries.js"></script>
    <![endif]-->
    <style>
      table.right { float: left; margin-left: 20px; }
      table.right td { border: 1px solid #ccc; }
      
    </style>
    <script>
      // intelligent scrolling of the sidebar content
      $(window).scroll(function() {
        var sb = $('.sphinxsidebarwrapper');
        var win = $(window);
        var sbh = sb.height();
        var offset = $('.sphinxsidebar').position()['top'];
        var wintop = win.scrollTop();
        var winbot = wintop + win.innerHeight();
        var curtop = sb.position()['top'];
        var curbot = curtop + sbh;
        // does sidebar fit in window?
        if (sbh < win.innerHeight()) {
          // yes: easy case -- always keep at the top
          sb.css('top', $u.min([$u.max([0, wintop - offset - 10]),
                                $(document).height() - sbh - 200]));
        } else {
          // no: only scroll if top/bottom edge of sidebar is at
          // top/bottom edge of window
          if (curtop > wintop && curbot > winbot) {
            sb.css('top', $u.max([wintop - offset - 10, 0]));
          } else if (curtop < wintop && curbot < winbot) {
            sb.css('top', $u.min([winbot - sbh - offset - 20,
                                  $(document).height() - sbh - 200]));
          }
        }
      });
    </script>

  </head><body>
<div class="pageheader">

  <ul>
    <li><a title="Home" href="http://apero.exoplanets.ca/">
        <i class="fa fa-home fa-3x" aria-hidden="true"></i></a></li>
    <li><a title="install" href="http://apero.exoplanets.ca/user/general/installation.html">
        <i class="fa fa-cog fa-3x" aria-hidden="true"></i></a></li>
    <li><a title="github" href="https://github.com/njcuk9999/apero-drs">
        <i class="fa fa-git-square fa-3x" aria-hidden="true"></i></a></li>
    <li><a title="download documentation" href="http://apero.exoplanets.ca/apero-docs.pdf">
        <i class="fa fa-download fa-3x" aria-hidden="true"></i></a></li>
    <li><a title="download paper" href="https://ui.adsabs.harvard.edu/abs/2022PASP..134k4509C">
        <i class="fa fa-file-pdf-o fa-3x" aria-hidden="true"></i></a></li>
    <li><a title="UdeM" href="http://apero.exoplanets.ca/main/misc/udem.html">
        <i class="fa fa-university fa-3x" aria-hidden="true"></i></a></li>
    <li><a title="ARI" href="http://apero.exoplanets.ca/ari/home/">
        <i class="fa fa-database fa-3x" aria-hidden="true"></i>
    </a></li>
  </ul>
    <div>
    <a href="http://apero.exoplanets.ca/">
      <img src="http://apero.exoplanets.ca/_static/images/apero_logo.png" alt="APERO" />
    </a>
    <br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A PipelinE to Reduce Observations
    </div>

</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">APERO 0.8.001 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Localization calibration</a></li> 
      </ul>
    </div>

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <section id="localization-calibration">
<h1>Localization calibration<a class="headerlink" href="#localization-calibration" title="Permalink to this heading">¶</a></h1>
<p>The localization recipe takes preprocessed <cite>DARK_FLAT</cite> or <cite>FLAT_DARK</cite> files (as many as given by the user or as many as
occur on the nights being used via Aprocessing). It is run twice, once for the C fiber localization (with a set of
<cite>DARK_FLAT</cite>) and once for the AB fiber localization (with a set of <cite>FLAT_DARK</cite>). It combines the <cite>DARK_FLAT</cite> files or the
<cite>FLAT_DARK</cite> files into a single <cite>DARK_FLAT</cite> or <cite>FLAT_DARK</cite> (via a median combination of the images). After combining, the
images are calibrated using our standard image calibration technique.</p>
<p>The first step in the localization code is to take the combined and calibrated <cite>DARK_FLAT</cite> or <cite>FLAT_DARK</cite> and apply a
weighted box median, shown in equation:</p>
<div class="math notranslate nohighlight">
\[\begin{split}IM_{\text{orderp } j} = \left\{ \begin{array}{ll}
  \text{MED}(IM_{j=0:j=k+1}):     &amp; k &lt; 5            \\
  \text{MED}(IM_{j=k-5:j=4088}):  &amp; k &gt; 4088 - 5     \\
  \text{MED}(IM_{j=k-5:j=k+5+1}): &amp; \text{otherwise} \\
\end{array} \right.\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(IM_{\text{orderp } j}\)</span> is the order profile flux for all rows in the jth column,
<span class="math notranslate nohighlight">\(IM_{j=x:j=y}\)</span> is the combined, calibrated <cite>DARK_FLAT</cite> or <cite>FLAT_DARK</cite>, that spans all columns from
<span class="math notranslate nohighlight">\(j=x\)</span> to <span class="math notranslate nohighlight">\(j=y\)</span>, and k is the column index number and ranges from <span class="math notranslate nohighlight">\(j=0\)</span> to <span class="math notranslate nohighlight">\(j=4088\)</span>.</p>
<p>This produces the order profile image of the <cite>DARK_FLAT</cite> or <cite>FLAT_DARK</cite> which is used for the optimal extraction
and to locate the orders.</p>
<p>To locate the orders we use the scikit <cite>measure.label</cite> algorithm which labels connected regions.
Two pixels are defined as connected when both themselves and their neighbors have the same value.
We use a connectivity value of 2 meaning that any of the 8 surrounding pixels can be neighbors if they share
the same value.</p>
<p>In order to facilitate the labeling we first perform a 95th percentile of a box (of size <span class="math notranslate nohighlight">\(25\times25\)</span> pixels)
across the whole image, as true illuminated pixels’ flux is location-dependent. We set a threshold at half that value
and label all pixels above this threshold as one and all pixels below this to a value of zero. We then perform the
<cite>measure.label</cite> on this Boolean map (referred to from this point on as <span class="math notranslate nohighlight">\(Mask_{orders}\)</span>).
This is just a first guess of the order positions and usually returns many labeled regions that are not true orders.</p>
<p>To remove bad labels we first remove any labeled region with less than 500 pixels. We then remove any pixel within a
labeled region that has a flux value less than 0.05 times the 95th percentile of all pixels in that given labeled
region and remove this pixel from <span class="math notranslate nohighlight">\(Mask_{orders}\)</span>. We then median filter each row of <span class="math notranslate nohighlight">\(Mask_{orders}\)</span> to
clean up the labeled edges and apply a binary dilation (scipy <cite>ndimage.binary_dilation</cite>) algorithm.
This binary dilation essentially merges labeled regions that are close to each other together by expanding regions
marked with ones around the edges of these regions. After <span class="math notranslate nohighlight">\(Mask_{orders}\)</span> has been updated we re-run the
labeling algorithm. As a final filtering step, we remove any region center that does not overlap with the central
part of the image in the along-order direction (i.e., the center <span class="math notranslate nohighlight">\(\pm\)</span> half the width of the detector,
2044 <span class="math notranslate nohighlight">\(\pm\)</span> 1022 pixels).</p>
<p>Once we have the final set of labeled regions we use :math:<a href="#id1"><span class="problematic" id="id2">`</span></a>Mask_{orders} on each order to fit a polynomial fit
(of degree 3) to the pixel positions in that labeled region forcing continuity between orders by fitting each
coefficient across the orders. We also use the :math:<a href="#id3"><span class="problematic" id="id4">`</span></a>Mask_{orders} pixel positions to linearly fit the width of
each order.</p>
<p>For a <cite>DARK_FLAT</cite>, this produces polynomial fits and coefficients for 49 orders for the C fiber.
For a <cite>FLAT_DARK</cite> input, this produces polynomial fits and coefficients for 98 orders (49 orders for A and 49 orders
for B). These polynomial coefficients for the positions of the orders and the widths of the orders are then converted
into values as a function of position across each order.</p>
<p>As part of quality control we check that:</p>
<blockquote>
<div><ul class="simple">
<li><p>the number of orders is consistent with the required number of orders (49 for fiber C, 98 for fibers A+B).</p></li>
<li><p>the across-order value at the center of the detector is always larger than the value of the previous order</p></li>
</ul>
</div></blockquote>
<p>The order profile (ORDERP), locations of the orders (LOCO), and widths of the orders are saved to the calibration
database (if both quality control criteria are met) for use throughout APERO.</p>
</section>


            <div class="clearer"></div>
          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">APERO 0.8.001 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Localization calibration</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2019, Neil Cook.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.0.1.
    </div>
  </body>
</html>