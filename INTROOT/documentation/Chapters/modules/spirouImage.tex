
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
\clearpage
\newpage
\noindent\begin{minipage}{\textwidth}
\section{The spirouImage module}
\label{ch:the_module:spirouImage}
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
\subsection{AddKey}

Defined in \spirouImage\path{.}

\begin{pythonbox}
from SpirouDRS import spirouImage
spirouImage.AddKey(hdict=None, keywordstore=None, value=None)
spirouImage.spirouFITS.add_new_key(hdict=None, keywordstore=None, value=None)
\end{pythonbox}

\begin{pythondocstring}
Add a new key to hdict from keywordstore, if value is not None then the
keywordstore value is updated. Each keywordstore is in form:
        [key, value, comment]    where key and comment are strings
if hdict is None creates a new dictionary

:param hdict: dictionary or None, storage for adding to FITS rec
:param keywordstore: list, keyword list (defined in spirouKeywords.py)
                     must be in form [string, value, string]
:param value: object or None, if any python object (other than None) will
              replace the value in keywordstore (i.e. keywordstore[1]) with
              value, if None uses the value = keywordstore[1]

:return hdict: dictionary, storage for adding to FITS rec
\end{pythondocstring}
\end{minipage}

%----------------------------------------------------------------------------------------
\noindent\begin{minipage}{\textwidth}
\subsection{AddKey1DList}

Defined in \spirouImage\path{.pirouFITS.add_key_1d_list}

\begin{pythonbox}
from SpirouDRS import spirouImage
spirouImage.AddKey1DList(hdict, keywordstore, values=None, dim1name='order')
spirouImage.pirouFITS.add_key_1d_list(hdict, keywordstore, values=None, dim1name='order')
\end{pythonbox}

\begin{pythondocstring}
Add a new 1d list to key using the keywordstorage[0] as prefix in form
keyword = kewordstoreage + row number

:param hdict: dictionary, storage for adding to FITS rec
:param keywordstore: list, keyword list (defined in spirouKeywords.py)
                     must be in form [string, value, string]
:param values: numpy array or 1D list of keys or None

              if numpy array or 1D list will create a set of keys in form
              keyword = kewordstoreage + row number
              where row number is the position in values
              with value = values[row number][column number]

              if None uses the value = keywordstore[1]
:param dim1name: string, the name for dimension 1 (rows), used in FITS rec
                 HEADER comments in form:
      COMMENT = keywordstore[2] dim1name={row number}

:return hdict: dictionary, storage for adding to FITS rec
\end{pythondocstring}
\end{minipage}

%----------------------------------------------------------------------------------------
\noindent\begin{minipage}{\textwidth}
\subsection{AddKey2DList}

Defined in \spirouImage\path{.spirouFITS.add_key_2d_list}

\begin{pythonbox}
from SpirouDRS import spirouImage
spirouImage.AddKey2DList
spirouImage.spirouFITS.add_key_2d_list
\end{pythonbox}

\begin{pythondocstring}
Add a new 2d list to key using the keywordstorage[0] as prefix in form
keyword = kewordstoreage + number

where number = (row number * number of columns) + column number

:param hdict: dictionary, storage for adding to FITS rec
:param keywordstore: list, keyword list (defined in spirouKeywords.py)
                     must be in form [string, value, string]
:param values: numpy array or 2D list of keys or None

              if numpy array or 2D list will create a set of keys in form
              keyword = kewordstoreage + number
              where number = (row number*number of columns)+column number
              with value = values[row number][column number]

              if None uses the value = keywordstore[1]
:param dim1name: string, the name for dimension 1 (rows), used in FITS rec
                 HEADER comments in form:
      COMMENT = keywordstore[2] dim1name={row number} dim2name={col number}
:param dim2name: string, the name for dimension 2 (cols), used in FITS rec
                 HEADER comments in form:
      COMMENT = keywordstore[2] dim1name={row number} dim2name={col number}

:return hdict: dictionary, storage for adding to FITS rec
\end{pythondocstring}
\end{minipage}

%----------------------------------------------------------------------------------------

\noindent\begin{minipage}{\textwidth}
\subsection{ConvertToE}

Defined in \spirouImage\path{.}

\begin{pythonbox}
from SpirouDRS import spirouImage
spirouImage.ConvertToE(image, p=None, gain=None, exptime=None)
spirouImage.spirouImage.convert_to_e(image, p=None, gain=None, exptime=None)
\end{pythonbox}

\begin{pythondocstring}
Converts image from ADU/s into e-

:param image:
:param p: parameter dictionary, ParamDict containing constants
        Must contain at least: (if exptime is None)
            exptime: float, the exposure time of the image
            gain: float, the gain of the image

:param gain: float, if p is None, used as the gain to multiple the image by
:param exptime: float, if p is None, used as the exposure time the image
                is multiplied by

:return newimage: numpy array (2D), the image in e-
\end{pythondocstring}
\end{minipage}

%----------------------------------------------------------------------------------------
\noindent\begin{minipage}{\textwidth}
\subsection{ConvertToADU}

Defined in \spirouImage\path{.spirouImage.convert_to_adu}

\begin{pythonbox}
from SpirouDRS import spirouImage
spirouImage.ConvertToADU(image, p=None, exptime=None)
spirouImage.spirouImage.convert_to_adu(image, p=None, exptime=None)
\end{pythonbox}

\begin{pythondocstring}
Converts image from ADU/s into ADU

:param image:

:param p: parameter dictionary, ParamDict containing constants
    Must contain at least: (if exptime is None)
        exptime: float, the exposure time of the image

:param exptime: float, if p is None, used as the exposure time the image
                is multiplied by

:return newimage: numpy array (2D), the image in e-
\end{pythondocstring}
\end{minipage}

%----------------------------------------------------------------------------------------

\noindent\begin{minipage}{\textwidth}
\subsection{CopyOriginalKeys}

Defined in \spirouImage\path{.spirouFITS.copy_original_keys}

\begin{pythonbox}
from SpirouDRS import spirouImage
spirouImage.CopyOriginalKeys(header, comments, hdict=None, forbid_keys=True)
spirouImage.spirouFITS.copy_original_keys(header, comments, hdict=None, forbid_keys=True)
\end{pythonbox}

\begin{pythondocstring}
Copies keys from hdr dictionary to hdict, if forbid_keys is True some
keys will not be copies (defined in python code)

:param header: header dictionary from readimage (ReadImage) function

:param comments: comment dictionary from readimage (ReadImage) function

:param hdict: dictionary or None, header dictionary to write to fits file
              if None hdict is created

            Must be in form:

                    hdict[key] = (value, comment)
            or
                    hdict[key] = value     (comment will be equal to
                                            "UNKNOWN"
:param forbid_keys: bool, if True uses the forbidden copy keys (defined in
                    spirouConfig.Constants.FORBIDDEN_COPY_KEYS() to remove
                    certain keys from those being copied, if False copies
                    all keys from input header

:return hdict: dictionary, (updated or new) header dictionary containing
               key/value pairs from the header (that are NOT in
               spirouConfig.spirouConst.FORBIDDEN_COPY_KEY)
\end{pythondocstring}
\end{minipage}

%----------------------------------------------------------------------------------------

\noindent\begin{minipage}{\textwidth}
\subsection{CopyRootKeys}

Defined in \spirouImage\path{.spirouFITS.copy_root_keys}

\begin{pythonbox}
from SpirouDRS import spirouImage
spirouImage.CopyRootKeys(hdict=None, filename=None, root=None, ext=0)
spirouImage.spirouFITS.copy_root_keys(hdict=None, filename=None, root=None, ext=0)
\end{pythonbox}

\begin{pythondocstring}
Copy keys from a filename to hdict

:param hdict: dictionary or None, header dictionary to write to fits file
              if None hdict is created
:param filename: string, location and filename of the FITS rec to open

:param ext: int, the extension of the FITS rec to open header from
            (defaults to 0)
:return:
\end{pythondocstring}
\end{minipage}

%----------------------------------------------------------------------------------------

\noindent\begin{minipage}{\textwidth}
\subsection{CorrectForDark}

Defined in \spirouImage\path{.spirouImage.correct_for_dark}

\begin{pythonbox}
from SpirouDRS import spirouImage
spirouImage.CorrectForDark(p, image, header, nfiles=None, return_dark=False)
spirouImage.spirouImage.correct_for_dark(p, image, header, nfiles=None, return_dark=False)
\end{pythonbox}

\begin{pythondocstring}
Corrects "image" for "dark" using calibDB file (header must contain
value of p['ACQTIME_KEY'] as a keyword)

:param p: parameter dictionary, ParamDict containing constants
    Must contain at least:
            nbframes: int, the number of frames/files (usually the length
                      of "arg_file_names")
            calibDB: dictionary, the calibration database dictionary
                     (if not in "p" we construct it and need "max_time_unix"
            max_time_unix: float, the unix time to use as the time of
                            reference (used only if calibDB is not defined)
            log_opt: string, log option, normally the program name
            DRS_CALIB_DB: string, the directory that the calibration
                          files should be saved to/read from

:param image: numpy array (2D), the image
:param header: dictionary, the header dictionary created by
               spirouFITS.ReadImage
:param nfiles: int or None, number of files that created image (need to
               multiply by this to get the total dark) if None uses
               p['nbframes']
:param return_dark: bool, if True returns corrected_image and dark
                    if False (default) returns corrected_image

:return corrected_image: numpy array (2D), the dark corrected image
                         only returned if return_dark = True:
:return darkimage: numpy array (2D), the dark
\end{pythondocstring}
\end{minipage}

%----------------------------------------------------------------------------------------

\noindent\begin{minipage}{\textwidth}
\subsection{FitTilt}

Defined in \spirouImage\path{.spirouImage.fit_tilt}

\begin{pythonbox}
from SpirouDRS import spirouImage
spirouImage.FitTilt(pp, lloc)
spirouImage.spirouImage.fit_tilt(pp, lloc)
\end{pythonbox}

\begin{pythondocstring}
Fit the tilt (lloc['tilt'] with a polynomial of size = p['ic_tilt_filt']
return the coefficients, fit and residual rms in lloc dictionary

:param pp: parameter dictionary, ParamDict containing constants
    Must contain at least:
        IC_TILT_FIT: int, Order of polynomial to fit for tilt

:param loc: parameter dictionary, ParamDict containing data
        Must contain at least:
            number_orders: int, the number of orders in reference spectrum
            tilt: numpy array (1D), the tilt angle of each order

:return loc: parameter dictionary, the updated parameter dictionary
        Adds/updates the following:
            xfit_tilt: numpy array (1D), the order numbers
            yfit_tilt: numpy array (1D), the fit for the tilt angle of each
                       order
            a_tilt: numpy array (1D), the fit coefficients (generated by
                    numpy.polyfit but IN REVERSE ORDER)
            rms_tilt: float, the RMS (np.std) of the residuals of the
                      tilt - tilt fit values
\end{pythondocstring}
\end{minipage}

%----------------------------------------------------------------------------------------

\noindent\begin{minipage}{\textwidth}
\subsection{FlipImage}

Defined in \spirouImage\path{.spirouImage.flip_image}

\begin{pythonbox}
from SpirouDRS import spirouImage
spirouImage.FlipImage(image, fliprows=True, flipcols=True)
spirouImage.spirouImage.flip_image(image, fliprows=True, flipcols=True)
\end{pythonbox}

\begin{pythondocstring}
Flips the image in the x and/or the y direction

:param image: numpy array (2D), the image
:param fliprows: bool, if True reverses row order (axis = 0)
:param flipcols: bool, if True reverses column order (axis = 1)

:return newimage: numpy array (2D), the flipped image
\end{pythondocstring}
\end{minipage}

%----------------------------------------------------------------------------------------

\noindent\begin{minipage}{\textwidth}
\subsection{GetAllSimilarFiles}

Defined in \spirouImage\path{.spirouImage.get_all_similar_files}

\begin{pythonbox}
from SpirouDRS import spirouImage
spirouImage.GetAllSimilarFiles(p, directory, prefix=None, suffix=None)
spirouImage.spirouImage.get_all_similar_files(p, directory, prefix=None, suffix=None)
\end{pythonbox}

\begin{pythondocstring}
Get all similar files in a directory with matching prefix and suffix defined
either by "prefix" and "suffix" or by p["ARG_FILE_NAMES"][0]

:param p: parameter dictionary, ParamDict containing constants
    Must contain at least:
            arg_file_names: list, list of files taken from the command line
                            (or call to recipe function) must have at least
                            one string filename in the list
            log_opt: string, log option, normally the program name

:param directory: string, the directory to search for files
:param prefix: string or None, if not None the prefix to search for, if
               None defines the prefix from the first 5 characters of
               p["ARG_FILE_NAMES"][0]
:param suffix: string  or None, if not None the suffix to search for, if
               None defines the prefix from the last 8 characters of
               p["ARG_FILE_NAMES"][0]

:return filelist: list of strings, the full paths of all files that are in
                  "directory" with the matching prefix and suffix defined
                  either by "prefix" and "suffix" or by
                  p["ARG_FILE_NAMES"][0]
\end{pythondocstring}
\end{minipage}

%----------------------------------------------------------------------------------------

\noindent\begin{minipage}{\textwidth}
\subsection{GetSigdet}

Defined in \spirouImage\path{.spirouImage.get_sigdet}

\begin{pythonbox}
from SpirouDRS import spirouImage
spirouImage.GetSigdet(p, hdr, name=None, return_value=False)
spirouImage.spirouImage.get_sigdet(p, hdr, name=None, return_value=False)
\end{pythonbox}

\begin{pythondocstring}
Get sigdet from HEADER. Wrapper for spirouImage.get_param

:param p: parameter dictionary, ParamDict of constants
:param hdr: dictionary, header dictionary to extract
:param name: string or None, if not None the name for the parameter
             logged if there is an error in getting parameter, if name is
             None the name is taken as "keyword"
:param return_value: bool, if True returns parameter, if False adds
                     parameter to "p" parameter dictionary (and sets source)

:return value: if return_value is True value of parameter is returned
:return p: if return_value is False, updated parameter dictionary p with
           key = name is returned
\end{pythondocstring}
\end{minipage}

%----------------------------------------------------------------------------------------

\noindent\begin{minipage}{\textwidth}
\subsection{GetExpTime}

Defined in \spirouImage\path{.spirouImage.get_exptime}

\begin{pythonbox}
from SpirouDRS import spirouImage
spirouImage.GetExpTime(p, hdr, name=None, return_value=False)
spirouImage.spirouImage.get_exptime(p, hdr, name=None, return_value=False)
\end{pythonbox}

\begin{pythondocstring}
Get Exposure time from HEADER. Wrapper for spirouImage.get_param

:param p: parameter dictionary, ParamDict of constants
:param hdr: dictionary, header dictionary to extract
:param name: string or None, if not None the name for the parameter
             logged if there is an error in getting parameter, if name is
             None the name is taken as "keyword"
:param return_value: bool, if True returns parameter, if False adds
                     parameter to "p" parameter dictionary (and sets source)

:return value: if return_value is True value of parameter is returned
:return p: if return_value is False, updated parameter dictionary p with
           key = name is returned
\end{pythondocstring}
\end{minipage}

%----------------------------------------------------------------------------------------

\noindent\begin{minipage}{\textwidth}
\subsection{GetGain}

Defined in \spirouImage\path{.spirouImage.get_gain}

\begin{pythonbox}
from SpirouDRS import spirouImage
spirouImage.GetGain(p, hdr, name=None, return_value=False)
spirouImage.spirouImage.get_gain(p, hdr, name=None, return_value=False)
\end{pythonbox}

\begin{pythondocstring}
Get Gain from HEADER. Wrapper for spirouImage.get_param

:param p: parameter dictionary, ParamDict of constants
:param hdr: dictionary, header dictionary to extract
:param name: string or None, if not None the name for the parameter
             logged if there is an error in getting parameter, if name is
             None the name is taken as "keyword"
:param return_value: bool, if True returns parameter, if False adds
                     parameter to "p" parameter dictionary (and sets source)

:return value: if return_value is True value of parameter is returned
:return p: if return_value is False, updated parameter dictionary p with
           key = name is returned
\end{pythondocstring}
\end{minipage}

%----------------------------------------------------------------------------------------

\noindent\begin{minipage}{\textwidth}
\subsection{GetAcqTime}

Defined in \spirouImage\path{.spirouImage.get_acqtime}

\begin{pythonbox}
from SpirouDRS import spirouImage
spirouImage.GetAcqTime(p, hdr, name=None, kind='human', return_value=False)
spirouImage.spirouImage.get_acqtime(p, hdr, name=None, kind='human', return_value=False)
\end{pythonbox}

\begin{pythondocstring}
Get the acquision time from the header file, if there is not header file
use the parameter dictionary "p" to open the header in 'arg_file_names[0]'

:param p: parameter dictionary, ParamDict containing constants
    Must contain at least:
        "name" defined in call
        parameter dictionary to give to value

:param hdr: dictionary, the header dictionary created by
            spirouFITS.ReadImage
:param name: string, the name in parameter dictionary to give to value
             if return_value is False (i.e. p[name] = value)
:param kind: string, 'human' for 'YYYY-mm-dd-HH-MM-SS.ss' or 'unix'
             for time since 1970-01-01
:param return_value: bool, if False value is returned in p as p[name]
                     if True value is returned

:return p or value: dictionary or string or float, if return_value is False
                    parameter dictionary is returned, if return_value is
                    True and kind=='human' returns a string, if return_value
                    is True and kind=='unix' returns a float
\end{pythondocstring}
\end{minipage}

%----------------------------------------------------------------------------------------

\noindent\begin{minipage}{\textwidth}
\subsection{ReadParam}

Defined in \spirouImage\path{.spirouImage.get_param}

\begin{pythonbox}
from SpirouDRS import spirouImage
spirouImage.ReadParam(p, hdr, name=None, kind='human', return_value=False)
spirouImage.spirouImage.get_param(p, hdr, name=None, kind='human', return_value=False)
\end{pythonbox}

\begin{pythondocstring}
Get the acquision time from the header file, if there is not header file
use the parameter dictionary "p" to open the header in 'arg_file_names[0]'

:param p: parameter dictionary, ParamDict containing constants
    Must contain at least:
        "name" defined in call
        parameter dictionary to give to value

:param hdr: dictionary, the header dictionary created by
            spirouFITS.ReadImage
:param name: string, the name in parameter dictionary to give to value
             if return_value is False (i.e. p[name] = value)
:param kind: string, 'human' for 'YYYY-mm-dd-HH-MM-SS.ss' or 'unix'
             for time since 1970-01-01
:param return_value: bool, if False value is returned in p as p[name]
                     if True value is returned

:return p or value: dictionary or string or float, if return_value is False
                    parameter dictionary is returned, if return_value is
                    True and kind=='human' returns a string, if return_value
                    is True and kind=='unix' returns a float
\end{pythondocstring}
\end{minipage}

%----------------------------------------------------------------------------------------

\noindent\begin{minipage}{\textwidth}
\subsection{GetKey}

Defined in \spirouImage\path{.spirouFITS.keylookup}

\begin{pythonbox}
from SpirouDRS import spirouImage
spirouImage.GetKey(p, d=None, key=None, has_default=False, default=None)
spirouImage.spirouFITS.keylookup(p, d=None, key=None, has_default=False, default=None)
\end{pythonbox}

\begin{pythondocstring}
Looks for a key in dictionary "p" or "d", if has_default is True sets
value of key to 'default' if not found else logs an error

:param p: parameter dictionary, ParamDict containing constants
    Must contain at least:
            log_opt: string, log option, normally the program name
            "key": if d is None must contain key="key" or error is raised
:param d: dictionary, any dictionary, if None uses parameter dictionary
          if "d" is not None then must contain key="key" or error is raised
:param key: string, key in the dictionary to find
:param has_default: bool, if True uses "default" as the value if key
                    not found
:param default: object, value of the key if not found and
                has_default is True

:return value: object, value of p[key] or default (if has_default=True)
\end{pythondocstring}
\end{minipage}

%----------------------------------------------------------------------------------------

\noindent\begin{minipage}{\textwidth}
\subsection{GetKeys}

Defined in \spirouImage\path{.spirouFITS.keyslookup}

\begin{pythonbox}
from SpirouDRS import spirouImage
spirouImage.GetKeys(p, d=None, keys=None, has_default=False, defaults=None)
spirouImage.spirouFITS.keyslookup(p, d=None, keys=None, has_default=False, defaults=None)
\end{pythonbox}

\begin{pythondocstring}
Looks for keys in dictionary "p" or "d", if has_default is True sets
value of key to 'default' if not found else logs an error

:param p: parameter dictionary, ParamDict containing constants
    Must contain at least:
            log_opt: string, log option, normally the program name
            "key": if d is None must contain key="key" or error is raised
:param d: dictionary, any dictionary, if None uses parameter dictionary
          if "d" is not None then must contain key="key" or error is raised
:param keys: list of strings, keys in the dictionary to find
:param has_default: bool, if True uses "default" as the value if key
                    not found
:param defaults: list of objects or None, values of the keys if not
                 found and has_default is True

:return values: list of objects, values of p[key] for key in keys
                or default value for each key (if has_default=True)
\end{pythondocstring}
\end{minipage}

%----------------------------------------------------------------------------------------

\noindent\begin{minipage}{\textwidth}
\subsection{GetTilt}

Defined in \spirouImage\path{.}

\begin{pythonbox}
from SpirouDRS import spirouImage
spirouImage.GetTilt(pp, lloc, image)
spirouImage.spirouImage.get_tiltspirouImage.get_tilt(pp, lloc, image)
\end{pythonbox}

\begin{pythondocstring}
Get the tilt by correlating the extracted fibers

:param pp: parameter dictionary, ParamDict containing constants
    Must contain at least:
            ic_tilt_coi: int, oversampling factor
            log_opt: string, log option, normally the program name

:param loc: parameter dictionary, ParamDict containing data
        Must contain at least:
            number_orders: int, the number of orders in reference spectrum
            cent1: numpy array (2D), the extraction for A, updated is
                   the order "rnum"
            cent2: numpy array (2D), the extraction for B, updated is
                   the order "rnum"
            offset: numpy array (1D), the center values with the
                    offset in 'IC_CENT_COL' added

:param image: numpy array (2D), the image

:return loc: parameter dictionary, the updated parameter dictionary
        Adds/updates the following:
            nbcos: numpy array, zero array  (length of "number_orderes")
            tilt: numpy array (1D), the tilt angle of each order
\end{pythondocstring}
\end{minipage}

%----------------------------------------------------------------------------------------

\noindent\begin{minipage}{\textwidth}
\subsection{GetTypeFromHeader}

Defined in \spirouImage\path{.spirouFITS.get_type_from_header}

\begin{pythonbox}
from SpirouDRS import spirouImage
spirouImage.GetTypeFromHeader(p, keywordstore, hdict=None, filename=None)
spirouImage.spirouFITS.get_type_from_header(p, keywordstore, hdict=None, filename=None)
\end{pythonbox}

\begin{pythondocstring}
Special FITS HEADER keyword - get the type of file from a FITS file HEADER
using "keywordstore"

:param p: parameter dictionary, ParamDict containing constants
    Must contain at least:
            log_opt: string, log option, normally the program name
            fitsfilename: string, the full path of for the main raw fits
                          file for a recipe
                          i.e. /data/raw/20170710/filename.fits

:param keywordstore: list, a keyword store in the form
                     [name, value, comment] where the format is
                     [string, object, string]
:param hdict: dictionary or None, the HEADER dictionary containing
              key/value pairs from a FITS HEADER, if None uses the
              header from "FITSFILENAME" in "p", unless filename is not None
              This hdict is used to get the type of file
:param filename: string or None, if not None and hdict is None, this is the
                 file which is used to extract the HEADER from to get
                 the type of file

:return ftype: string, the type of file (extracted from a HEADER dictionary/
               file) if undefined set to 'UNKNOWN'
\end{pythondocstring}
\end{minipage}

%----------------------------------------------------------------------------------------

\noindent\begin{minipage}{\textwidth}
\subsection{LocateBadPixels}

Defined in \spirouImage\path{.spirouImage.locate_bad_pixels}

\begin{pythonbox}
from SpirouDRS import spirouImage
spirouImage.LocateBadPixels(p, fimage, fmed, dimage, wmed=None)
spirouImage.spirouImage.locate_bad_pixels(p, fimage, fmed, dimage, wmed=None)
\end{pythonbox}

\begin{pythondocstring}
Locate the bad pixels in the flat image and the dark image

:param p: parameter dictionary, ParamDict containing constants
    Must contain at least:
            log_opt: string, log option, normally the program name
            BADPIX_FLAT_MED_WID: float, the median image in the x
                                 dimension over a boxcar of this width
            BADPIX_FLAT_CUT_RATIO: float, the maximum differential pixel
                                   cut ratio
            BADPIX_ILLUM_CUT: float, the illumination cut parameter
            BADPIX_MAX_HOTPIX: float, the maximum flux in ADU/s to be
                               considered too hot to be used

:param fimage: numpy array (2D), the flat normalised image
:param fmed: numpy array (2D), the flat median normalised image
:param dimage: numpy array (2D), the dark image
:param wmed: float or None, if not None defines the median filter width
             if None uses p["BADPIX_MED_WID", see
             scipy.ndimage.filters.median_filter "size" for more details

:return bad_pix_mask: numpy array (2D), the bad pixel mask image
:return badpix_stats: list of floats, the statistics array:
                        Fraction of hot pixels from dark [%]
                        Fraction of bad pixels from flat [%]
                        Fraction of NaN pixels in dark [%]
                        Fraction of NaN pixels in flat [%]
                        Fraction of bad pixels with all criteria [%]
\end{pythondocstring}
\end{minipage}

%----------------------------------------------------------------------------------------

\noindent\begin{minipage}{\textwidth}
\subsection{MakeTable}

Defined in \spirouImage\path{.spirouTable.make_table}

\begin{pythonbox}
from SpirouDRS import spirouImage
spirouImage.MakeTable
spirouImage.spirouTable.make_table
\end{pythonbox}

\begin{pythondocstring}
Construct an astropy table from columns and values

:param columns: list of strings, the list of column names
:param values: list of lists or numpy array (2D), the list of lists/array
               of values, first dimension must have same length as number
               of columns, there must be the same number of values in each
               column
:param formats: list of strings, the astropy formats for each column
                i.e. 0.2f  for a float with two decimal places, must have
                same length as number of columns
:param units: list of strings, the units for each column, must have
              same length as number of columns

:return table: astropy.table.Table instance, the astropy table containing
               all columns and data
\end{pythondocstring}
\end{minipage}

%----------------------------------------------------------------------------------------

\noindent\begin{minipage}{\textwidth}
\subsection{MeasureDark}

Defined in \spirouImage\path{.spirouImage.measure_dark}

\begin{pythonbox}
from SpirouDRS import spirouImage
spirouImage.MeasureDark(pp, image, image_name, short_name)
spirouImage.spirouImage.measure_dark(pp, image, image_name, short_name)
\end{pythonbox}

\begin{pythondocstring}
Measure the dark pixels in "image"

:param pp: parameter dictionary, ParamDict containing constants
    Must contain at least:
            log_opt: string, log option, normally the program name
            DARK_QMIN: int, The lower percentile (0 - 100)
            DARK_QMAX: int, The upper percentile (0 - 100)
            HISTO_BINS: int,  The number of bins in dark histogram
            HISTO_RANGE_LOW: float, the lower extent of the histogram
                             in ADU/s
            HISTO_RANGE_HIGH: float, the upper extent of the histogram
                              in ADU/s

:param image: numpy array (2D), the image
:param image_name: string, the name of the image (for logging)
:param short_name: string, suffix (for parameter naming -
                    parmaeters added to pp with suffix i)

:return pp: parameter dictionary, the updated parameter dictionary
        Adds the following: (based on "short_name")
            histo_full: numpy.histogram tuple (hist, bin_edges) for
                        the full image
            histo_blue: numpy.histogram tuple (hist, bin_edges) for
                        the blue part of the image
            histo_red: numpy.histogram tuple (hist, bin_edges) for
                        the red part of the image
            med_full: float, the median value of the non-Nan image values
                      for the full image
            med_blue: float, the median value of the non-Nan image values
                      for the blue part of the image
            med_red: float, the median value of the non-Nan image values
                     for the red part of the image
            dadead_full: float, the fraction of dead pixels as a percentage
                         for the full image
            dadead_blue: float, the fraction of dead pixels as a percentage
                         for the blue part of the image
            dadead_red: float, the fraction of dead pixels as a percentage
                        for the red part of the image

      where:
          hist : numpy array (1D) The values of the histogram.
          bin_edges : numpy array (1D) of floats, the bin edges
\end{pythondocstring}
\end{minipage}

%----------------------------------------------------------------------------------------

\noindent\begin{minipage}{\textwidth}
\subsection{NormMedianFlat}

Defined in \spirouImage\path{.spirouImage.normalise_median_flat}

\begin{pythonbox}
from SpirouDRS import spirouImage
spirouImage.NormMedianFlat(p, image, method='new', wmed=None, percentile=None)
spirouImage.spirouImage.normalise_median_flat(p, image, method='new', wmed=None, percentile=None)
\end{pythonbox}

\begin{pythondocstring}
Applies a median filter and normalises. Median filter is applied with width
"wmed" or p["BADPIX_FLAT_MED_WID"] if wmed is None) and then normalising by
the 90th percentile

:param p: parameter dictionary, ParamDict containing constants
    Must contain at least:
            BADPIX_FLAT_MED_WID: float, the median image in the x
                                 dimension over a boxcar of this width
            BADPIX_NORM_PERCENTILE: float, the percentile to normalise
                                    to when normalising and median
                                    filtering image
            log_opt: string, log option, normally the program name

:param image: numpy array (2D), the iamge to median filter and normalise
:param method: string, "new" or "old" if "new" uses np.percentile else
               sorts the flattened image and takes the "percentile" (i.e.
               90th) pixel value to normalise
:param wmed: float or None, if not None defines the median filter width
             if None uses p["BADPIX_MED_WID", see
             scipy.ndimage.filters.median_filter "size" for more details
:param percentile: float or None, if not None degines the percentile to
                   normalise the image at, if None used from
                   p["BADPIX_NORM_PERCENTILE"]

:return norm_med_image: numpy array (2D), the median filtered and normalised
                        image
:return norm_image: numpy array (2D), the normalised image
\end{pythondocstring}
\end{minipage}

%----------------------------------------------------------------------------------------

\noindent\begin{minipage}{\textwidth}
\subsection{ReadData}

Defined in \spirouImage\path{.spirouFITS.readdata}

\begin{pythonbox}
from SpirouDRS import spirouImage
spirouImage.ReadData(p, filename, log=True)
spirouImage.spirouFITS.readdata(p, filename, log=True)
\end{pythonbox}

\begin{pythondocstring}
Reads the image 'fitsfilename' defined in p and adds files defined in
'arg_file_names' if add is True

:param p: parameter dictionary, ParamDict containing constants
    Must contain at least:
            log_opt: string, log option, normally the program name

:param filename: string, filename of the image to read
:param log: bool, if True logs opening and size

:return image: numpy array (2D), the image
:return header: dictionary, the header file of the image
:return nx: int, the shape in the first dimension, i.e. data.shape[0]
:return ny: int, the shape in the second dimension, i.e. data.shape[1]
\end{pythondocstring}
\end{minipage}

%----------------------------------------------------------------------------------------

\noindent\begin{minipage}{\textwidth}
\subsection{ReadImage}

Defined in \spirouImage\path{.spirouFITS.readimage}

\begin{pythonbox}
from SpirouDRS import spirouImage
spirouImage.ReadImage(p, filename=None, log=True, kind=None)
spirouImage.spirouFITS.readimage(p, filename=None, log=True, kind=None)
\end{pythonbox}

\begin{pythondocstring}
Reads the image 'fitsfilename' defined in p and adds files defined in
'arg_file_names' if add is True

:param p: parameter dictionary, ParamDict containing constants
    Must contain at least:
            fitsfilename: string, the full path of for the main raw fits
                  file for a recipe
                  i.e. /data/raw/20170710/filename.fits
            log_opt: string, log option, normally the program name
            arg_file_names: list, list of files taken from the command line
                            (or call to recipe function) must have at least
                            one string filename in the list

:param filename: string or None, filename of the image to read, if None
                 then p['fitsfilename'] is used
:param log: bool, if True logs opening and size
:param kind: string or None, if defined names the image else just image,
             used in logging (if log = True)

:return image: numpy array (2D), the image
:return header: dictionary, the header file of the image
:return nx: int, the shape in the first dimension, i.e. data.shape[0]
:return ny: int, the shape in the second dimension, i.e. data.shape[1]
\end{pythondocstring}
\end{minipage}

%----------------------------------------------------------------------------------------

\noindent\begin{minipage}{\textwidth}
\subsection{ReadTable}

Defined in \spirouImage\path{.spirouTable.read_table}

\begin{pythonbox}
from SpirouDRS import spirouImage
spirouImage.ReadTable(filename, fmt, colnames=None)
spirouImage.spirouTable.read_table(filename, fmt, colnames=None)
\end{pythonbox}

\begin{pythondocstring}
Reads a table from file "filename" in format "fmt", if colnames are defined
renames the columns to these name

:param filename: string, the filename and location of the table to read
:param fmt: string, the format of the table to read from (must be valid
            for astropy.table to read - see below)
:param colnames: list of strings or None, if not None renames all columns
                 to these strings, must be the same length as columns
                 in file that is read

:return None:

astropy.table readable formats are as follows:
\end{pythondocstring}
\end{minipage}

%----------------------------------------------------------------------------------------

\noindent\begin{minipage}{\textwidth}
\subsection{ReadImageAndCombine}

Defined in \spirouImage\path{.spirouFITS.readimage_and_combine}

\begin{pythonbox}
from SpirouDRS import spirouImage
spirouImage.ReadImageAndCombine(p, framemath='+', filename=None, filenames=None, log=True)
spirouImage.spirouFITS.readimage_and_combine(p, framemath='+', filename=None, filenames=None, log=True)
\end{pythonbox}

\begin{pythondocstring}
Reads the image 'fitsfilename' defined in p and adds files defined in
'arg_file_names' if add is True

:param p: parameter dictionary, ParamDict containing constants
    Must contain at least:
            log_opt: string, log option, normally the program name
            
            optional:
            fitsfilename: string, the full path of for the main raw fits
                  file for a recipe i.e. /data/raw/20170710/filename.fits
                  (if filename is None this is required)
                  
            arg_file_names: list, list of files taken from the command line
                            (or call to recipe function) must have at least
                            one string filename in the list
                  (if filenames is None this is required)

:param framemath: string, controls how files should be added

            currently supported are:
            'add' or '+'           - adds the frames
            'sub' or '-'           - subtracts the frames
            'average' or 'mean'    - averages the frames
            'multiply' or '*'      - multiplies the frames
            'divide' or '/'        - divides the frames
            'none'                 - does not add
            
:param filename: string or None, filename of the image to read, if None
                 then p['fitsfilename'] is used

:param filenames: list of strings or None, filenames to combine with 
                  "filename", if None then p['arg_file_names'] is used

:param log: bool, if True logs opening and size

:return image: numpy array (2D), the image
:return header: dictionary, the header file of the image
:return nx: int, the shape in the first dimension, i.e. data.shape[0]
:return ny: int, the shape in the second dimension, i.e. data.shape[1]
\end{pythondocstring}
\end{minipage}

%----------------------------------------------------------------------------------------

\noindent\begin{minipage}{\textwidth}
\subsection{ReadFlatFile}

Defined in \spirouImage\path{.spirouFITS.read_flat_file}

\begin{pythonbox}
from SpirouDRS import spirouImage
spirouImage.ReadFlatFile(p, hdr=None, filename=None, key=None)
spirouImage.spirouFITS.read_flat_file(p, hdr=None, filename=None, key=None)
\end{pythonbox}

\begin{pythondocstring}
Reads the wave file (from calib database or filename)

:param p: parameter dictionary, ParamDict containing constants
    Must contain at least:
            fitsfilename: string, the full path of for the main raw fits
                          file for a recipe
                          i.e. /data/raw/20170710/filename.fits
            fiber: string, the fiber used for this recipe (eg. AB or A or C)
            log_opt: string, log option, normally the program name

:param hdr: dictionary or None, the header dictionary to look for the
                 acquisition time in, if None loads the header from
                 p['fitsfilename']
:param filename: string or None, the filename and path of the tilt file,
                 if None gets the TILT file from the calib database
                 keyword "TILT"
:param key: string or None, if None key='WAVE' else uses string as key
            from calibDB (first entry) to get wave file

:return wave: list of the tilt for each order
\end{pythondocstring}
\end{minipage}

%----------------------------------------------------------------------------------------

\noindent\begin{minipage}{\textwidth}
\subsection{ReadHeader}

Defined in \spirouImage\path{.spirouFITS.read_header}

\begin{pythonbox}
from SpirouDRS import spirouImage
spirouImage.ReadHeader(p=None, filepath=None, ext=0)
spirouImage.spirouFITS.read_header(p=None, filepath=None, ext=0)
\end{pythonbox}

\begin{pythondocstring}
Read the header from a file at "filepath" with extention "ext" (default=0)

:param p: parameter dictionary, ParamDict containing constants
    Must contain at least:
            log_opt: string, log option, normally the program name

:param filepath: string, filename and path of FITS file to open
:param ext: int, extension in FITS rec to open (default = 0)

:return hdict: dictionary, the dictionary with key value pairs
\end{pythondocstring}
\end{minipage}

%----------------------------------------------------------------------------------------

\noindent\begin{minipage}{\textwidth}
\subsection{ReadKey}

Defined in \spirouImage\path{.spirouFITS.read_key}

\begin{pythonbox}
from SpirouDRS import spirouImage
spirouImage.ReadKey(p, hdict=None, key=None)
spirouImage.spirouFITS.read_key(p, hdict=None, key=None)
\end{pythonbox}

\begin{pythondocstring}
Read a key from hdict (or p if hdict is not defined) and return it's
value.

:param p: parameter dictionary, ParamDict containing constants
    Must contain at least:
            log_opt: string, log option, normally the program name

:param hdict: dictionary or None, the dictionary to add the key to once
              found, if None creates a new dictionary
:param key: string, key in the dictionary to find

:return value: object, the value of the key from hdict
               (or p if hdict is None)
\end{pythondocstring}
\end{minipage}

%----------------------------------------------------------------------------------------

\noindent\begin{minipage}{\textwidth}
\subsection{Read2Dkey}

Defined in \spirouImage\path{.spirouFITS.read_key_2d_list}

\begin{pythonbox}
from SpirouDRS import spirouImage
spirouImage.Read2Dkey(p, hdict, key, dim1, dim2)
spirouImage.spirouFITS.read_key_2d_list(p, hdict, key, dim1, dim2)
\end{pythonbox}

\begin{pythondocstring}
Read a set of header keys that were created from a 2D list

:param p: parameter dictionary, ParamDict containing constants
    Must contain at least:
            log_opt: string, log option, normally the program name

:param hdict: dictionary, HEADER dictionary to extract key/value pairs from
:param key: string, prefix of HEADER key to construct 2D list from
             key[number]

             where number = (row number * number of columns) + column number
             where column number = dim2 and row number = range(0, dim1)
:param dim1: int, the number of elements in dimension 1 (number of rows)
:param dim2: int, the number of columns in dimension 2 (number of columns)

:return value: numpy array (2D), the reconstructed 2D list of variables
               from the HEADER dictionary keys
\end{pythondocstring}
\end{minipage}

%----------------------------------------------------------------------------------------

\noindent\begin{minipage}{\textwidth}
\subsection{ReadTiltFile}

Defined in \spirouImage\path{.spirouFITS.read_tilt_file}

\begin{pythonbox}
from SpirouDRS import spirouImage
spirouImage.ReadTiltFile(p, hdr=None, filename=None, key=None)
spirouImage.spirouFITS.read_tilt_file(p, hdr=None, filename=None, key=None)
\end{pythonbox}

\begin{pythondocstring}
Reads the tilt file (from calib database or filename) and using the
'kw_TILT' keyword-store extracts the tilts for each order

:param p: parameter dictionary, ParamDict containing constants
    Must contain at least:
            fitsfilename: string, the full path of for the main raw fits
                          file for a recipe
                          i.e. /data/raw/20170710/filename.fits
            kw_TILT: list, the keyword list for kw_TILT (defined in
                     spirouKeywords.py)
            IC_TILT_NBO: int, Number of orders in tilt file

:param hdr: dictionary or None, the header dictionary to look for the
                 acquisition time in, if None loads the header from
                 p['fitsfilename']
:param filename: string or None, the filename and path of the tilt file,
                 if None gets the TILT file from the calib database
                 keyword "TILT"
:param key: string or None, if None key='TILT' else uses string as key
            from calibDB (first entry) to get tilt file

:return tilt: list of the tilt for each order
\end{pythondocstring}
\end{minipage}

%----------------------------------------------------------------------------------------

\noindent\begin{minipage}{\textwidth}
\subsection{ReadWaveFile}

Defined in \spirouImage\path{.spirouFITS.read_wave_file}

\begin{pythonbox}
from SpirouDRS import spirouImage
spirouImage.ReadWaveFile(p, hdr=None, filename=None, key=None, return_header=False)
spirouImage.spirouFITS.read_wave_file(p, hdr=None, filename=None, key=None, return_header=False)
\end{pythonbox}

\begin{pythondocstring}
Reads the wave file (from calib database or filename)

:param p: parameter dictionary, ParamDict containing constants
    Must contain at least:
            fitsfilename: string, the full path of for the main raw fits
                          file for a recipe
                          i.e. /data/raw/20170710/filename.fits
            fiber: string, the fiber used for this recipe (eg. AB or A or C)

:param hdr: dictionary or None, the header dictionary to look for the
                 acquisition time in, if None loads the header from
                 p['fitsfilename']
:param filename: string or None, the filename and path of the tilt file,
                 if None gets the TILT file from the calib database
                 keyword "TILT"
:param key: string or None, if None key='WAVE' else uses string as key
            from calibDB (first entry) to get wave file

:param return_header: bool, if True returns header file else just returns
                      wave file
:return wave: list of the tilt for each order
\end{pythondocstring}
\end{minipage}

%----------------------------------------------------------------------------------------

\noindent\begin{minipage}{\textwidth}
\subsection{ReadOrderProfile}

Defined in \spirouImage\path{.spirouFITS.read_order_profile_superposition}

\begin{pythonbox}
from SpirouDRS import spirouImage
spirouImage.ReadOrderProfile(p, hdr=None, filename=None)
spirouImage.spirouFITS.read_order_profile_superposition(p, hdr=None, filename=None)
\end{pythonbox}

\begin{pythondocstring}
Read the order profile superposition image from either "filename" (if not
None) or get filename from the calibration database using "p"

"ORDER_PROFILE_{X}" must be in calibration database if filename is None
where X is either p["ORDERP_FILE"] or p["FIBER"] (presedence in that order)

:param p: parameter dictionary, ParamDict containing constants
    Must contain at least:
            ORDERP_FILE: string, the suffix for the order profile
                         calibration database key (usually the fiber type)
                         - read from "orderp_file_fpall"
            fiber: string, the fiber used for this recipe (eg. AB or A or C)
            log_opt: string, log option, normally the program name

:param hdr: dictionary or None, header dictionary (used to get the
            acquisition time if trying to get "ORDER_PROFILE_{X}" from
            the calibration database, if None uses the header from the
            first file in "ARG_FILE_NAMES" i.e. "FITSFILENAME"
:param filename: string or None, if defined no need for "hdr" or keys from
                 "p" the order profile is read straight from "filename"

:return orderp: numpy array (2D), the order profile image read from file
\end{pythondocstring}
\end{minipage}

%----------------------------------------------------------------------------------------

\noindent\begin{minipage}{\textwidth}
\subsection{ResizeImage}

Defined in \spirouImage\path{.spirouImage.resize}

\begin{pythonbox}
from SpirouDRS import spirouImage
spirouImage.ResizeImage(image, x=None, y=None, xlow=0, xhigh=None, ylow=0, yhigh=None, getshape=True)
spirouImage.spirouImage.resize(image, x=None, y=None, xlow=0, xhigh=None, ylow=0, yhigh=None, getshape=True)
\end{pythonbox}

\begin{pythondocstring}
Resize an image based on a pixel values

:param image: numpy array (2D), the image
:param x: None or numpy array (1D), the list of x pixels
:param y: None or numpy array (1D), the list of y pixels
:param xlow: int, x pixel value (x, y) in the bottom left corner,
             default = 0
:param xhigh:  int, x pixel value (x, y) in the top right corner,
             if None default is image.shape(1)
:param ylow: int, y pixel value (x, y) in the bottom left corner,
             default = 0
:param yhigh: int, y pixel value (x, y) in the top right corner,
             if None default is image.shape(0)
:param getshape: bool, if True returns shape of newimage with newimage

if getshape = True
:return newimage: numpy array (2D), the new resized image
:return nx: int, the shape in the first dimension, i.e. data.shape[0]
:return ny: int, the shape in the second dimension, i.e. data.shape[1]

if getshape = False
:return newimage: numpy array (2D), the new resized image
\end{pythondocstring}
\end{minipage}

%----------------------------------------------------------------------------------------

\noindent\begin{minipage}{\textwidth}
\subsection{WriteImage}

Defined in \spirouImage\path{.spirouFITS.writeimage}

\begin{pythonbox}
from SpirouDRS import spirouImage
spirouImage.WriteImage(filename, image, hdict, dtype=None)
spirouImage.spirouFITS.writeimage(filename, image, hdict, dtype=None)
\end{pythonbox}

\begin{pythondocstring}
Writes an image and its header to file

:param filename: string, filename to save the fits file to
:param image: numpy array (2D), the image
:param hdict: dictionary, header dictionary to write to fits file

            Must be in form:

                    hdict[key] = (value, comment)
            or
                    hdict[key] = value     (comment will be equal to
                                            "UNKNOWN"
:param dtype: None or hdu format type, forces the image to be in the
              format type specified (if not None)

              valid formats are for example: 'int32', 'float64'

:return None:
\end{pythondocstring}
\end{minipage}

%----------------------------------------------------------------------------------------

\noindent\begin{minipage}{\textwidth}
\subsection{WriteTable}

Defined in \spirouImage\path{.spirouTable.write_table}

\begin{pythonbox}
from SpirouDRS import spirouImage
spirouImage.WriteTable(table, filename, fmt='fits')
spirouImage.spirouTable.write_table(table, filename, fmt='fits')
\end{pythonbox}

\begin{pythondocstring}
Writes a table to file "filename" with format "fmt"

:param filename: string, the filename and location of the table to read
:param fmt: string, the format of the table to read from (must be valid
            for astropy.table to read - see below)

:return None:
\end{pythondocstring}
\end{minipage}

%----------------------------------------------------------------------------------------

