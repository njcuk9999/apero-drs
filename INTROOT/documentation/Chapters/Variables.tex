%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
\ifdevguide
\chapter{Variables}
\else
\chapter{User modifiable variables}
\fi
\label{ch:variables}
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


To better understand the variables in the DRS we have laid out each variable in the following way:

\begin{itemize}
\item \namedlabel{text:variable} \ParameterEntry{Variable title}
{Description of the variable}
{VARIABLE\_NAME}
{Default Value}{The recipe used the variable is used in.}
{The place where the variable is defined.}
{The code (module + function) where variable is used.}
{
Who should be able to change this variable, levels are as follows:
\begin{itemize}
	\item Public: Everyone (including the user)
	\item Private: Only the developer
\end{itemize}
}

\end{itemize}

\ifdevguide
\begin{note}
All variable from all configuration files are (and should be) loaded into the main parameter dictionary `p' in all recipes and thus are accessed via: 
\begin{pythonbox}
variable = p["(*\textcolor{red}{VARIABLE\_NAME}*)"]
\end{pythonbox}
\end{note}
\fi





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
\section{Variable file locations}
\label{ch:variables:location}
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\ifdevguide
\subsection{User modifiable variables}
\fi

The variables are currently stored in two places. The first (\configtxtfile) contains constants that deal with initial set up. These were mentioned in Section \ref{ch:install:setup} and are located in \configtxtfilepath. \\

\noindent The other variables modify how the DRS runs. These are located in \constantsfile\, (located at \constantsfilepath).  \\


\ifdevguide
\subsection{Private variables}

\noindent In addition to the above (user modifiable public variable files) there are several files that will contain all constants that should not be changed by a user (i.e. static variables that are set and changed only in development). These are described below:

\begin{itemize}

	\item \textbf{Keywords:} The keywords for header input and output are stored in \spirouKeywords. This contains keyword definitions in the form of a python list:  \\

	\begin{pythonbox}
	kw_VARIABLE = ['KEYWORD', 'Default value', 'Comment']
	\end{pythonbox}

	\noindent where the 'KEYWORD' is the key in the FITs REC header file, with the value and comment defined in the next positions. i.e. in a FITs REC header reader one would expect

	\begin{thighlight}
	\begin{tabular}{l c r c l}
	KEYWORD & = & Default value & / Comment \\
	\end{tabular}
	\end{thighlight}


	\item \textbf{Constants and Pseudo-constants:} These are stored in \spirouConst, they range from simple objects (strings, integers, float, lists, python dictionaries etc.) to more complicated `pseudo-constants' that are constructed themselves from other constants. These are kept private (i.e. no mentioned in the user manual) as they should not need be changed by the average user.

\end{itemize}

\fi





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
\section{Global variables}
\label{ch:variables:global}
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{itemize}
% DRS_NAME
\ifdevguide
\item \namedlabel{text:drs_name} \ParameterEntry{DRS Name}
{Defines the data reduction software name. Value must be a valid string.}
{DRS\_NAME}{SPIROU}
{\AllRecipes}{\spirouConst.NAME()}{\AllRecipes}{Private}
\fi

% DRS_VERSION
\ifdevguide
\item \namedlabel{text:drs_version} \ParameterEntry{DRS Version}
{Defines the data reduction software version. Value must be a valid string.}
{DRS\_VERSION}{0.0.1}
{\AllRecipes}{\spirouConst.VERSION()}{\AllRecipes}{Private}
\fi


% IC_IMAGE_TYPE
\item \namedlabel{text:ic_image_type} \ParameterEntry{DRS Detector Type}
{Defines the detector. Value must be a valid string. Currently supported values are: ``H2RG'' or ``H4RG''.}
{IC\_IMAGE\_TYPE}{H4RG}
{\AllRecipes}{\constantsfile}{\AllRecipes}{Public}


% DRS_RELEASE
\ifdevguide
\item \ParameterEntry{Release type}
{Defines the current release type or state of the DRS. Value must be a valid string. This could explain the current state or just distinguish between alpha, beta and full releases.}
{release}{'alpha'}
{\AllRecipes}{\spirouConst.RELEASE()}{\AllRecipes}{Private}
\fi

% package
\ifdevguide
\item \ParameterEntry{Package name}
{Defines the name of the python package that all sub-modules are located in. Value must be a string and be the name of a valid python package.}
{package}{SpirouDRS}
{\AllRecipes}{\spirouConst.PACKAGE()}{\AllRecipes}{Private}
\fi

% authors
\ifdevguide
\item \ParameterEntry{authors}
{Defines the authors of the DRS. Value must be a string, author names separated by a comma.}
{authors}{N. Cook, F. Bouchy, E. Artigau, I. Boisse, M. Hobson, C. Moutou}
{\AllRecipes}{\spirouConst.AUTHORS()}{\AllRecipes}{Private}
\fi


% date
\ifdevguide
\item \ParameterEntry{date}
{Defines the last edited date for the DRS. Value must be a string in format YYYY-MM-DD format.}
{date}{2017-11-17}
{None}{\spirouConst.LATEST\_EDIT()}{None}{Private}
\fi


% DRS_PLOT
\item \namedlabel{text:drs_plot} \ParameterEntry{Plotting switch}
{Defines whether to show plots (A value of 1 to show plots, a value of 0 to not show plots). Value must be an integer (0 or 1) or boolean (True or False)}
{DRS\_PLOT}{1}
{\AllRecipes}{\configtxtfile}{\AllRecipes}{Public}

% DRS_INTERACTIVE
\item \namedlabel{text:drs_interactive} \ParameterEntry{Interactive switch}
{Defines whether to run in interactive mode. If False or 0 will be set to non-interactive mode (i.e. \definevariable{text:drs_plot}{DRS\_PLOT} will be set to 0). Will stop any user input at the end of recipes if set to 0.}
{DRS\_INTERACTIVE}{1}
{\AllRecipes}{\configtxtfile}{\AllRecipes}{Public}

% interactive_plots
\ifdevguide
\item \ParameterEntry{Use matplotlib interactive plot environment}
{Defines whether to use the matplotlib interactive plot environment. If True or 1 uses `plot.ion()' and plots do not interrupt the running of code. If False or 0 all plots are run and `plt.show(), plt.close()' is used after each plot (pausing the code and destroying the plots after they are manually closed). This is mostly useful for debugging.}
{interactive\_plots}{True}
{\spirouPlot}{\spirouConst.INTERACITVE\_PLOTS\_ENABLED()}{\spirouPlot variable definition}{Private}
\fi

% DRS_DEBUG
\item \namedlabel{text:drs_debug} \ParameterEntry{Debug mode}
{Defines whether we should run the DRS in debug mode. Certain print/log statements and certain graphs only plot in debug mode. On an error the option to enter the python debugger is asked (allows user to look into functions/current memory and see what variables are currently defined. Value must be an integer. Value must be an integer where:
\begin{itemize}
\item 0 = No debug
\item 1 = basic debugging on errors (prompted to enter python debugger)
\item 2 = Same as 1 and recipes specific (plots and some code runs)
\end{itemize}
}
{DRS\_DEBUG}{0}
{\AllRecipes}{\configtxtfile}{\AllRecipes}{Public}

% DEBUG
\ifdevguide
\item \PseudoParamEntry{Debugging mode controller}
{Controls the debug level (from \definevariable{text:drs_debug}{DRS\_DEBUG})}
{debug}
{\AllRecipes}{\spirouConst.DEBUG()}{\AllRecipes}
\fi


% USER_CONFIG
\item \namedlabel{text:user_config} \ParameterEntry{Enable use of custom configuration files}
{Controls whether the DRS searches for custom configuration files (all configuration files). Value can be 1 (True) or 0 (False), True turns on the use of custom configuration files. Constants/variables set in the custom constant files \textbf{always} take precedence over the master files. Any constant/variable not set in a custom constant file is taken from the master files. Value must be 1 or True to switch on or 0 or False to switch off.}
{DRS\_DEBUG}{0}
{\AllRecipes}{\configtxtfile}{\AllRecipes}{Public}

% ICDP_NAME
\item \namedlabel{text:icdp_name} \ParameterEntry{Plot interval}
{Defines the main constants file for the DRS (not the directory just the file name). The directory is controlled internally or if \definevariable{text:user_config}{USER\_CONFIG} is set by \definevariable{text:drs_uconfig}{DRS\_UCONFIG}}{constants\_SPIROU.py}
{\AllRecipes}{\configtxtfile}{\AllRecipes}{Public}


% SPECIAL_NAME
\item \ParameterEntry{Plot interval}
{Defines the a special constants file for the DRS (not the directory just the file name). The directory is controlled internally or if \definevariable{text:user_config}{USER\_CONFIG} is set by \definevariable{text:drs_uconfig}{DRS\_UCONFIG}}{special\_config\_SPIROU.py}
{\AllRecipes}{\configtxtfile}{\AllRecipes}{Public}
\DevNote{This file does not currently exist.}

% ic_display_timeout
\item \ParameterEntry{Plot interval}
{Set the interval between plots in seconds (for certain interactive graphs). Value must be a valid float larger than zero.}
{ic\_display\_timeout}{0.5}{\callocRAW}{\constantsfile}{}{Public}
\DevNote{Should this be public?}

\end{itemize}






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
\section{Directory variables}
\label{ch:variables:directory}
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{itemize}

% TDATA
\item \namedlabel{text:tdata} \ParameterEntry{The data directory}
{Defines the path to the data directory. Value must be a string containing a valid file location.}
{TDATA}{/drs/data/}{\AllRecipes}{\configtxtfile}{\spirouConst}{Public}

% DRS_ROOT
\item \namedlabel{text:drs_root} \ParameterEntry{The installation directory}
{Defines the installation directory (\InstallDIR). Value must be a string containing a valid file location.}
{DRS\_ROOT}{/drs/INTROOT/}{\AllRecipes}{\configtxtfile}{\spirouConst}{Public}

% DRS_DATA_RAW
\item \namedlabel{text:drs_data_raw} \ParameterEntry{The raw data directory}
{Defines the directory that the reduced data will be saved to/read from. Value must be a string containing a valid file location.}
{DRS\_DATA\_RAW}{/drs/data/raw}{\AllRecipes}{\configtxtfile}{\spirouConst}{Public}

% DRS_DATA_REDUC
\item \namedlabel{text:drs_data_reduc} \ParameterEntry{The reduced data directory}
{Defines the directory that the reduced data will be saved to/read from. Value must be a string containing a valid file location.}
{DRS\_DATA\_REDUC}{/drs/data/reduced}{\AllRecipes}{\configtxtfile}{\spirouConst}{Public}

% DRS_CALIB_DB
\item \namedlabel{text:drs_calib_db} \ParameterEntry{The calibration database and calibration file directory}
{Defines the directory that the calibration files and database will be saved to/read from. Value must be a string containing a valid file location.}
{DRS\_CALIB\_DB}{/drs/data/calibDB}{\AllRecipes}{\configtxtfile}{\spirouConst}{Public}

% DRS_DATA_MSG
\item \namedlabel{text:drs_data_msg} \ParameterEntry{The log directory}
{Defines the directory that the log messages are stored in. Value must be a string containing a valid file location.}
{DRS\_DATA\_MSG}{/drs/data/msg}{\AllRecipes}{\configtxtfile}{\spirouConst}{Public}

% DRS_DATA_WORKING
\item \namedlabel{text:drs_data_working} \ParameterEntry{The working directory}
{Defines the working directory. Value must be a string containing a valid file location.}
{DRS\_DATA\_WORKING}{/drs/data/tmp/}{\AllRecipes}{\configtxtfile}{\spirouConst}{Public}

% DRS_UCONFIG
\item \namedlabel{text:drs_uconfig} \ParameterEntry{The custom configuration directory}
{Defines the custom configuration directory. Value must be a string containing a valid file location.}
{DRS\_UCONFIG}{$\sim$/spirou\_config/}{\AllRecipes}{\configtxtfile}{\spirouConst}{Public}

\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
\section{Observatory variables}
\label{ch:variables:observatory}
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{itemize}

% IC_LONGIT_OBS
\item \namedlabel{text:ic_longit_obs} \ParameterEntry{CFHT Longitude}
{Defines the CFHT longitude West (in degrees)}
{IC\_LONGIT\_OBS}{155.468876}
{\calCCF}{\constantsfile}{\spirouRV.\path{earth_velocity_correction}}{Public}

% IC_LATIT_OBS
\item \namedlabel{text:ic_longit_obs} \ParameterEntry{CFHT Longitude}
{Defines the CFHT latitude North (in degrees)}
{IC\_LATIT\_OBS}{19.825252}
{\calCCF}{\constantsfile}{\spirouRV.\path{earth_velocity_correction}}{Public}

% IC_ALTIT_OBS
\item \namedlabel{text:ic_longit_obs} \ParameterEntry{CFHT Longitude}
{Defines the CFHT altitude (in km)}
{IC\_ALTIT\_OBS}{4.204}
{\calCCF}{\constantsfile}{\spirouRV.\path{earth_velocity_correction}}{Public}

\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
\section{Image variables}
\label{ch:variables:image}
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{itemize}

% Resize blue window (has to be defined manually)
% IC_CCDX_BLUE_LOW
% IC_CCDX_BLUE_HIGH
% IC_CCDY_BLUE_LOW
% IC_CCDY_BLUE_HIGH
\item 
\begin{minipage}[t]{\textwidth}
\textbf{Resizing blue window (\textcolor{red}{ic\_ccd\{x/y\}\_blue\_\{low/high\}})}

\begin{thighlight}
\textcolor{brown}{The blue window used in \calDARK. Each value must be a integer between 0 and the maximum array size in each dimension.} 

\begin{tabular}{>{\color{red}}l c l}
&&\\
ic\_ccdx\_blue\_low &=& 2048-200 \\
ic\_ccdx\_blue\_high &=& 2048-1500 \\
ic\_ccdy\_blue\_low &=& 2048-20 \\
ic\_ccdy\_blue\_high &=& 2048-350 \\
&&\\
\textcolor{blue}{Used in:}  & \multicolumn{2}{p{10cm}}{\calDARK} \\
\textcolor{blue}{Defined in:} & \multicolumn{2}{p{10cm}}{\constantsfile} \\
\ifdevguide
\textcolor{blue}{Called in:} & \multicolumn{2}{p{10cm}}{\textcolor{codegreen}{\calDARK.\progMAIN}} \\
\textcolor{blue}{Level:} & \multicolumn{2}{p{10cm}}{Public} \\
\fi
\end{tabular}
\end{thighlight}
\end{minipage}


% Resize red window (has to be defined manually)
 % IC_CCDX_RED_LOW
 % IC_CCDX_RED_HIGH
 % IC_CCDY_RED_LOW
 % IC_CCDY_RED_HIGH
\item 
\begin{minipage}[t]{\textwidth}
\textbf{Resizing red window (\textcolor{red}{ic\_ccd\{x/y\}\_red\_\{low/high\}})}

\begin{thighlight}
\textcolor{brown}{The blue window used in \calDARK. Each value must be a integer between 0 and the maximum array size in each dimension.} 

\begin{tabular}{>{\color{red}}l c l}
&&\\
ic\_ccdx\_red\_low  & =  & 2048-20 \\
ic\_ccdx\_red\_high &  = &  2048-1750 \\
ic\_ccdy\_red\_low  & =  & 2048-1570 \\
ic\_ccdy\_red\_high &  = &  2048-1910 \\
&&\\
\textcolor{blue}{Used in:}  & \multicolumn{2}{p{10cm}}{\calDARK} \\
\textcolor{blue}{Defined in:} & \multicolumn{2}{p{10cm}}{\constantsfile} \\
\ifdevguide
\textcolor{blue}{Called in:} & \multicolumn{2}{p{10cm}}{\textcolor{codegreen}{\calDARK.\progMAIN}} \\
\textcolor{blue}{Level:} & \multicolumn{2}{p{10cm}}{Public} \\
\fi
\end{tabular}
\end{thighlight}
\end{minipage}



% Resize image (has to be defined manually)
% IC_CCDX_LOW
% IC_CCDX_HIGH
% IC_CCDY_LOW
% IC_CCDY_HIGH
\item 
\begin{minipage}[t]{\textwidth}
\textbf{Resizing red window (\textcolor{red}{ic\_ccd\{x/y\}\_\{low/high\}})}

\begin{thighlight}
\textcolor{brown}{The blue window used in \calDARK. Each value must be a integer between 0 and the maximum array size in each dimension.} 

\begin{tabular}{>{\color{red}}l c l}
&&\\
ic\_ccdx\_low &=& 5 \\
ic\_ccdx\_high &=& 2040 \\
ic\_ccdy\_low &=& 5 \\
ic\_ccdy\_high &=& 1935 \\
&&\\
\textcolor{blue}{Used in:}  & \multicolumn{2}{p{10cm}}{\callocRAW, \calSLIT, \calFFraw, \calextractRAW, \calDRIFTRAW} \\
\textcolor{blue}{Defined in:} & \multicolumn{2}{p{10cm}}{\constantsfile} \\
\ifdevguide
\textcolor{blue}{Called in:} & \multicolumn{2}{p{10cm}}{\textcolor{codegreen}{\callocRAW\progMAIN, \calSLIT\progMAIN, \calFFraw\progMAIN, \calextractRAW\progMAIN, \calDRIFTRAW.\progMAIN}} \\
\textcolor{blue}{Level:} & \multicolumn{2}{p{10cm}}{Public} \\
\fi
\end{tabular}
\end{thighlight}
\end{minipage}


% Avaiable fiber types
% fiber_types
\item \namedlabel{text:fiber_types} \ParameterEntry{Available fiber types}
{Defines the type of fiber we have (used in various codes). Theses are define in a python list of string, where the earlier a fiber is in the list the more it takes priority in searches (i.e. AB over A or B if AB is first)}
{fiber\_types}
{\lstinline[style=pythoninline]| ['AB', 'A', 'B', 'C'] |}
{\calextractRAW, \calDRIFTE}{\constantsfile}{\calextractRAW.\progMAIN, \spirouStartup.get\_fiber\_type()}{Public}


\end{itemize}






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
\clearpage
\newpage
\section{Fiber variables}
\label{ch:variables:fiber}
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

These variables are defined for each type of fiber and thus are defined as a python dictionary of values \ifdevguide (read using the python `eval' function) \fi. As such they all must contain the same dictionary keys (currently `AB', `A', `B' and `C'). 

\DevNote{For python to combine these at run time the suffix `\_fpall' must be used (thus once a fiber is defined the code will know to extract the key before the suffix). i.e. for variable `nbfib\_fpall' and a fiber `AB' the extracted parameter will be `nbfib' with the value in the dictionary corresponding to the `AB' key.}

\begin{itemize}

% nbfib
% nbfib_fpall
\item \ParameterEntry{Number of fibers}
{This describes the number of fibers of a given type. Must be a python dictionary with identical keys to all other fiber parameters (each value must be an integer).}
{nbfib\_fpall}
{\lstinline[style=pythoninline]| \{'AB':2, 'A':1, 'B':1, 'C':1\} |}
{\callocRAW}{\constantsfile}
{\callocRAW.\progMAIN}{Public}

% ic_first_order_jump
% ic_first_order_jump_fpall
\item \ParameterEntry{Order skip number}
{Describes the number of orders to skip at the start of an image. Must be a python dictionary with identical keys to all other fiber parameters (each value must be an integer).}
{ic\_first\_order\_jump\_fpall}
{\lstinline[style=pythoninline]| \{'AB':2, 'A':0, 'B':0, 'C':0\} |}
{\callocRAW}{\constantsfile}
{\callocRAW.\progMAIN}{Public}

% ic_locnbmaxo
% ic_locnbmaxo_fpall
\item \ParameterEntry{Maximum order numbers}
{Describes the maximum allowed number of orders. Must be a python dictionary with identical keys to all other fiber parameters (each value must be an integer).}
{ic\_locnbmaxo\_fpall}
{\lstinline[style=pythoninline]| \{'AB':72, 'A':36, 'B':36, 'C':36\} |}
{\callocRAW}{\constantsfile}
{\callocRAW.\progMAIN}{Public}

% qc_loc_nbo
% qc_loc_nbo_fpall
\item \namedlabel{text:qc_loc_nbo_fpall} \ParameterEntry{Number of orders to fit (QC)}
{Quality control parameter for the number of orders on fiber to fit. Must be a python dictionary with identical keys to all other fiber parameters (each value must be an integer).}
{qc\_loc\_nbo\_fpall}
{\lstinline[style=pythoninline]| \{'AB':72, 'A':36, 'B':36, 'C':36\} |}
{\callocRAW}{\constantsfile}
{\callocRAW.\progMAIN}{Public}
\DevNote{Should this be merged with `ic\_locnbmaxo\_fpall'?}

% fib_type
% fib_type_fpall
\item \ParameterEntry{Fiber types for this fiber}
{The fiber type(s) -- as a list -- for this fiber. Must be a python dictionary with identical keys to all other fiber parameters (each value must be a list of strings).}
{fib\_type\_fpall}
{\lstinline[style=pythoninline]| \{'AB':["AB"], 'A':["A"], 'B':["B"], 'C':["C"]\} |}
{\calFFraw}{\constantsfile}
{\calFFraw.\progMAIN}{Public}
\DevNote{This is not be needed but is in here due to a loop in \calFFraw}

% ic_ext_range1
% ic_ext_range1_fpall
\item \ParameterEntry{Half-zone extraction width (left/top)}
{The pixels are extracted from the center of the order out to the edges in the row direction (y-axis), i.e. defines the illuminated part of the order - this number defines the \textbf{top} side (if one requires a symmetric extraction around the order fit both range 1 and range 2 -- below -- should be the same). This can also be used to extract A and B separately (where the fit order is defined at the centre of the AB pair). Must be a python dictionary with identical keys to all other fiber parameters.}
{ic\_ext\_range1\_fpall}
{\lstinline[style=pythoninline]| \{'AB':14.5, 'A':0.0, 'B':14.5, 'C':7.5\} |}
{\calFFraw}{\constantsfile}
{\calextractRAW.\progMAIN, \spirouEXTOR.extract\_tilt\_weight\_order2(), \spirouPlot.ff\_sorder\_fit\_edges()}{Public}
\DevNote{Formally this was called `plage1' in \calFFraw}

% ic_ext_range2
% ic_ext_range2_fpall
\item \ParameterEntry{Half-zone extraction width (right/bottom)}
{The pixels are extracted from the center of the order out to the edges in the row direction (y-axis), i.e. defines the illuminated part of the order - this number defines the \textbf{bottom} side (if one requires a symmetric extraction around the order fit both range 1 and range 2 -- below -- should be the same). This can also be used to extract A and B separately (where the fit order is defined at the centre of the AB pair). Must be a python dictionary with identical keys to all other fiber parameters.}
{ic\_ext\_range2\_fpall}
{\lstinline[style=pythoninline]| \{'AB':14.5, 'A':14.5, 'B':0.0, 'C':7.5\} |}
{\calFFraw, \calextractRAW}{\constantsfile}
{\calFFraw.\progMAIN, \calextractRAW.\progMAIN, \spirouEXTOR.extract\_tilt\_weight\_order2(), \spirouPlot.ff\_sorder\_fit\_edges()}{Public}
\DevNote{Formally this was called `plage2' in \calFFraw}

% ic_ext_range
% ic_ext_range_fpall
\item \ParameterEntry{Half-zone extraction width for full extraction}
{The pixels are extracted from the centre of the order out to the edges in the row direction (y-axis), i.e. defines the illuminated part of the order. In \calextractRAW both sides of the fit order are extracted at with the same width (symmetric). Must be a python dictionary with identical keys to all other fiber parameters.}
{ic\_ext\_range\_fpall}
{\lstinline[style=pythoninline]| \{'AB':14.5, 'A':14.5, 'B':14.5, 'C':7.5\} |}
{\calextractRAW}{\constantsfile}
{\spirouEXTOR.extract\_order(), \spirouEXTOR.extract\_tilt\_order(), \spirouEXTOR.extract\_tilt\_weight\_order(), \spirouEXTOR.extract\_weight\_order()}{Public}
\DevNote{Formally this was called `plage' in \calextractRAW}

% loc_file
% loc_file_fpall
\item \ParameterEntry{Localization fiber for extraction  }
{Defines the localization fiber to use for each fiber type. This is the file in calibDB that is used i.e. the keyword \masterCALIBDBfile used will be \`LOC\_\{loc\_file\_fpall\}' (e.g. for fiber=`AB' use `LOC\_AB'). Must be a python dictionary with identical keys to all other fiber parameters.}
{loc\_file\_fpall}
{\lstinline[style=pythoninline]| \{'AB':'AB', 'A':'AB', 'B':'AB', 'C':'C'\} |}
{\calextractRAW}{\constantsfile}
{\spirouLOCOR.get\_loc\_coefficients()}{Public}

% orderp_file
% orderp_file_fpall
\item \ParameterEntry{Order profile fiber for extraction}
{Defines the order profile fiber to use for each fiber type. This is the file in calibDB that is used i.e. the keyword \masterCALIBDBfile used will be \`ORDER\_PROFILE\_\{orderp\_file\_fpall\}' (e.g. for fiber=`AB' use `ORDER\_PROFILE\_AB'). Must be a python dictionary with identical keys to all other fiber parameters.}
{orderp\_file\_fpall}
{\lstinline[style=pythoninline]| \{'AB':'AB', 'A':'AB', 'B':'AB', 'C':'C'\} |}
{\calextractRAW}{\constantsfile}
{\spirouFITS.read\_order\_profile\_superposition()}{Public}

% ic_ext_d_range
% ic_ext_d_range_fpall
\item \ParameterEntry{Half-zone extract width \calDRIFTRAW}
{The size in pixels of the extraction away from the order localization fit (to the top and bottom) - defines the illuminated area of the order for extraction. Must be a python dictionary with identical keys to all other fiber parameters.}
{ic\_ext\_d\_range\_fpall}
{\lstinline[style=pythoninline]| \{'AB':14.0, 'A':14.0, 'B':14.0, 'C':7.0\} |}
{\calDRIFTRAW}{\constantsfile}
{\calDRIFTRAW.\progMAIN}{Public}
\DevNote{Formally this was called `ic\_extnbsig' in \calDRIFTRAW}

\end{itemize}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
\clearpage
\newpage
\section{Pre-processing variables}
\label{ch:variables:preprocessing}
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{itemize}

% PP_MODE
\item \namedlabel{text:pp_mode} \ParameterEntry{Preprocessing Mode}
{Defines the preprocessing output type. Currently expected values are:
\begin{itemize}
	\item 0: Adds only the \definevariable{text:processed_suffix}{PROCESSED\_SUFFIX}
	\item 1: Adds the \definevariable{text:processed_suffix}{PROCESSED\_SUFFIX} and an identifying suffix (i.e. \path{flat_dark}, \path{dark_dark} etc.)
\end{itemize}
}
{PP\_MODE}{0}
{\calpreprocess}{\constantsfile}{\spirouFile.\path{id_mode}}{Public}


% IC_FORCE_PREPROCESS
\item \namedlabel{text:ic_force_preprocess} \ParameterEntry{Force Pre-processing}
{Defines whether the DRS should force pre-processed files only. If True (or 1) only files that are pre-processed will be allowed to be used in the DRS (an error will be generated on un-preprocessed files). If False (or 0) any file will be accepted (but un-preprocessed files will be assumed to be raw and hence rotated, as in pre-processing).}
{IC\_FORCE\_PREPROCESS}{1}
{\AllRecipes}{\constantsfile}
{\spirouFile.\path{check_file_id}, \spirouFile.\path{check_preprocess}}{Public}

% PROCESSED_SUFFIX
\item \namedlabel{text:processed_suffix} \ParameterEntry{Pre-processing suffix}
{Defines the suffix to apply to the pre-processed files. If "None" then no suffix is added (or checked for).}
{PROCESSED\_SUFFIX}{"\_pp.fits"}
{\AllRecipes}{\constantsfile}{\calpreprocess.main, \offlisting.main, \spirouFile.\path{check_file_id}, \spirouFile.\path{check_preprocess}, \spirouImage.\path{fix_non_preprocessed}}{Public}

% NUMBER_DARK_AMP
\item \namedlabel{text:number_dark_amp} \ParameterEntry{Number of dark amplifiers}
{Defines the number of dark amplifiers on the detector}
{NUMBER\_DARK\_AMP}{5}
{\calpreprocess}{\constantsfile}{\spirouImage.\path{median_filter_dark_amp}}{Public}

% TOTAL_AMP_NUM
\item \namedlabel{text:total_amp_num} \ParameterEntry{Total number of amplifiers}
{Defines the total number of amplifiers on the detector}
{TOTAL\_AMP\_NUM}{32}
{\calpreprocess}{\constantsfile}{\spirouImage.\path{ref_top_bottom}, \spirouImage.\path{median_filter_dark_amp}}{Public}

% NUMBER_REF_TOP
\item \namedlabel{text:number_ref_top} \ParameterEntry{Number of top reference pixels}
{Defines the number of un-illuminated reference pixels at the top of the image.}
{NUMBER\_REF\_TOP}{4}
{\calpreprocess}{\constantsfile}{\spirouImage.\path{ref_top_bottom}, \spirouImage.\path{median_one_over_f_noise}}{Public}

% NUMBER_REF_BOTTOM
\item \namedlabel{text:number_ref_top} \ParameterEntry{Number of bottom reference pixels}
{Defines the number of un-illuminated reference pixels at the bottom of the image.}
{NUMBER\_REF\_BOTTOM}{4}
{\calpreprocess}{\constantsfile}{\spirouImage.\path{ref_top_bottom}, \spirouImage.\path{median_one_over_f_noise}}{Public}

% DARK_MED_BINNUM
\item \namedlabel{text:dark_med_binnum} \ParameterEntry{Number of bins in dark median process}
{Define the number of bins used in the dark media process.}
{DARK\_MED\_BINNUM}{32}
{\calpreprocess}{\constantsfile}{\spirouImage.\path{median_filter_dark_amp}, \spirouImage.\path{median_one_over_f_noise}}{Public}

% RAW_TO_PP_ROTATION
\item \namedlabel{text:raw_pp_rotation} \ParameterEntry{Raw to Pre-processed rotation}
{Defines the rotation angle of the raw images compared to that expected by the DRS. Value must be multiple of 90 degrees (in degrees counter-clockwise direction).}
{RAW\_TO\_PP\_ROTATION}{-90}
{\AllRecipes}{\constantsfile}{\calpreprocess.main, \spirouImage.\path{fix_non_preprocessed}}{Public}

\end{itemize}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
\clearpage
\newpage
\section{Dark calibration variables}
\label{ch:variables:dark}
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{itemize}

% dark_qmin
\item \ParameterEntry{Lower percentile for dead pixel stats}
{This defines the lower percentile to be logged for the fraction of dead pixels statistics. Value must be an integer between 0 and 100 (1 sigma below the mean is $\sim$16).}
{dark\_qmin}{5}
{\calDARK}{\constantsfile}
{\spirouImage.measure\_dark()}{Public}

% dark_qmax
\item \ParameterEntry{Upper percentile for dead pixel stats}
{This defines the upper percentile to be logged for the fraction of dead pixels statistics. Value must be an integer between 0 and 100 (1 sigma above the mean is $\sim$84).}
{dark\_qmax}{95}
{\calDARK}{\constantsfile}
{\spirouImage.measure\_dark()}{Public}

% histo_bins
\item \ParameterEntry{Dark stat histogram bins}
{Defines the number of bins to use in the dark histogram plot. Value must be a positive integer.}
{histo\_bins}{200}
{\calDARK}{\constantsfile}
{\spirouImage.measure\_dark()}{Public}

% histo_range_low
\item \ParameterEntry{Lower bound for the Dark stat histogram}
{Defines the lower bound for the dark statistic histogram. Value must be a float less than (no equal to) the value of `histo\_range\_high'}
{histo\_range\_low}{-0.5}
{\calDARK}{\constantsfile}
{\spirouImage.measure\_dark()}{Public}

% histo_range_high
\item \ParameterEntry{Upper bound for the Dark stat histogram}
{Defines the upper bound for the dark statistic histogram. Value must be a float greater than (not equal to) the value of `histo\_range\_low'}
{histo\_range\_high}{5}
{\calDARK}{\constantsfile}
{\spirouImage.measure\_dark()}{Public}

% dark_cutlimit
\item \namedlabel{text:dark_cutlimit} \ParameterEntry{Bad pixel cut limit}
{Defines the bad pixel cut limit in ADU/s. 
\begin{equation}
badpixels = (image > \text{dark\_cut\_limit}) \text{ OR } (\text{non-finite})
\end{equation}}
{dark\_cutlimit}{100.0}
{\calDARK}{\constantsfile}
{\calDARK.\progMAIN}{Public}

\end{itemize}






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
\clearpage
\newpage
\section{Localization calibration variables}
\label{ch:variables:localization}
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{itemize}

% loc_box_size
\item \ParameterEntry{Order profile smoothed box size}
{Defines the size of the order profile smoothing box (from the central pixel minus size to the central pixel plus size). Value must be an integer larger than zero.}
{loc\_box\_size}{10}
{\callocRAW}{\constantsfile}
{\callocRAW.\progMAIN}{Public}


% ic_offset
\item \ParameterEntry{Image row offset}
{The row number (y axis) of the image to start localization at (below this row orders will not be fit). Value must be an integer equal to or larger than zero.}
{ic\_offset}{40}
{\callocRAW}{\constantsfile}
{\callocRAW.\progMAIN }{Public}

% ic_cent_col
\item \ParameterEntry{Central column of the image}
{The column which is to be used as the central column (x-axis), this is the column that is initially used to find the order locations. Value must be an integer between 0 and the number of columns (x-axis dimension).}
{ic\_cent\_col}{1000}
{\callocRAW, \calFFraw, \calextractRAW}{\constantsfile}
{\callocRAW.\progMAIN, \calFFraw.\progMAIN, \calextractRAW.\progMAIN, \spirouBACK.measure\_background\_{\hskip 0pt}and\_get\_central\_pixels(), \spirouPlot.slit\_sorder\_plot(), \spirouEXTOR.extract\_AB\_order(), \spirouLOCOR.find\_order\_centers(), \spirouLOCOR.initial\_order\_fit()}{Public}

% ic_ext_window
\item \ParameterEntry{Localization window row size}
{Defines the size of the localization window in rows (y-axis). Value must be an integer larger than zero and less than the number of rows (y-axis dimension).}
{ic\_ext\_window}{12}
{\callocRAW}{\constantsfile}
{\spirouLOCOR.find\_order\_centers}{Public}
\DevNote{Formally this was called `ic\_ccdcolc' in \callocRAW}

% ic_locstepc
\item \ParameterEntry{Localization window column step}
{For the initial localization procedure interval points along the order (x-axis) are defined and the centers are found, this is used as the first estimate of the order shape. This parameter defines that interval step in columns (x-axis). Value must be an integer larger than zero and less than the number of columns (x-axis dimension).}
{ic\_locstepc}{12}
{\callocRAW}{\constantsfile}
{\spirouLOCOR.find\_order\_centers}{Public}

% ic_image_gap
\item \ParameterEntry{Image gap index}
{Defines the image gap index. The order is skipped if the top of the row (row number - ic\_ext\_window) or bottom of the row (row number + ic\_ext\_window) is inside this image gap index. i.e. a order is skipped if:
\begin{equation}
(\text{top of the row} < \text{ic\_image\_gap})
\text{ OR } 
(\text{bottom of the row} > \text{ic\_image\_gap})
\end{equation}
Value must be an integer between zero and the number of rows (y-axis dimension).
}
{ic\_image\_gap}{0}
{\callocRAW}{\constantsfile}
{\spirouLOCOR.find\_order\_centers}{Public}
\DevNote{This is set to zero and never used in a meaningful way, should it be removed?}


% ic_widthmin
\item \ParameterEntry{Minimum order row size}
{Defines the minimum row width (width in y-axis) to accept an order as valid. If below this threshold order is not recorded. Value must be an integer between zero and the number of rows (y-axis dimension).}
{ic\_widthmin}{5}
{\callocRAW}{\constantsfile}
{\spirouLOCOR.find\_order\_centers}{Public}


% ic_noise_mult_thres
\item \ParameterEntry{Center noise multiplier threshold}
{Defines the noise multiplier threshold in order to accept an order center as usable such that:
\begin{equation}
max(value) - min(value) > \text{ic\_noise\_mult\_thres} * sigdet
\end{equation}
where the value is row center pixel value and sigdet is the image's read out noise. Values must be a float.}
{ic\_noise\_mult\_thres}{100}
{\callocRAW}{\constantsfile}
{\spirouLOCOR.find\_order\_centers}{Public}


% bad_region_fit
\item \ParameterEntry{Polynomial fit coefficients for bad region interp.}
{Defines the polynomial fit parameters for interpolating over the bad regions (holes) before the localization is done. Must be a python list of floats. The coefficient list should be in the following order:
\begin{equation}
p[0]*x^{(N-1)} + p[1]*x^{(N-2)} + \text{...} + p[N-2]*x + p[N-1]
\end{equation}
}
{bad\_region\_fit}{[3.19884964e-05,  -1.08289228e-01,   2.16643659e+03]}
{\callocRAW}{\constantsfile}
{\spirouImage.interp\_bad\_regions}{Public}

% bad_region_med_size
\item \ParameterEntry{Median filter box size 1 for bad region interp.}
{Defines the median filter box size used in interpolating over the bad regions (holes) before the localization is done. Value must be a positive integer.}
{bad\_region\_med\_size}{101}
{\callocRAW}{\constantsfile}
{\spirouImage.interp\_bad\_regions}{Public}

% bad_region_threshold
\item \ParameterEntry{Threshold for bad pixels for bad region interp.}
{Defines the threshold below which the image (normalised between 0 and 1) should be regarded as bad. Used in interpolating over the bad regions (holeS) before localization is done. Value must be a float between 0 and 1.}
{bad\_region\_threshold}{0.2}
{\callocRAW}{\constantsfile}
{\spirouImage.interp\_bad\_regions}{Public}

% bad_region_kernel_size
\item \ParameterEntry{Box size (kernel) for convolve in bad region interp.}
{Defines the box size (kernel) for the convolution. Used in interpolating over the bad regions (holes) before localization is done. Value must be a positive integer.}
{bad\_region\_kernel\_size}{51}
{\callocRAW}{\constantsfile}
{\spirouImage.interp\_bad\_regions}{Public}

% bad_region_med_size2
\item \ParameterEntry{Median filter box size 2 for bad region interp.}
{Defines the median filter box size used  (during the convolution) in interpolating over the bad regions (holes) before the localization is done. Value must be a positive integer.}
{bad\_region\_med\_size2}{11}
{\callocRAW}{\constantsfile}
{\spirouImage.interp\_bad\_regions}{Public}

% bad_region_good_value
\item \ParameterEntry{Threshold for good ratio for bad region interp.}
{Defines the threshold (of the ratio between original image and the interpolated image) where pixels are deemed "good". For use in interpolating over the bad regions (holes) before the localization is done.}
{bad\_region\_good\_value}{0.5}
{\callocRAW}{\constantsfile}
{\spirouImage.interp\_bad\_regions}{Public}

% bad_region_bad_value
\item \ParameterEntry{Threshold for bad ratio for bad region interp.}
{Defines the threshold (of the ratio between original image and the interpolated image) where pixels are deemed "bad". For use in interpolating over the bad regions (holes) before the localization is done.}
{bad\_region\_bad\_value}{0.25}
{\callocRAW}{\constantsfile}
{\spirouImage.interp\_bad\_regions}{Public}

% ic_locnbpix
\item \ParameterEntry{Min/Max smoothing box size}
{Defines the half-size of the rows to use when smoothing the image to work out the minimum and maximum pixel values. This defines the half-spacing between orders and is used to estimate background and the maximum signal. Value must be greater than zero and less than the number of rows (y-axis dimension).}
{ic\_locnbpix}{45}
{\callocRAW}{\constantsfile}
{\spirouBACK.measure\_min\_max()}{Public}

% ic_min_amplitude
\item \ParameterEntry{Minimum signal amplitude}
{Defines a cut off (in e-) where below this point the central pixel values will be set to zero. Value must be a float greater than zero.}
{ic\_min\_amplitude}{100.0}
{\callocRAW}{\constantsfile}{\spirouBACK.measure\_background\_{\hskip 0pt}and\_get\_central\_pixels()}
{Public}

% ic_locseuil
\item \ParameterEntry{Normalized background amplitude threshold}
{Defines the normalized amplitude threshold to accept pixels for background calculation (pixels below this normalized value will be used for the background calculation). Value must be a float between zero and one.}
{ic\_locseuil}{0.2}
{\callocRAW}{\constantsfile}{\spirouBACK.measure\_background\_{\hskip 0pt}and\_get\_central\_pixels()}
{Public}

% ic_satseuil
\item \ParameterEntry{Saturation threshold on the order profile plot}
{Defines the saturation threshold on the order profile plot, pixels above this value will be set this value (ic\_satseuil). Value must be a float greater than zero.}
{ic\_satseuil}{64536}
{\callocRAW}{\constantsfile}{\callocRAW.\progMAIN}{Public}


% ic_locdfitc
\item \namedlabel{text:ic_locdfitc} \ParameterEntry{Degree of the fitting polynomial for localization position}
{Defines the degree of the fitting polynomial for locating the positions of each order i.e. if value is 1 is a linear fit, if the value is 2 is a quadratic fit. The value must be a positive integer equal to or greater than zero (zero would lead to a constant fit along the column direction (x-axis direction).}
{ic\_locdfitc}{5}
{\callocRAW}{\constantsfile}{\spirouLOCOR.initial\_order\_fit(), \spirouLOCOR.sigmaclip\_order\_fit()}{Public}


% ic_locdfitw
\item \ParameterEntry{Degree of the fitting polynomial for localization width}
{Defines the degree of the fitting polynomial for measuring the width of each order i.e. if value is 1 is a linear fit, if the value is 2 is a quadratic fit. The value must be a positive integer equal to or greater than zero (zero would lead to a constant fit along the row direction (y-axis direction).}
{ic\_locdfitw}{5}
{\callocRAW}{\constantsfile}{\spirouLOCOR.initial\_order\_fit(), \spirouLOCOR.sigmaclip\_order\_fit()}{Public}


% ic_locdfitp
\item \ParameterEntry{Degree of the fitting polynomial for localization position error}
{Defines the degree of the fitting polynomial for locating the positions error of each order i.e. if value is 1 is a linear fit, if the value is 2 is a quadratic fit. The value must be a positive integer equal to or greater than zero (zero would lead to a constant fit along the column direction (x-axis direction).}
{ic\_locdfitp}{3}
{\callocRAW}{\constantsfile}{\spirouKeywords, \callocRAW.\progMAIN, \spirouLOCOR.sigmaclip\_order\_fit()}{Public}
\DevNote{This is only currently used to add the value to the localization file (`\_loco\_\definevariable{text:fiber_types}{fiber}.fits') but not used in any calculation. It could be removed?}


% ic_max_rms_center
\item \ParameterEntry{Maximum RMS for sigma-clipping order fit (positions)}
{Defines the maximum RMS allowed for an order, if RMS is above this value the position with the highest residual is removed and the fit is recalculated without that position (sigma-clipped). Value must be a positive float.
\vspace{0.5cm}
i.e. position fit is recalculated if: 
\begin{equation}
max(RMS) > \text{ic\_max\_rms\_center}
\end{equation}
}
{ic\_max\_rms\_center}{0.2}
{\callocRAW}{\constantsfile}
{\spirouLOCOR.sigmaclip\_order\_fit()}{Public}


% ic_max_ptp_center
\item \ParameterEntry{Maximum peak-to-peak for sigma-clipping order fit (positions)}
{Defines the maximum peak-to-peak value allowed for an order, if the peak to peak is above this value the position with the highest residual is removed and the fit is recalculated without that position (sigma-clipped). Value must be a positive float.
\vspace{0.5cm}
i.e. position fit is recalculated if: 
\begin{equation}
max(|\text{residuals}|) > \text{ic\_max\_ptp\_center}
\end{equation}
}
{ic\_max\_ptp\_center}{0.2}
{\callocRAW}{\constantsfile}{\spirouLOCOR.sigmaclip\_order\_fit()}{Public}


% ic_ptporms_center
\item \ParameterEntry{Maximum peak-to-peak-RMS ratio for sigma-clipping order fit(positions)}
{Defines the maximum ratio of peak-to-peak residuals and RMS value allowed for an order, if the ratio is above this value the position with the highest residual is removed and the fit is recalculated without that position (sigma-clipped). Value must be a positive float.
\vspace{0.5cm}
i.e. position fit is recalculated if: 
\begin{equation}
max(|\text{residuals}|)/\text{RMS} > \text{ic\_ptporms\_center}
\end{equation}
}
{ic\_ptporms\_center}{8.0}
{\callocRAW}{\constantsfile}{\spirouLOCOR.sigmaclip\_order\_fit()}{Public}


% ic_max_rms_fwhm
\item \ParameterEntry{Maximum RMS for sigma-clipping order fit (width)}
{Defines the maximum RMS allowed for an order, if RMS is above this value the width with the highest residual is removed and the fit is recalculated without that width (sigma-clipped). Value must be a positive float.
\vspace{0.5cm}
i.e. width fit is recalculated if: 
\begin{equation}
max(RMS) > \text{ic\_max\_rms\_width}
\end{equation}
}
{ic\_max\_rms\_fwhm}{1.0}
{\callocRAW}{\constantsfile}{\spirouLOCOR.sigmaclip\_order\_fit()}{Public}


% ic_max_ptp_fracfwhm
\item \ParameterEntry{Maximum peak-to-peak for sigma-clipping order fit (widths)}
{Defines the maximum peak-to-peak value allowed for an order, if the peak to peak is above this value the width with the highest residual is removed and the fit is recalculated without that width (sigma-clipped). Value must be a positive float.
\vspace{0.5cm}
i.e. width fit is recalculated if: 
\begin{equation}
max(|\text{residuals/data}|)\times100 > \text{ic\_max\_ptp\_fracfwhm}
\end{equation}
}
{ic\_max\_ptp\_fracfwhm}{1.0}
{\callocRAW}{\constantsfile}{\spirouLOCOR.sigmaclip\_order\_fit()}{Public}


% ic_loc_delta_width
\item \ParameterEntry{Delta width 3 convolve shape model}
{Defines the delta width in pixels for the 3 convolve shape model - currently not used. Value must be a positive float.}
{ic\_loc\_delta\_width}{1.85}
{\callocRAW}{\constantsfile}{\callocRAW.\progMAIN, \spirouKeywords}{Public}
\DevNote{This is currently not used (other than saving in the calibDB loco file. Can it be removed?).}


% ic_locopt1
\item \ParameterEntry{Localization archiving option}
{Whether we save the location image with the superposition of the fit (zeros). If this option is 1 or True it will save the file to `\_with-order\_\definevariable{text:fiber_types}{fiber}.fits' if 0 or False it will not save this file. Value must be 1, 0, True or False.}
{ic\_locopt1}{1}
{\callocRAW}{\constantsfile}{\callocRAW.\progMAIN}{Public}


\end{itemize}






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
\clearpage
\newpage
\section{Slit calibration variables}
\label{ch:variables:slit}
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{itemize}

% ic_tilt_coi
\item \ParameterEntry{Tilt oversampling factor}
{Defines the oversampling factor used to work out the tilt of the slit. Value must be an integer value larger than zero.}
{ic\_tilt\_coi}{10}
{\calSLIT}{\constantsfile}{\spirouImage.get\_tilt()}{Public}
\DevNote{Formally this was called `coi' in \calSLIT.}


% ic_facdec
\item \ParameterEntry{Slit fit order plot offset factor}
{Defines an offset of the position fit to show the edges of the illuminated area. (Final offset is $\pm \times$ 2 of this offset away from the order fit. Value must be a positive float.)}
{ic\_facdec}{1.6}
{\calSLIT}{\constantsfile}{\spirouPlot.slit\_sorder\_plot()}{Public}


% ic_tilt_fit
\item \ParameterEntry{Degree of the fitting polynomial for the tilt}
{Defines the degree of the fitting polynomial for determining the tilt i.e. i.e. if value is 1 is a linear fit, if the value is 2 is a quadratic fit.  The value must be a positive integer equal to or greater than zero (zero would lead to a constant fit).}
{ic\_tilt\_fit}{4}
{\calSLIT}{\constantsfile}{\spirouImage.fit\_tilt()}{Public}


% ic_slit_order_plot
\item \ParameterEntry{Selected order in Slit fit order plot}
{Defines the selected order to plot the fit for in the Slit fir order plot. Value must be between zero and the maximum number of orders.}
{ic\_slit\_order\_plot}{10}
{\calSLIT}{\constantsfile}{\spirouPlot.slit\_sorder\_plot()}{Public}


\end{itemize}






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
\clearpage
\newpage
\section{Flat fielding calibration variables}
\label{ch:variables:flatfielding}
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{itemize}

% ic_do_bkgr_subtraction
\item \ParameterEntry{Measure background}
{Define whether to measure the background and do a background subtraction. Value must be True or 1 to do the background measurement and subtraction or be False or 0 to not do the background measurement and subtraction.}
{ic\_do\_bkgr\_subtraction}{0}
{\calFFraw}{\constantsfile}{\calFFraw.\progMAIN}{Public}
\DevNote{Currently even if True or 1 the background is not calculated as the \Program{interpol} function has not been converted to python.}


% ic_bkgr_window
\item \ParameterEntry{Half-size of background window}
{Defines the half-size (in pixels) of the background window to create a sub-frame to find the minimum $2\times$ ic\_bkgr\_window pixels for which to calculate the background from. Size is used in both row and column (y and x) direction. Value must be an integer between zero and the minimum(row number, column number) (minimum(x-axis dimension, y-axis dimension)).}
{ic\_bkgr\_window}{100}
{\calFFraw}{\constantsfile}{\spirouBACK.measure\_background\_flatfield()}{Public}


% ic_tilt_nbo
\item \ParameterEntry{Number of orders in tilt measurement}
{Defines the number of orders in the tilt measurement file (TILT key in the \masterCALIBDBfile). This is the number of tilts that will be extracted. Value must be an integer larger than zero and smaller than or equal to the total number of orders present in the TILT file.}
{ic\_tilt\_nbo}{36}
{\calFFraw}{\constantsfile}{\spirouFITS.read\_tilt\_file()}{Public}
\DevNote{This can probably be removed and replaced with a check to the TILT file - to automatically determine how many orders there should be.}
\DevNote{This was formally called `nbo' and was hard coded in \calFFraw.}


% FF_START_ORDER
\item \ParameterEntry{Flat extraction start order}
{Start order of the extract for the flat finding recipe. If value is "None" uses start order = 0, else must be a positive order number less than the total number of orders.}
{ff\_start\_order}{None}
{\calFFraw}{\constantsfile}{\spirouFLAT.get\_valid\_orders()}{Public}


% FF_END_ORDER
\item \ParameterEntry{Flat extraction end order}
{End order of the extract for the flat finding recipe. If value is "None" uses last order, else must be a positive order number less than the total number of orders.}
{ff\_end\_order}{None}
{\calFFraw}{\constantsfile}{\spirouFLAT.get\_valid\_orders()}{Public}


% ic_ff_sigdet
\item \ParameterEntry{The manually set sigdet for flat fielding.}
{This defines the sigdet to use in the weighted tilt extraction. Set to -1 to use from the input file (`fitsfilename') HEADER. Value must be either -1 or a positive float.}
{ic\_ff\_sigdet}{100.0}
{\calFFraw}{\constantsfile}{\calFFraw.\progMAIN}{Public}


% ic_extfblaz
\item \ParameterEntry{Half size blaze window}
{Defines the distance from the central column that should be used to measure the blaze for each order. Value must be an integer greater than zero and less than half the number of columns (x-axis dimension).}
{ic\_extfblaz}{50}
{\calFFraw}{\constantsfile}{\calFFraw.\progMAIN}{Public}


% ic_blaze_fitn
\item \ParameterEntry{Fit degree for the blaze polynomial fit}
{Defines the degree of the fitting polynomial for fitting the blaze function of each order i.e. if value is 1 is a linear fit, if the value is 2 is a quadratic fit. The value must be a positive integer equal to or greater than zero (zero would lead to a constant fit along the column direction (x-axis direction).}
{ic\_blaze\_fitn}{5}
{\calFFraw}{\constantsfile}{\calFFraw.\progMAIN}{Public}


% ic_ff_order_plot
\item \ParameterEntry{Selected order for flat fielding plot}
{Defines the selected order to plot on the flat fielding image plot. Value must be a integer between zero and the number of orders.}
{ic\_ff\_order\_plot}{5}
{\calFFraw}{\constantsfile}{\spirouPlot.ff\_sorder\_fit\_edges}{Public}
\DevNote{This was formally called `ic\_plot\_order' in \calFFraw.}

% ic_ff_plot_all_orders
\item \ParameterEntry{Plot all order fits for flat fielding plot}
{If True or 1, instead of plotting the selected order from ic\_ff\_order\_plot will plot the order fits (and edges) for all orders. This is slower than just plotting one. Value must be True or 1 or False or 0.}
{ic\_ff\_plot\_all\_orders}{0}
{\calFFraw}{\constantsfile}{\calFFraw.\progMAIN}{Public}
\DevNote{This is a new plot, instead of plotting one selected order plots all orders - this is obviously slightly slower than just plotting one example order.}

% FF_RMS_PLOT_SKIP_ORDERS
\item \namedlabel{text:ff_rms_plot_skip_orders} \ParameterEntry{Flat-field plot skip orders}
{Define the orders not to plot on the RMS flat-field plot. Should be a valid python list of integers (with each value being an integer between 0 and the maximum number of orders)}
{FF\_RMS\_PLOT\_SKIP\_ORDERS}{{\lstinline[style=pythoninline]| [22, 23, 24, 25, 48] |}}
{\calFFraw}{\constantsfile}{\spirouPlot.\path{ff_rms_plot}}{Public}

% IC_FF_EXTRACT_TYPE
\item \namedlabel{text:ic_ff_extract_type} \ParameterEntry{Flat-field extraction type}
{Defines the extraction type for the flat-fielding. Must be one of the following:
\begin{itemize}
	\item "0" - Simple extraction (function = \spirouEXTOR.\path{extract_const_range})
	\item "1" - Wieghted extraction (function = \spirouEXTOR.\path{extract_weight})
	\item "2" - tilt extraction (function = \spirouEXTOR.\path{extract_tilt})
	\item "3a" - tilt weight extraction - old (function = \spirouEXTOR.\path{extract_tilt_weight})
	\item "3b" - tilt weight extraction 2 - old (function = \spirouEXTOR.\path{extract_tilt_weight_old2})
	\item "3c" - tilt weight extraction 2 (function = \spirouEXTOR.\path{extract_tilt_weight2})
	\item "3d" - tilt weight extraction 2 - with cosmic correction (function = \spirouEXTOR.\path{extract_tilt_weight2cosm})
\end{itemize}
}
{IC\_FF\_EXTRACT\_TYPE}{"3c"}
{\calFFraw}{\constantsfile}{\calFFraw.main, \spirouEXTOR.\path{extraction_wrapper}}{Public}

\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
\clearpage
\newpage
\section{Extraction calibration variables}
\label{ch:variables:extraction}
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{itemize}

% ic_extopt
\item \ParameterEntry{Extraction option - rough extraction}
{Extraction option for rough extraction:
\begin{itemize}
\item if 0 extraction by summation over a constant range
\item if 1 extraction by summation over constants sigma (not currently available)
\item if 2 Horne extraction without cosmic elimination (not currently available)
\item if 3 Horne extraction with cosmic elimination (not currently available)
\end{itemize}
 Used for estimating the slit tilt and in calculating the blaze/flat fielding. Value must be a integer between 0 and 3.
}
{ic\_extopt}{0}
{\calSLIT, \calFFraw}{\constantsfile}
{\spirouEXTOR.extract\_AB\_order(), \spirouEXTOR.extract\_order}{Public}


% EXT_START_ORDER
\item \ParameterEntry{Extraction start order}
{Start order of the extract for the extraction. If value is "None" uses start order = 0, else must be a positive order number less than the total number of orders.}
{ff\_start\_order}{None}
{\calextractRAW}{\constantsfile}{\spirouEXTOR.get\_valid\_orders()}{Public}


% EXT_END_ORDER
\item \ParameterEntry{Extraction end order}
{End order of the extract for the extraction. If value is "None" uses last order, else must be a positive order number less than the total number of orders.}
{ff\_end\_order}{None}
{\calextractRAW}{\constantsfile}{\spirouEXTOR.get\_valid\_orders()}{Public}


% ic_extnbsig
\item \ParameterEntry{Extraction distance - rough extraction}
{The pixels are extracted from the centre of the order out to the edges in the row direction (y-axis), i.e. defines the illuminated part of the order). Used for estimating the slit tilt and in calculating the blaze/flat fielding. Value must be a positive float between 0 and the total number of rows (y-axis dimension).}
{ic\_extnbsig}{2.5}
{\calSLIT, \calFFraw}{\constantsfile}{\spirouEXTOR.extract\_AB\_order}{Public}


% ic_extract_type
\item \namedlabel{text:ic_extract_type} \ParameterEntry{Extraction type}
{Defines the extraction type for the \calextractRAW. Must be one of the following:
\begin{itemize}
	\item "0" - Simple extraction (function = \spirouEXTOR.\path{extract_const_range})
	\item "1" - Wieghted extraction (function = \spirouEXTOR.\path{extract_weight})
	\item "2" - tilt extraction (function = \spirouEXTOR.\path{extract_tilt})
	\item "3a" - tilt weight extraction - old (function = \spirouEXTOR.\path{extract_tilt_weight})
	\item "3b" - tilt weight extraction 2 - old (function = \spirouEXTOR.\path{extract_tilt_weight_old2})
	\item "3c" - tilt weight extraction 2 (function = \spirouEXTOR.\path{extract_tilt_weight2})
	\item "3d" - tilt weight extraction 2 - with cosmic correction (function = \spirouEXTOR.\path{extract_tilt_weight2cosm})
\end{itemize}
}
{ic\_extract\_type}{"3d"}
{\calextractRAW}{\constantsfile}{\calextractRAW.\progMAIN}{Public}

% IC_EXT_TILT_BORD
\item \ParameterEntry{Tilt border}
{Set the number of pixels to set as the border (needed to allow for tilt to not go off edge of image). Value must be a positive integer, smaller than half the number of x pixels.}
{ic\_ext\_tilt\_bord}{2}
{\calextractRAW, \calFFraw}{\constantsfile}{\spirouEXTOR.extract\_tilt\_order(), \spirouEXTOR.extract\_tilt\_weight\_order(), \spirouEXTOR.extract\_tilt\_weight\_order2()}{Public}

% ic_ext_sigdet
\item \namedlabel{text:ic_ext_sigdet} \ParameterEntry{Manually set the extraction sigdet}
{Set the sigdet used in the extraction process instead of using the sigdet in the FITS rec HEADER file. If the value is set to -1 the sigdet from the HEADER is used instead.}
{ic\_ext\_sigdet}{100}
{\calextractRAW}{\constantsfile}{\calextractRAW.\progMAIN}{Public}
\DevNote{Why is this value used and not the value in the header file?}

% ic_ext_order_plot
\item \ParameterEntry{Selected order in extract fit order plot}
{Defines the selected order to plot the fit for in the extract fit order plot. Value must be between zero and the maximum number of orders.}
{ic\_ext\_order\_plot}{20}
{\calextractRAW}{\constantsfile}{\spirouPlot.ext\_selected\_order\_plot()}{Public}


% ic_cosmic_sigcut
\item \namedlabel{text:ic_cosmic_sigcut} \ParameterEntry{Cosmic Sig Cut}
{Defines the percentage of (normalized) flux above which we detect as cosmics.}
{IC\_COSMIC\_SIGCUT}{0.25}
{\calFFraw, \calextractRAW}{\constantsfile}{\spirouEXTOR.\path{extraction_wrapper}, \spirouEXTOR.\path{extract_tilt_weight2cosm}}{Public}

% ic_cosmic_thresh
\item \namedlabel{text:ic_cosmic_thresh} \ParameterEntry{Max Cosmic Threshold}
{Defines the maximum number of iterations to check for cosmics (for each pixel).}
{IC\_COSMIC\_THRES}{5}
{\calFFraw, \calextractRAW}{\constantsfile}{\spirouEXTOR.\path{extraction_wrapper}, \spirouEXTOR.\path{extract_tilt_weight2cosm}}{Public}

\end{itemize}







%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
\clearpage
\newpage
\section{Drift calibration variables}
\label{ch:variables:drift}
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{itemize}


% ic_drift_noise
\item \ParameterEntry{Noise value for SNR drift calculation}
{Define the noise value for the signal to noise ratio in the drift calculation.
\begin{equation}
snr = flux/\sqrt(\text{flux} + \text{noise}^2)
\end{equation}
Value must be a float larger than zero.
}
{ic\_drift\_noise}{100.0}
{\calDRIFTRAW}{\constantsfile}{\calDRIFTRAW.\progMAIN}{Public}


% ic_drift_back_corr
\item \namedlabel{text:ic_drift_back_corr} \ParameterEntry{Do background correction}
{Defines whether the background correction is done.}
{IC\_DRIFT\_BACK\_CORR}{1}
{\calDRIFTE, \calDRIFTPEAK}{\constantsfile}{\calDRIFTE.\progMAIN, \calDRIFTPEAK.\progMAIN}{Public}


% ic_drift_maxflux
\item \ParameterEntry{The maximum flux for a good (unsaturated) pixel}
{Defines the maximum flux to define a good pixel. This pixels and those that surround it will not be used in determining the RV parameters. Value must be a float greater than zero.}
{ic\_drift\_maxflux}{1.e9}
{\calDRIFTRAW}{\constantsfile}{\calDRIFTRAW.\progMAIN}{Public}


% ic_drift_boxsize
\item \ParameterEntry{Saturated pixel flag size}
{Defines the number of pixels around a saturated pixel to flag as unusable (and hence not used in determining the RV parameters). Value must be a integer larger than zero.}
{ic\_drift\_boxsize}{12}
{\calDRIFTRAW}{\constantsfile}{\calDRIFTRAW.\progMAIN}{Public}


% drift_nlarge
\item \ParameterEntry{Large number of files for skip}
{Defines the number of files that is large enough to require the `drift\_file\_skip' parameter (only uses one file in every `drift\_file\_skip' files). This is done to speed up the code and avoid a bug. Value must be an integer larger than zero.}
{drift\_nlarge}{300}
{\calDRIFTRAW, \calDRIFTE, \calDRIFTPEAK}{\constantsfile}{\calDRIFTRAW.\progMAIN, \calDRIFTE.\progMAIN, \calDRIFTPEAK.\progMAIN}{Public}
\DevNote{Has this bug been fixed, do we need to skip for a large number of files?}


% drift_file_skip
\item \ParameterEntry{Large number of files skip parameter (\calDRIFTRAW)}
{Defines how many files we skip. This is done by selecting one file every `drift\_file\_skip' files. i.e. if skip is 3 the code uses every 3rd file to calculate the drift. Value must be an integer larger than zero. A value of 1 is equivalent to no skipping of files regardless of the file number.}
{drift\_file\_skip}{3}
{\calDRIFTRAW}{\constantsfile}{\calDRIFTRAW.\progMAIN}{Public}


% drift_e2ds_file_skip
\item \ParameterEntry{Large number of files skip parameter (\calDRIFTE)}
{Defines how many files we skip. This is done by selecting one file every `drift\_file\_skip' files. i.e. if skip is 3 the code uses every 3rd file to calculate the drift. Value must be an integer larger than zero. A value of 1 is equivalent to no skipping of files regardless of the file number.}
{drift\_e2ds\_file\_skip}{1}
{\calDRIFTE}{\constantsfile}{\calDRIFTE.\progMAIN}{Public}


% ic_drift_cut_raw
\item \ParameterEntry{Number of sigmas to cut in cosmic re-normalization (\calDRIFTRAW)}
{Defines the number of standard deviations to remove fluxes at (and replace with the reference flux) for \calDRIFTRAW. Value must be a float larger than zero.}
{ic\_drift\_cut\_raw}{3}
{\calDRIFTRAW}{\constantsfile}{\calDRIFTRAW.\progMAIN}{Public}


% ic_drift_cut_e2ds
\item \ParameterEntry{Number of sigmas to cut in cosmic re-normalization (\calDRIFTE)}
{Defines the number of standard deviations to remove fluxes at (and replace with the reference flux) for \calDRIFTE. Value must be a float larger than zero.}
{ic\_drift\_cut\_e2ds}{4.5}
{\calDRIFTE}{\constantsfile}{\calDRIFTE.\progMAIN}{Public}


% ic_drift_n_order_max
\item \ParameterEntry{Number of orders to use in drift}
{Defines the number of orders to use (starting from zero to maximum number). This is used to get the median drift. Value must be an integer between 0 and the maximum number of orders.}
{ic\_drift\_n\_order\_max}{28}
{\calDRIFTRAW}{\constantsfile}{\calDRIFTRAW.\progMAIN}{Public}


% drift_type_raw
\item \ParameterEntry{Define the way to combine orders for drift (for \calDRIFTRAW)}
{Defines the way to calculate the combine order drifts (to one drift per image) should either be 'weighted mean' (Equation \ref{equation:drift_type_wmean_1}) or 'median' (Equation \ref{equation:drift_type_median_1}) for \calDRIFTRAW.
\begin{equation}
\namedlabel{equation:drift_type_wmean_1}
\text{drift} = \frac{\sum{(\text{drift}_i * w_i)}}{\sum{w_i}}
\end{equation}
\noindent where $w_i$ is $1/\Delta v_{rms}$
\begin{equation}
\namedlabel{equation:drift_type_median_1}
\text{drift} = \text{median}(\text{drift}_i)
\end{equation}
\noindent Value should be a valid python string either `median' or `weighted mean'.
}
{drift\_type\_raw}{median}
{\calDRIFTRAW}{\constantsfile}{\calDRIFTRAW.\progMAIN}{Public}


% drift_type_e2ds
\item \ParameterEntry{Define the way to combine orders for drift \calDRIFTE)}
{Defines the way to calculate the combine order drifts (to one drift per image) should either be 'weighted mean' (Equation \ref{equation:drift_type_wmean_2}) or 'median' (Equation \ref{equation:drift_type_median_2}) for \calDRIFTE.
\begin{equation}
\namedlabel{equation:drift_type_wmean_2}
\text{drift} = \frac{\sum{(\text{drift}_i * w_i)}}{\sum{w_i}}
\end{equation}
\noindent where $w_i$ is $1/\Delta v_{rms}$
\begin{equation}
\namedlabel{equation:drift_type_median_2}
\text{drift} = \text{median}(\text{drift}_i)
\end{equation}
\noindent Value should be a valid python string either `median' or `weighted mean'.
}
{drift\_type\_e2ds}{weighted mean}
{\calDRIFTE}{\constantsfile}{\calDRIFTE.\progMAIN}{Public}

% ic_drift_order_plot
\item \ParameterEntry{Selected order in drift fit order plot}
{Defines the selected order to plot the fit for in the drift fit order plot. Value must be between zero and the maximum number of orders.}
{ic\_drift\_order\_plot}{20}
{\calDRIFTRAW, \calDRIFTE}{\constantsfile}{\spirouPlot. drift\_plot\_selected\_wave\_ref()}{Public}

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
\clearpage
\newpage
\section{Drift-Peak calibration variables}
\label{ch:variables:driftpeak}
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{itemize}

% ic_drift_peak_n_order_min
\item \namedlabel{text:ic_drift_peak_n_order_min} \ParameterEntry{First order to use in drift-peak}
{Defines the first order to use (from this to \definevariable{text:ic_drift_peak_n_order_max}{ic\_drift\_peak\_n\_order\_max}). This is used to get the median drift. Value must be an integer greater than or equal to 0 and less than \definevariable{text:ic_drift_peak_n_order_max}{ic\_drift\_peak\_n\_order\_max}.}
{ic\_drift\_peak\_n\_order\_min}{2}
{\calDRIFTPEAK}{\constantsfile}{\calDRIFTPEAK.\progMAIN}{Public}

% ic_drift_peak_n_order_max
\item \namedlabel{text:ic_drift_peak_n_order_max} \ParameterEntry{Last order to use in drift-peak}
{Defines the last order to use (from \definevariable{text:ic_drift_peak_n_order_min}{ic\_drift\_peak\_n\_order\_min} to this). This is used to get the median drift. Value must be an integer greater than \definevariable{text:ic_drift_peak_n_order_min}{ic\_drift\_peak\_n\_order\_min} and less than or equal to the maximum number of orders.}
{ic\_drift\_peak\_n\_order\_max}{30}
{\calDRIFTPEAK}{\constantsfile}{\calDRIFTPEAK.\progMAIN}{Public}

% drift_peak_file_skip
\item \ParameterEntry{Large number of files skip parameter (\calDRIFTE)}
{Defines how many files we skip. This is done by selecting one file every `drift\_file\_skip' files. i.e. if skip is 3 the code uses every 3rd file to calculate the drift. Value must be an integer larger than zero. A value of 1 is equivalent to no skipping of files regardless of the file number.}
{drift\_e2ds\_file\_skip}{1}
{\calDRIFTPEAK}{\constantsfile}{\calDRIFTPEAK.\progMAIN}{Public}

% drift_peak_minmax_boxsize
\item \ParameterEntry{Minimum box size for min max smoothing}
{Defines the minimum size of the box used to get the minimum and maximum pixel values (specifically minimum pixel values). Each box (defined as the pixel position $\pm$box size) is used to work out the background value for that pixel. Value must be an integer larger than zero and less than half the number of columns (x-dimension).}
{drift\_peak\_minmax\_boxsize}{6}
{\calDRIFTPEAK}{\constantsfile}{\calDRIFTPEAK.\progMAIN}{Public}

% drift_peak_border_size
\item \namedlabel{text:drift_peak_border_size} \ParameterEntry{Image column (x-dim) border size}
{Defines the number of pixels on either side of an image that should not be used to find FP peaks. This size must be larger to or equal to \definevariable{text:drift_peak_fpbox_size}{drift\_peak\_fpbox\_size}, therefore the fit to an individual FP does not go off the edge of the image. Value must be an integer larger to or equal to \definevariable{text:drift_peak_fpbox_size}{drift\_peak\_fpbox\_size} and less than and less than half the number of columns (x-dimension).}
{drift\_peak\_border\_size}{3}
{\calDRIFTPEAK}{\constantsfile}{\spirouRV.create\_drift\_file()}{Public}

% drift_peak_fpbox_size
\item \namedlabel{text:drift_peak_fpbox_size} \ParameterEntry{Box size for fitting individual FP peak.}
{Defines the half-box size (i.e. central position $\pm$box size) of the box used to fit an individual FP peak. This size must be large enough to fit a peak but not too large as to encompass multiple FP peaks. The value must be an integer larger than zero and smaller than or equal to \definevariable{text:drift_peak_border_size}{drift\_peak\_border\_size} (to avoid fitting off the edges of the image).}
{drift\_peak\_fpbox\_size}{3}
{\calDRIFTPEAK}{\constantsfile}{\spirouRV.create\_drift\_file(), \spirouRV.get\_drift()}{Public}

% drift_peak_min_nfp_peak
% \item \ParameterEntry{Minimum normalized flux for valid FP peak}
% {Defines the minimum normalized flux a valid FP peak must have in order to be recognized as an FP peak (before the peak fitting is done). At this point the FP peak is normalised so the maximum is around a value of 1.0. If a peaks maximum is below this threshold it will not be used as a valid FP in finding the drifts. Value must be a float larger than zero and less than 1.0}
% {drift\_peak\_min\_nfp\_peak}{0.25}
% {\calDRIFTPEAK}{\constantsfile}{\spirouRV.create\_drift\_file()}{Public}


% drift_peak_peak_sig_lim
\item \ParameterEntry{Minimum sigma above median for valid peak}
{Defines the flux a valid peak must have in order to be recognized as a valid peak (before the peak fitting is done). If a peaks maximum is below this threshold it will not be used as a valid peak in finding the drifts. Value is a dictionary containing keys equivalent to the lamp types (currently this is 'fp' and 'hc'. The values of each must be a float greater than 1 for above the median and, between zero and 1 for below the median).}
{drift\_peak\_peak\_sig\_lim}
{\lstinline[style=pythoninline]| {'fp':1.0, 'hc':7.0} |}
{\calDRIFTPEAK}{\constantsfile}{\spirouRV.create\_drift\_file()}{Public}


% drift_peak_inter_peak_spacing
\item \ParameterEntry{Minimum spacing between valid peaks}
{Defines the minimum spacing peaks must have (between neighbouring peaks) in order to recognized as valid peaks (before the peak fitting is done). If peak is closer than this separation to a previous peak the peak will not be used as a valid peak in finding the drifts. Value must be an integer greater than zero.}
{drift\_peak\_inter\_peak\_spacing}{5}
{\calDRIFTPEAK}{\constantsfile}{\spirouRV.create\_drift\_file()}{Public}


% drift_peak_exp_width
\item \namedlabel{text:drift_peak_exp_width} \ParameterEntry{Expected width of FP peaks}
{Defines the expected width of the FP peaks. Parameter is used to `normalise' the peaks which are then subsequently removed if:
\begin{equation}
\text{normalized FP FWHM} > \text{drift\_peak\_norm\_width\_cut}
\end{equation}
this is equivalent to:
\begin{equation}
\text{FP FWHM} > (\text{drift\_peak\_exp\_width} + \text{drift\_peak\_norm\_width\_cut})
\end{equation}
Value must be a float larger than zero and less than the number of columns (x-dimension).
}
{drift\_peak\_exp\_width}{0.8}
{\calDRIFTPEAK}{\constantsfile}{\spirouRV.remove\_wide\_peaks(), \spirouRV.get\_drift()}{Public}

% drift_peak_norm_width_cut
\item \ParameterEntry{Normalized FP width threshold}
{Defines the maximum `normalized' width of FP peaks that is acceptable for a valid FP peak. i.e. widths above this threshold are rejected as valid FP peaks.
This works as follows:
\begin{equation}
\text{normalized FP FWHM} > \text{drift\_peak\_norm\_width\_cut}
\end{equation}
this is equivalent to:
\begin{equation}
\text{FP FWHM} > (\text{drift\_peak\_exp\_width} + \text{drift\_peak\_norm\_width\_cut})
\end{equation}
Value must be a float larger than zero and less than the number of columns (x-dimension) but if \definevariable{text:drift_peak_exp_width}{drift\_peak\_exp\_width} is defined sensibly then this number should be small.
}
{drift\_peak\_norm\_width\_cut}{0.2}
{\calDRIFTPEAK}{\constantsfile}{\spirouRV.remove\_wide\_peaks()}{Public}

% drift_peak_getdrift_gaussfit
\item \ParameterEntry{Get drift via a Gaussian fitting process}
{Defines whether the drift is calculated via a Gaussian fitting process (fitting the targeted order with a Gaussian) -- $\sim\times$10 slower, or adjusts a barycentre to get the drift. Value must be True or 1 to do the Gaussian fit, or False or 0 to use the barycentre adjustment.}
{drift\_peak\_getdrift\_gaussfit}{False}
{\calDRIFTPEAK}{\constantsfile}{\calDRIFTPEAK.\progMAIN}{Public}

% drift_peak_pearsonr_cut
\item \ParameterEntry{Pearson R coefficient (between reference and image)}
{Defines the threshold below which a image is deemed to dissimilar from the reference image to be used. A Pearson R test is performed between the reference image (E2DS file) and the current iteration image (E2DS file), the minimum of all usable orders is then tested. If any order does not pass the criteria:
\begin{equation}
\text{coefficient}_{\text{order}} > \text{drift\_peak\_pearsonr\_cut}
\end{equation}
then the whole image (E2DS file) is rejected. Value must be a float larger than zero and less than 1.0, values should be close to unity for a good fit i.e. 0.97.
}
{drift\_peak\_pearsonr\_cut}{0.9}
{\calDRIFTPEAK}{\constantsfile}{\calDRIFTPEAK.\progMAIN}{Public}
\DevNote{This value is currently set below a recommended level and should be set back to 0.97 as soon as possible, even coefficients at 0.95 are from very bad orders, and orders should be removed. A plot currently is made when a bad file is found (i.e. when the above cut is not met).}

% drift_peak_sigmaclip
\item \ParameterEntry{Sigma clip for found FP peaks}
{Defines the number of sigmas above the median that is used to remove bad FP peaks from the drift calculation process. Value must be a float larger than zero.}
{drift\_peak\_sigmaclip}{1.0}
{\calDRIFTPEAK}{\constantsfile}{\calDRIFTPEAK.\progMAIN}{Public}


% drift_peak_plot_line_log_amp
\item \ParameterEntry{Plot linelist vs log Amplitude}
{Defines whether we plot the line list against log amplitude. Value must be 1 or True to plot, or 0 or False to not plot}
{drift\_peak\_plot\_line\_log\_amp}{False}
{\calDRIFTPEAK}{\constantsfile}{\spirouPlot.drift\_peak\_plot{\hskip 0pt}\_llpeak\_amps()}{Public}

% drift_peak_selected_order
\item \ParameterEntry{Selected order for line-list vs log Amplitude plot}
{Defines the selected order to plot the wave vs extracted spectrum for over-plotting on the line list against log amplitude plot. Value must be an integer between 0 and the number of orders}
{drift\_peak\_selected\_order}{30}
{\calDRIFTPEAK}{\constantsfile}{\spirouPlot.drift\_peak\_plot{\hskip 0pt}\_llpeak\_amps()}{Public}



\end{itemize}





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
\clearpage
\newpage
\section{Bad pixel calibration variables}
\label{ch:variables:badpix}
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{itemize}

	% badpix_flat_med_wid
	\item \namedlabel{text:badpix_flat_med_wid} \ParameterEntry{Bad pixel median image box width}
	{A similar flat is produced by taking the running median of the flat in the column direction (x-dimension) over a boxcar width of \definevariable{text:badpix_flat_med_wid}{badpix\_flat\_med\_wid}. This assumes that the flux level varies only by a small amount over \definevariable{text:badpix_flat_med_wid}{badpix\_flat\_med\_wid} pixels and that the bad pixels are isolated enough that the median along that box will be representative of the flux they should have if they were not bad. Value should be an integer larger than zero and less than the number of columns (x-axis dimension).}
	{badpix\_flat\_med\_wid}{7}
	{\calbadpix}{\constantsfile}{\spirouImage.normalise\_median\_flat(), \spirouImage.locate\_bad\_pixels()}{Public}
	\DevNote{Formally this was called wmed in \calbadpix}

	% badpix_illum_cut
	\item \ParameterEntry{Bad pixel illumination cut parameter}
	{Threshold below which a pixel is considered unilluminated. As we cut the pixels that fractionally deviate by more than a certain amount (\definevariable{text:badpix_flat_cut_ratio}{badpix\_flat\_cut\_ratio}) this would lead to lots of bad pixels in unilluminated regions of the array. This parameter stops this, as the pixels are normalised this value must be a float greater than zero and less than 1.}
	{badpix\_illum\_cut}{0.05}
	{\calbadpix}{\constantsfile}{\spirouImage.locate\_bad\_pixels()}{Public}
	\DevNote{Formally this was called illum\_cut in \calbadpix}

	% badpix_flat_cut_ratio
	\item \namedlabel{text:badpix_flat_cut_ratio} \ParameterEntry{Bad pixel maximum differential pixel cut ratio}{This sets the maximum differential pixel response relative to the expected value. Value must be a float larger than zero.}
	{badpix\_flat\_cut\_ratio}{0.5}
	{\calbadpix}{\constantsfile}{\spirouImage.locate\_bad\_pixels()}{Public}
	\DevNote{Formally this was called cut\_ratio in \calbadpix}

	% badpix_max_hotpix
	\item \ParameterEntry{Bad pixel maximum flux to considered too hot}
	{Defines the maximum flux value to be considered too hot to user.}
	{badpix\_max\_hotpix}{100.0}
	{\calbadpix}{\constantsfile}{\spirouImage.locate\_bad\_pixels()}{Public}
	\DevNote{Formally this was called max\_hotpix in \calbadpix}

	% badpix_norm_percentile
	\item \ParameterEntry{Bad pixel normalisation percentile}
	{Defines the percentile at which the bad pixels are normalised to in order to locate bad and dead pixels.}
	{badpix\_norm\_percentile}{90.0}
	{\calbadpix}{\constantsfile}{\spirouImage.locate\_bad\_pixels()}{Public}


	% badpix_full_flat
	\item \ParameterEntry{Full detector flat file}
	{Defines the full detector flat file (located in the data folder)}
	{badpix\_full\_flat}{`detector\_flat\_full.fits'}
	{\calbadpix}{\constantsfile}{\spirouImage.locate\_bad\_pixels\_full()}{Public}

	% badpix_full_threshold
	\item \ParameterEntry{Full detector good threshold}
	{Defines the threshold on the full detector flat file to deem pixels as good}
	{badpix\_full\_threshold}{0.3}
	{\calbadpix}{\constantsfile}{\spirouImage.locate\_bad\_pixels\_full()}{Public}

\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
\clearpage
\newpage
\section{Wavelength solution variables}
\label{ch:variables:wave}
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{itemize}

% IC_LAMPS
\item \namedlabel{text:ic_lamps} \ParameterEntry{Lamp types}
{Define the lamp types. These must be present in \definevariable{text:ic_ll_line_file_all}{IC\_LL\_LINE\_FILE\_ALL} and \definevariable{text:ic_cat_type_all}{IC\_CAT\_TYPE\_ALL} to be used. Each dictionary entry must be a list of strings (to look for in the header).}
{IC\_LAMPS}{\lstinline[style=pythoninline]| dict(UNe=['hcone', 'hc1'], TH=['hctwo', 'hc2']) |}
{\calHC, \calWAVE}{\constantsfile}{\spirouTHORCA.\path{decide_on_lamp_type}}{Public}

% IC_LL_LINE_FILE_ALL
\item \namedlabel{text:ic_ll_line_file_all} \ParameterEntry{Catalogue line list files}
{Define the lamp types. These must be present in \definevariable{text:ic_lamps}{IC\_LAMPS} and \definevariable{text:ic_cat_type_all}{IC\_CAT\_TYPE\_ALL} to be used.}
{IC\_LL\_LINE\_FILE\_ALL}{\lstinline[style=pythoninline]| dict(UNe='catalogue_UNe.dat', TH='catalogue_ThAr.dat') |}
{\calHC, \calWAVE}{\constantsfile}{\spirouTHORCA.\path{get_lamp_parameters}}{Public}

% IC_CAT_TYPE_ALL
\item \namedlabel{text:ic_cat_type_all} \ParameterEntry{Type of line list catalogue}
{Define the lamp types. These must be present in \definevariable{text:ic_lamps}{IC\_LAMPS} and \definevariable{text:ic_ll_line_file_all}{IC\_LL\_LINE\_FILE\_ALL} to be used.}
{IC\_CAT\_TYPE\_ALL}{\lstinline[style=pythoninline]| dict(UNe='fullcat', TH='thcat') |}
{\calHC, \calWAVE}{\constantsfile}{\spirouTHORCA.\path{get_lamp_parameters}}{Public}

% IC_RESOL
\item \namedlabel{text:ic_resol} \ParameterEntry{Resolution of the detector}
{Define the resolution of the detector}
{IC\_RESOL}{65000}
{\calHC, \calWAVE}{\constantsfile}{\spirouTHORCA.\path{find_lines}}{Public}

% IC_LL_FREE_SPAN
\item \namedlabel{text:ic_ll_free_span} \ParameterEntry{Wavelength free-span}
{Define the wavelength free span parameter in find lines. Must be a list of line widths (in pixels). Ordered from largest to smallest.}
{IC\_LL\_FREE\_SPAN}{\lstinline[style=pythoninline]| [6.0, 3.5] |}
{\calHC, \calWAVE}{\constantsfile}{\spirouTHORCA.\path{first_guess_at_wave_solution}, \spirouTHORCA.\path{find_lines}}{Public}

% IC_LL_SP_MIN
\item \namedlabel{text:ic_ll_sp_min} \ParameterEntry{Minimum wavelength - find lines}
{Define the minimum wavelength of the detector to use in find lines (in nm).}
{IC\_LL\_SP\_MIN}{900}
{\calHC, \calWAVE}{\constantsfile}{\spirouTHORCA.\path{find_lines}}{Public}

% IC_LL_SP_MAX
\item \namedlabel{text:ic_ll_sp_max} \ParameterEntry{Maximum wavelength - find lines}
{Define the maximum wavelength of the detector to use in find lines (in nm).}
{IC\_LL\_SP\_MAX}{2400}
{\calHC, \calWAVE}{\constantsfile}{\spirouTHORCA.\path{find_lines}}{Public}

% IC_HC_NOISE
\item \namedlabel{text:ic_hc_noise} \ParameterEntry{Readout noise - find lines}
{Define the read out noise to use in find lines}
{IC\_HC\_NOISE}{60}
{\calHC, \calWAVE}{\constantsfile}{\spirouTHORCA.\path{find_lines}}{Public}

% IC_MAX_SIGLL_CAL_LINES
\item \namedlabel{text:ic_max_sigll_cal_lines} \ParameterEntry{Maximum sig-fit of guess lines}
{Define the maximum sigma fit of the guessed lines (FWHM/2.35 of the lines). Used to filter out bad lines after a guess on the lines.}
{IC\_MAX\_SIGLL\_CAL\_LINES}{4}
{\calHC, \calWAVE}{\constantsfile}{\spirouTHORCA.\path{detect_bad_lines}}{Public}

% IC_MAX_ERRW_ONFIT
\item \namedlabel{text:ic_max_errw_onfit} \ParameterEntry{Maximum error on guess lines}
{Define the maximum error on the guess of the lines. Used to filter out bad lines after a guess on the lines.}
{IC\_MAX\_ERRW\_ONFIT}{1}
{\calHC, \calWAVE}{\constantsfile}{\spirouTHORCA.\path{detect_bad_lines}}{Public}

% IC_MAX_AMPL_LINE
\item \namedlabel{text:ic_max_ampl_line} \ParameterEntry{Maximum amplitude on guess lines}
{Define the maximum amplitude on the guess of the lines. Used to filter out bad lines after a guess on the lines.}
{IC\_MAX\_AMPL\_LINE}{1.0e8}
{\calHC, \calWAVE}{\constantsfile}{\spirouTHORCA.\path{detect_bad_lines}}{Public}

% IC_HC_N_ORD_START
\item \namedlabel{text:ic_hc_n_ord_start} \ParameterEntry{Wave solution first order}
{Defines the first order to at which the wave solution is calculated.}
{IC\_HC\_N\_ORD\_START}{13}
{\calHC, \calWAVE}{\constantsfile}{\spirouTHORCA.\path{first_guess_at_wave_solution}, \spirouTHORCA.\path{calculate_littrow_sol}}{Public}

% IC_HC_N_ORD_FINAL
\item \namedlabel{text:ic_hc_n_ord_final} \ParameterEntry{Wave solution last order}
{Defines the last order to at which the wave solution is calculated.}
{IC\_HC\_N\_ORD\_START}{40}
{\calHC, \calWAVE}{\constantsfile}{\spirouTHORCA.\path{first_guess_at_wave_solution}, \spirouTHORCA.\path{calculate_littrow_sol}, \spirouWAVE.\path{calculate_instrument_drift}}{Public}

% IC_HC_T_ORDER_START
\item \namedlabel{text:ic_hc_t_order_start} \ParameterEntry{First echelle order number}
{Defines the first echelle order number extracted.}
{IC\_HC\_T\_ORDER\_START}{79}
{\calHC, \calWAVE}{\constantsfile}{\spirouTHORCA.\path{first_guess_at_wave_solution}, \spirouTHORCA.\path{detect_bad_lines}, \spirouTHORCA.\path{extrapolate_littrow_sol}, \spirouTHORCA.\path{second_guess_at_wave_solution}, \spirouTHORCA.\path{find_lines}, \spirouTHORCA.\path{fit_1d_ll_solution}}{Public}

% IC_ERRX_MIN
\item \namedlabel{text:ic_errx_min} \ParameterEntry{Minimum x error in 1D fit}
{Define the maximum weight given to a line via defining the minimum instrumental error, such that:
\begin{equation}
\text{max\_weight} = 1.0 / (\text{IC\_ERRX\_MIN})^2
\end{equation}
}
{IC\_ERRX\_MIN}{0.01}
{\calHC, \calWAVE}{\constantsfile}{\spirouTHORCA.\path{fit_1d_ll_solution}}{Public}

% IC_LL_DEGR_FIT
\item \namedlabel{text:ic_ll_degr_fit} \ParameterEntry{Wavelength solution poly-fit degree}
{Define the wavelength fit polynomial order}
{IC\_LL\_DEGR\_FIT}{4}
{\calHC, \calWAVE}{\constantsfile}{\spirouTHORCA.\path{fit_1d_ll_solution}, \spirouTHORCA.\path{invert_1ds_ll_solution}}{Public}

% IC_MAX_LLFIT_RMS
\item \namedlabel{text:ic_max_llfit_rms} \ParameterEntry{Maximum RMS for wave solution sigma-clip fit}
{Define the maximum RMS for the wavelength sigma-clip fitting process}
{IC\_MAX\_LLFIT\_RMS}{3.0}
{\calHC, \calWAVE}{\constantsfile}{\spirouTHORCA.\path{fit_1d_ll_solution}}{Public}

% IC_LITTROW_FIT_DEG_1
\item \namedlabel{text:ic_littrow_fit_deg_1} \ParameterEntry{Littrow poly-fit degree 1}
{Define the polynomial fit degree for the Littrow fit (iteration 1)}
{IC\_LITTROW\_FIT\_DEG\_1}{5}
{\calHC, \calWAVE}{\constantsfile}{\spirouTHORCA.\path{calculate_littrow_sol} with iteration=1}{Public}

% IC_LITTROW_FIT_DEG_2
\item \namedlabel{text:ic_littrow_fit_deg_2} \ParameterEntry{Littrow poly-fit degree 2}
{Define the polynomial fit degree for the Littrow fit (iteration 2)}
{IC\_LITTROW\_FIT\_DEG\_2}{7}
{\calHC, \calWAVE}{\constantsfile}{\spirouTHORCA.\path{calculate_littrow_sol} with iteration=2}{Public}

% IC_LITTROW_CUT_STEP_1
\item \namedlabel{text:ic_littrow_cut_step_1} \ParameterEntry{Littrow cut steps}
{Define the x-pixel interval between positions to measure the Littrow at (iteration 1)
i.e.:
\begin{equation}
xcutpoints = [1 * step, 2 * step, 3 * step, ..., (N-1) * step]
\end{equation}
where `step' = IC\_LITTROW\_CUT\_STEP\_1 and `N' = length of x-dimension divided by `step'.}
{IC\_LITTROW\_CUT\_STEP\_1}{250}
{\calHC, \calWAVE}{\constantsfile}{\spirouTHORCA.\path{calculate_littrow_sol} with iteration=1}{Public}

% IC_LITTROW_CUT_STEP_2
\item \namedlabel{text:ic_littrow_cut_step_2} \ParameterEntry{Littrow cut steps}
{Define the x-pixel interval between positions to measure the Littrow at (iteration 2)
i.e.:
\begin{equation}
xcutpoints = [1 * step, 2 * step, 3 * step, ..., (N-1) * step]
\end{equation}
where `step' = IC\_LITTROW\_CUT\_STEP\_2 and `N' = length of x-dimension divided by `step'.}
{IC\_LITTROW\_CUT\_STEP\_2}{500}
{\calHC, \calWAVE}{\constantsfile}{\spirouTHORCA.\path{calculate_littrow_sol} with iteration=2}{Public}

% IC_LITTROW_ORDER_INIT
\item \namedlabel{text:ic_littrow_order_init} \ParameterEntry{Littrow fit - first order}
{Defines the first order to start the LIttrow fit from}
{IC\_LITTROW\_ORDER\_INIT}{0}
{\calHC, \calWAVE}{\constantsfile}{\spirouTHORCA.\path{calculate_littrow_sol}, \spirouTHORCA.\path{extrapolate_littrow_sol}}{Public}

% IC_LITTROW_REMOVE_ORDERS
\item \namedlabel{text:ic_littrow_remove_orders} \ParameterEntry{Littrow fit - remove orders}
{Define the orders to ignore to ignore in the Littrow fit. Must be a valid python list of integers where each integer is a number between zero and the maximum number of orders.}
{IC\_LITTROW\_REMOVE\_ORDERS}{\lstinline[style=pythoninline]| [] |}
{\calHC, \calWAVE}{\constantsfile}{\spirouTHORCA.\path{calculate_littrow_sol}}{Public}

% IC_LITTROW_ORDER_FIT_DEG
\item \namedlabel{text:ic_ll_degr_fit} \ParameterEntry{Littrow-Wavelength solution poly-fit degree}
{Define the wavelength fit polynomial order}
{IC\_LITTROW\_ORDER\_FIT\_DEG}{4}
{\calHC, \calWAVE}{\constantsfile}{\spirouTHORCA.\path{extrapolate_littrow_sol}}{Public}
\DevNote{Same as IC\_LL\_DEGR\_FIT?}

% IC_LL_FREE_SPAN_2
\item \namedlabel{text:ic_ll_free_span_2} \ParameterEntry{Wavelength free-span 2}
{Define the wavelength free span parameter in find lines used after Littrow fit. Must be a list of line widths (in pixels). Ordered from largest to smallest.}
{IC\_LL\_FREE\_SPAN\_2}{\lstinline[style=pythoninline]| [4.25, 3.0] |}
{\calHC, \calWAVE}{\constantsfile}{\spirouTHORCA.\path{second_guess_at_wave_solution}, \spirouTHORCA.\path{find_lines}}{Public}

% IC_HC_N_ORD_START_2
\item \namedlabel{text:ic_hc_n_ord_start_2} \ParameterEntry{Wave solution first order 2}
{Defines the first order to at which the wave solution is calculated used after Littrow fit.}
{IC\_HC\_N\_ORD\_START\_2}{0}
{\calHC, \calWAVE}{\constantsfile}{\spirouTHORCA.\path{second_guess_at_wave_solution}, \spirouTHORCA.\path{join_orders}, \spirouWAVE.\path{insert_fp_lines}}{Public}

% IC_HC_N_ORD_FINAL_2
\item \namedlabel{text:ic_hc_n_ord_final_2} \ParameterEntry{Wave solution last order 2}
{Defines the last order to at which the wave solution is calculated used after Littrow fit.}
{IC\_HC\_N\_ORD\_START\_2}{46}
{\calHC, \calWAVE}{\constantsfile}{\spirouTHORCA.\path{second_guess_at_wave_solution}, \spirouTHORCA.\path{join_orders}, \spirouWAVE.\path{insert_fp_lines}}{Public}

% HC_FIND_LINES_MODE
\item \namedlabel{text:hc_find_lines_mode} 
\begin{minipage}[t]{\textwidth}\ParameterEntry{Find lines mode}
{Defines the mode to find lines. Currently allowed modes are:
\begin{itemize}
	\item 0: Fortran \path{fitgaus.f} routine
	\item 1: Python fit using \path{scipy.optimize.curve_fit}
	\item 2: Python fit using \path{lmfit.models} (Model, GaussianModel)
	\item 3: Python conversion of Fortran `fitgaus' - direct translation
	\item 4: Python conversion of Fortran `fitgaus' - gaussj improvement MH
	\item 5: Python conversion of Fortran `fitgaus' - gaussj improvement NJC
\end{itemize}
where value must be an integer between 0 and 5.
}
{HC\_FIND\_LINES\_MODE}{0}
{\calHC, \calWAVE}{\constantsfile}{\calHC.\progMAIN, \calWAVE.\progMAIN, but used in \spirouTHORCA.\path{fitgaus_wrapper} via \spirouTHORCA.\path{fit_emi_line} via \spirouTHORCA.\path{find_lines}}{Public}

\ifdevguide
\begin{note}
If mode = 0 fitgaus.f needs to be compiled with:
\begin{cmdbox}
f2py -c -m fitgaus --noopt --quiet fitgaus.f
\end{cmdbox}
While located in the \path{.../INTROOT/SpirouDRS/fortan} directory.
\end{note}

\begin{note}
If mode = 2 lmfit must be installed with
\begin{cmdbox}
pip install lmfit
\end{cmdbox}
\end{note}
\fi
\end{minipage}


% IC_FP_N_ORD_START
\item \namedlabel{text:ic_fp_n_ord_start} \ParameterEntry{FP solution - first order}
{Defines the first order to start the FP solution fitting at.}
{IC\_FP\_N\_ORD\_START}{0}
{\calWAVE}{\constantsfile}{\spirouWAVE.\path{fp_wavelength_sol}, \spirouWAVE.\path{insert_fp_lines}}{Public}

% IC_FP_N_ORD_FINAL
\item \namedlabel{text:ic_fp_n_ord_final} \ParameterEntry{FP solution - last order}
{Defines the last order to stop the FP solution fitting at.}
{IC\_FP\_N\_ORD\_FINAL}{24}
{\calWAVE}{\constantsfile}{\spirouWAVE.\path{fp_wavelength_sol}, \spirouWAVE.\path{insert_fp_lines}, \spirouPlot.\path{wave_plot_final_fp_order}}{Public}

% IC_FP_SIZE
\item \namedlabel{text:ic_fp_size} \ParameterEntry{FP solution - region size}
{Region size (in pixels) that each FP peak is fitted to}
{IC\_FP\_SIZE}{3}
{\calWAVE}{\constantsfile}{\spirouWAVE.\path{fp_wavelength_sol}}{Public}

% IC_FP_THRESHOLD
\item \namedlabel{text:ic_fp_threshold} \ParameterEntry{FP solution - position threshold}
{Defines the threshold used in detecting the positions of the FP peaks.}
{IC\_FP\_THRESHOLD}{0.2}
{\calWAVE}{\constantsfile}{\spirouWAVE.\path{fp_wavelength_sol}}{Public}

% IC_FP_DOPD0
\item \namedlabel{text:ic_fp_dopd0} \ParameterEntry{FP solution - cavity width}
{Defines the initial value of the FP effective cavity width (in nm). For SPIRou this is: 
\begin{equation}
2 \times d = 24.5 mm = 24.5\times10^{6} nm
\end{equation}
}
{IC\_FP\_DOPD0}{2.45e7}
{\calWAVE}{\constantsfile}{\spirouWAVE.\path{fp_wavelength_sol}, \spirouWAVE.\path{find_fp_lines}, \spirouWAVE.\path{correct_for_large_fp_jumps}}{Public}

% IC_FP_FIT_DEGREE
\item \namedlabel{text:ic_fp_fit_degree} \ParameterEntry{FP solution - poly-fit degree}
{Defines the polynomial fit degree between FP line numbers and the measured cavity width for each line.}
{IC\_FP\_FIT\_DEGREE}{9}
{\calWAVE}{\constantsfile}{\spirouWAVE.\path{fp_wavelength_sol}}{Public}

% IC_FP_LARGE_JUMP
\item \namedlabel{text:ic_fp_large_jump} \ParameterEntry{FP solution - large jump size}
{Defines the ``jump'' value (in pixels) that is considered too large between the current and previous FP peaks.}
{IC\_FP\_LARGE\_JUMP}{0.7}
{\calWAVE}{\constantsfile}{ \spirouWAVE.\path{correct_for_large_fp_jumps}}{Public}

% IC_WAVE_IDRIFT_PLOT_ORDER
\item \namedlabel{text:ic_wave_idrift_plot_order} \ParameterEntry{Instrumental drift plot order}
{Defines the plot order for the comparison between the reference spectrum and this iterations spectrum during the instrumental drift calculation. Must be an integer between zero and the maximum number of orders.}
{IC\_WAVE\_IDRIFT\_PLOT\_ORDER}{14}
{\calWAVE}{\constantsfile}{\spirouPlot.\path{wave_plot_instrument_drift}}{Public}

% IC_WAVE_IDRIFT_NOISE
\item \namedlabel{text:ic_wave_idrift_noise} \ParameterEntry{Instrumental drift noise}
{Defines the noise to use in the instrumental drift calculation}
{IC\_WAVE\_IDRIFT\_NOISE}{50.0}
{\calWAVE}{\constantsfile}{\spirouWAVE.\path{calculate_instrument_drift}}{Public}

% IC_WAVE_IDRIFT_MAXFLUX
\item \namedlabel{text:ic_wave_idrift_maxflux} \ParameterEntry{Instrumental drift maximum flux}
{Defines the maximum flux for a good (unsaturated) pixel to use in the instrumental drift calculation.}
{IC\_WAVE\_IDRIFT\_MAXFLUX}{350000}
{\calWAVE}{\constantsfile}{\spirouWAVE.\path{calculate_instrument_drift}}{Public}

% IC_WAVE_IDRIFT_BOXSIZE
\item \namedlabel{text:ic_wave_idrift_boxsize} \ParameterEntry{Instrumental drift saturation box size}
{Defines the size around a saturated pixel to flag as unusable in the instrumental drift calculation.}
{IC\_WAVE\_IDRIFT\_BOXSIZE}{12}
{\calWAVE}{\constantsfile}{\spirouWAVE.\path{calculate_instrument_drift}}{Public}

% IC_WAVE_IDRIFT_CUT_E2DS
\item \namedlabel{text:ic_wave_idrift_cut_e2ds} \ParameterEntry{Instrumental drift cosmic sigma}
{Defines the number of standard deviations to cut at in the cosmic re-normalization calculation during the instrumental drift calculation.}
{IC\_WAVE\_IDRIFT\_CUT\_E2DS}{4.5}
{\calWAVE}{\constantsfile}{\spirouWAVE.\path{calculate_instrument_drift}}{Public}

% IC_WAVE_IDRIFT_MAX_ERR
\item \namedlabel{text:ic_wave_idrift_max_err} \ParameterEntry{Instrumental drift maximum uncertainty}
{Defines the maximum uncertainty allowed on the RV for a given order. Used during the instrumental drift calculation.}
{IC\_WAVE\_IDRIFT\_MAX\_ERR}{3.0}
{\calWAVE}{\constantsfile}{\spirouWAVE.\path{calculate_instrument_drift}}{Public}

% IC_WAVE_IDRIFT_RV_CUT
\item \namedlabel{text:ic_wave_idrift_rv_cut} \ParameterEntry{Instrumental drift RV cut}
{Defines the RV cut above which the RV from orders are not used. Used during the instrumental drift calculation.}
{IC\_WAVE\_IDRIFT\_RV\_CUT}{20.0}
{\calWAVE}{\constantsfile}{\spirouWAVE.\path{calculate_instrument_drift}}{Public}


\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
\clearpage
\newpage
\section{CCF calibration variables}
\label{ch:variables:ccf}
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{itemize}

% IC_CCF_WIDTH
\item \ParameterEntry{CCF Width}
{Define the width of the CCF range. Value must be a positive integer.}
{ic\_ccf\_width}{30.0}
{\calCCF}{\constantsfile}{\calCCF.main()}{Public}


% IC_CCF_STEP
\item \ParameterEntry{CCF Step}
{Define the computations steps of the CCF }
{ic\_ccf\_step}{0.5}
{\calCCF}{\constantsfile}{\calCCF.main()}{Public}


% IC_W_MASK_MIN
\item \ParameterEntry{CCF mask weight}
{Define the weight of the CCF mask (if 1 force all weights equal)}
{ic\_w\_mask\_min}{0.0}
{\calCCF}{\constantsfile}{\spirouRV.get\_ccf\_mask()}{Public}


% IC_MASK_WIDTH
\item \ParameterEntry{Template line width}
{Define the width of the template line (if 0 use natural)}
{ic\_mask\_width}{1.7}
{\calCCF}{\constantsfile}{\spirouRV.get\_ccf\_mask()}{Public}


% CCF_BERV
\item \ParameterEntry{Barycentric Earth RV}
{Define the barycentric Earth RV (berv)}
{ccf\_berv}{0.0}
{\calCCF}{\constantsfile}{\spirouRV.coravelation()}{Public}


% CCF_BERV_MAX
\item \ParameterEntry{Maximum barycentric Earth RV}
{Define the maximum barycentric Earth RV }
{ccf\_berv\_max}{0.0}
{\calCCF}{\constantsfile}{\spirouRV.coravelation()}{Public}


% CCF_DET_NOISE
\item \ParameterEntry{Detector CCF noise}
{Define the detector noise to use in the CCF.}
{ccf\_det\_noise}{100.0}
{\calCCF}{\constantsfile}{\spirouRV.coravelation()}{Public}


% CCF_FIT_TYPE
\item \ParameterEntry{CCF Fit type}
{Define the type of fit for the CCF fit.}
{ccf\_fit\_type}{0}
{\calCCF}{\constantsfile}{\spirouRV.coravelation()}{Public}


% CCF_NUM_ORDERS_MAX
\item \ParameterEntry{CCF end order number.}
{Define the number of orders (from zero to ccf\_num\_orders\_max) to use to calculate the CCF and RV}
{ccf\_num\_orders\_max}{25}
{\calCCF}{\constantsfile}{\calCCF.main()}{Public}


% CCF_BERVMODE
\item \namedlabel{text:ccf_bervmode} \ParameterEntry{Earth velocity calculation mode}
{Deine the mode to work out the Earth velocity correction calculation. Options are:
\begin{itemize}
	\item "off" - berv is set to zero
	\item "old" - berv is calculated with FORTRAN newbervmain.f
	\item "new" - berv is calculated using barycorrpy
\end{itemize}
}
{CCF\_BERVMODE}{"new"}
{\calCCF}{\constantsfile}{\calCCF.\progMAIN, \spirouRV.\path{EarthVelocityCorrection}}{Public}

\ifdevguide

\begin{note}
If mode = "old" newbervmain.f needs to be compiled with:
\begin{cmdbox}
f2py -c -m newbervmain --noopt --quiet newbervmain.f
\end{cmdbox}
While located in the \path{\ldots/INTROOT/SpirouDRS/fortan} directory.
\end{note}

\begin{note}
If mode = "new" barycorrpy must be installed with
\begin{cmdbox}
pip install barycorrpy
\end{cmdbox}
\end{note}

\fi

\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
\clearpage
\newpage
\section{Polarimetry variables}
\label{ch:variables:polarimetry}
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{itemize}

% IC_POLAR_STOKES_PARAMS
\item \namedlabel{text:ic_polar_stokes_params} \ParameterEntry{Stokes parameters}
{Define all possible stokes parameters}
{IC\_POLAR\_STOKES\_PARAMS}{\lstinline[style=pythoninline]| ['V', 'Q', 'U']|}
{\polspirou}{\constantsfile}{\spirouPOLAR.\path{load_data}}{Public}

% IC_POLAR_FIBERS
\item \namedlabel{text:ic_polar_fibers} \ParameterEntry{Polar fibers}
{Define all possible fibers used for polarimetry}
{IC\_POLAR\_FIBERS}{\lstinline[style=pythoninline]| ['A', 'B']|}
{\polspirou}{\constantsfile}{\spirouPOLAR.\path{load_data}}{Public}

% IC_POLAR_METHOD
\item \namedlabel{text:ic_polar_method} \ParameterEntry{Polar method}
{Define the polarimetry method. Currently must be either: ``Ratio'' or ``Difference''.}
{IC\_POLAR\_METHOD}{'Ratio'}
{\polspirou}{\constantsfile}{\spirouPOLAR.\path{calculate_polarimetry_wrapper}}{Public}

% IC_POLAR_CONT_BINSIZE
\item \namedlabel{text:ic_polar_cont_binsize} \ParameterEntry{Polar continuum bin size}
{Define the polarimetry continuum bin size (for plotting)}
{IC\_POLAR\_CONT\_BINSIZE}{1000}
{\polspirou}{\constantsfile}{\spirouPOLAR.\path{calculate_continuum}}{Public}

% IC_POLAR_CONT_OVERLAP
\item \namedlabel{text:ic_polar_cont_overlap} \ParameterEntry{Polar continuum overlap size}
{Define the polarimetry continuum overlap size (for plotting)}
{IC\_POLAR\_CONT\_OVERLAP}{0}
{\polspirou}{\constantsfile}{\spirouPOLAR.\path{calculate_continuum}}{Public}

% IC_POLAR_CONT_TELLMASK
\item \namedlabel{text:ic_polar_cont_tellmask} \ParameterEntry{Polar tell mask}
{Define the telluric mask for calculation of the continuum.}
{IC\_POLAR\_CONT\_TELLMASK}
{\lstinline[style=pythoninline]| [[930,967],[1109,1167],[1326,1491],[1782,1979],[1997,2027],[2047,2076]] |}
{\polspirou}{\constantsfile}{\spirouPOLAR.\path{calculate_continuum}}{Public}

\end{itemize}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
\clearpage
\newpage
\section{Exoposure-meter variables}
\label{ch:variables:exopsuremeter}
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{itemize}

% EM_FIB_TYPE
\item \namedlabel{text:em_fib_type} \ParameterEntry{Exposure-meter Fiber Type}
{Define which fiber to extract. Must be either AB or A or B or C.}
{EM\_FIB\_TYPE}{"AB"}
{\calexometer}{\constantsfile}{\calexometer.\progMAIN}{Public}

% EM_TELL_THRESHOLD
\item \namedlabel{text:em_tell_threshold} \ParameterEntry{Telluric threshold}
{Define the telluric threshold (transmission) level to mask at.}
{EM\_TELL\_THRESHOLD}{0.95}
{\calexometer}{\constantsfile}{\calexometer.\progMAIN, \spirouExposeMeter.\path{create_mask}}{Public}

% EM_MIN_LAMBDA
\item \namedlabel{text:em_min_lambda} \ParameterEntry{Minimum wavelength for exposure-meter}
{Define the minimum wavelength (in nm) to mask at.}
{EM\_MIN\_LAMBDA}{1478.7}
{\calexometer}{\constantsfile}{\calexometer.\progMAIN, \spirouExposeMeter.\path{create_mask}}{Public}

% EM_MAX_LAMBDA
\item \namedlabel{text:em_max_lambda} \ParameterEntry{Maximum wavelength for exposure-meter}
{Define the maximum wavelength (in nm) to mask at.}
{EM\_MAX\_LAMBDA}{1823.1}
{\calexometer}{\constantsfile}{\calexometer.\progMAIN, \spirouExposeMeter.\path{create_mask}}{Public}

% EM_OUTPUT_TYPE
\item \namedlabel{text:em_output_type} \ParameterEntry{Exposure-meter file output type}
{Define what shape/properties we want the output mask to be. Options are:
\begin{itemize}
	\item "raw" - shape and rotation as in the raw input files
	\item "drs" - shape and rotation as in the DRS files
	\item "preprocess" - shape and rotation as in the pre-processed files
	\item "all" - produces all of the above
\end{itemize}
}
{EM\_OUTPUT\_TYPE}{"all"}
{\calexometer}{\constantsfile}{\calexometer.\progMAIN, \spirouCONST.\path{EM_SPE_FILE}, \spirouCONST.\path{EM_WAVE_FILE}, \spirouCONST.\path{EM_MASK_FILE}}{Public}


% EM_COMBINED_BADPIX
\item \namedlabel{text:em_combined_badpix} \ParameterEntry{Exposure-meter - include bad pixel mask}
{Define whether to combine exposure meter mask with the bad pixel mask. If True bad pixel mask is combined if False it is not.}
{EM\_COMBINED\_BADPIX}{True}
{\calexometer}{\constantsfile}{\calexometer.\progMAIN}{Public}

% EM_SAVE_WAVE_MAP
\item \namedlabel{text:em_save_wave_map} \ParameterEntry{Exposure-meter - save wave map}
{Define whether to save the 2D wavelength map. If True saves map if False does not save the map.}
{EM\_SAVE\_WAVE\_MAP}{True}
{\calexometer}{\constantsfile}{\calexometer.\progMAIN}{Public}

% EM_SAVE_TELL_SPEC
\item \namedlabel{text:em_save_tell_spec} \ParameterEntry{Exposure-meter - save telluric spectrum}
{Define whether to save the telluric spectrum mapped on to the 2D wavelength map. If True saves map if False does not save the map.}
{EM\_SAVE\_TELL\_SPEC}{True}
{\calexometer}{\constantsfile}{\calexometer.\progMAIN}{Public}


% EM_SAVE_MASK_MAP
\item \namedlabel{text:em_save_tell_spec} \ParameterEntry{Exposure-meter - save mask}
{Define whether to save the mask mapped on to the 2D wavelength map. If True saves map if False does not save the map.}
{EM\_SAVE\_MASK\_MAP}{True}
{\calexometer}{\constantsfile}{\calexometer.\progMAIN}{Public}



\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
\clearpage
\newpage
\section{Quality control variables}
\label{ch:variables:qualitycontrol}
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{itemize}

% qc_max_darklevel
\item \namedlabel{text:qc_max_darklevel} \ParameterEntry{Maximum dark median level}
{Defines the maximum dark median level in ADU/s. If this is greater than median flux it does not pass the quality control criteria:
\begin{equation}
\text{Median Flux} < \text{qc\_max\_darklevel}
\end{equation}
Value must be a float equal to or larger than zero. 
}
{qc\_max\_darklevel}{0.5}
{\calDARK}{\constantsfile}{\calDARK.\progMAIN}{Public}


% qc_max_dead
\item \namedlabel{text:qc_max_dead} \ParameterEntry{Maximum percentage of dead pixels}
{Defines the maximum allowed percentage of dead pixels in a dark image. If the number of dead pixels is greater than this it does not pass the quality control criteria:
\begin{equation}
\text{dead pixels} = (\text{pixel value} > \text{dark\_cutlimit}) \text{ and } (\text{pixel value} \neq \text{NaN})
\end{equation}
\begin{equation}
\text{Percentage of dead pixels} < \text{qc\_max\_dead}
\end{equation}
}
{qc\_max\_dead}{20.0}
{\calDARK}{\constantsfile}{\calDARK.\progMAIN}{Public}


% qc_max_dark
\item \namedlabel{text:qc_max_dark} \ParameterEntry{Maximum percentage of bad dark pixels}
{Defines the maximum allowed percentage of bad dark pixels in a dark image. If the number of dead pixels is greater than this it does not pass the quality control criteria:
\begin{equation}
\text{bad dark pixels} = \text{pixel value} > \text{dark\_cutlimit}
\end{equation}
\begin{equation}
\text{Percentage of bad dark pixels} < \text{qc\_max\_dead}
\end{equation}
}
{qc\_max\_dark}{6.0}
{\calDARK}{\constantsfile}{\calDARK.\progMAIN}{Public}


% qc_dark_time
\item \ParameterEntry{Minimum dark exposure time}
{Defines the minimum dark exposure time. If exposure time (from FITS rec HEADER) is below this the code will exit with `Dark exposure time too short' message. Value must be a float greater than zero.}
{qc\_dark\_time}{599.0}
{\calDARK}{\constantsfile}{\calDARK.\progMAIN}{Public}


% qc_loc_maxlocfit_removed_ctr
\item \namedlabel{text:qc_loc_maxlocfit_removed_ctr} \ParameterEntry{Maximum points removed in localization position fit}
{Defines the maximum allowed number of points removed in the position fitting process (during localization). If number is more than this it does not pass the quality control criteria: 
\begin{equation}
\text{Number of rejected orders in center fit} >\text{qc\_loc\_maxlocfit\_removed\_ctr}
\end{equation}
Value must be a integer greater than zero.
}
{qc\_loc\_maxlocfit\_removed\_ctr}{1500}
{\callocRAW}{\constantsfile}{\callocRAW.\progMAIN}{Public}


% qc_loc_maxlocfit_removed_wid
\item \namedlabel{text:qc_loc_maxlocfit_removed_wid} \ParameterEntry{Maximum points removed in localization width fit}
{Defines the maximum allowed number of points removed in the width fitting process (during localization). If number is more than this it does not pass the quality control criteria: 
\begin{equation}
\text{Number of rejected orders in width fit} >\text{qc\_loc\_maxlocfit\_removed\_width}
\end{equation}
Value must be a integer greater than zero.
}
{qc\_loc\_maxlocfit\_removed\_wid}{105}
{\callocRAW}{\constantsfile}{\callocRAW.\progMAIN}{Public}


% qc_loc_rmsmax_center
\item \namedlabel{text:qc_loc_rmsmax_center} \ParameterEntry{Maximum allowed RMS in fitting in localization position fit}
{Defines the maximum RMS allowed in the position fitting process (during localization). If the RMs is higher than this value it does not pass the quality control criteria: 
\begin{equation}
\text{Mean rms center fit} > \text{qc\_loc\_rmsmax\_center}
\end{equation}
Value must be a float greater than zero.
}
{qc\_loc\_rmsmax\_center}{100}
{\callocRAW}{\constantsfile}{\callocRAW.\progMAIN}{Public}


% qc_loc_rmsmax_fwhm
\item \namedlabel{text:qc_loc_rmsmax_fwhm} \ParameterEntry{Maximum allowed RMS in fitting in localization width fit}
{Defines the maximum RMS allowed in the width fitting process (during localization). If the RMs is higher than this value it does not pass the quality control criteria: 
\begin{equation}
\text{Mean rms width fit} > \text{qc\_loc\_rmsmax\_fwhm}
\end{equation}
Value must be a float greater than zero.
}
{qc\_loc\_rmsmax\_fwhm}{500}
{\callocRAW}{\constantsfile}{\callocRAW.\progMAIN}{Public}

% qc_ff_rms
\item \ParameterEntry{Maximum allowed RMS}
{Defines the maximum RMS allowed to accept a flat-field for calibration. Value must be a float greater than zero.}
{qc\_ff\_rms}{0.12}
{\calFFraw}{\constantsfile}{\calFFraw.\progMAIN}{Public}

% qc_loc_flumax 
\item \ParameterEntry{Saturation level reached warning}
{Defines the level above which a warning is generated in the form `SATURATION LEVEL REACHED on Fiber \definevariable{text:fiber_types}{fiber}'. Value must be a float greater than zero.}
{qc\_loc\_flumax}{64500}
{\calFFraw}{\constantsfile}{\calFFraw.\progMAIN}{Public}

% qc_slit_rms
\item \namedlabel{text:qc_slit_rms} \ParameterEntry{Maximum RMS allowed for slit TILT}
{Defines the maximum allowed RMS in the calculated TILT to add TILT profile to the \calibdb. Value must be a float larger than zero.}
{qc\_slit\_rms}{0.1}
{\calSLIT}{\constantsfile}{\calSLIT.\progMAIN}{Public}

% qc_slit_min
\item \namedlabel{text:c_slit_min} \ParameterEntry{Minimum angle allowed for slit TILT}
{Defines the minimum tilt angle allowed to add TILT profile to the calibration database. Value must be a float and must be less than \definevariable{text:c_slit_max}{qc\_slit\_max}}
{qc\_slit\_min}{-8.0}
{\calSLIT}{\constantsfile}{\calSLIT.\progMAIN}{Public}

% qc_slit_max
\item \namedlabel{text:c_slit_max} \ParameterEntry{Maximum angle allowed for slit TILT}
{Defines the maximum tiult angle allowed to add TILT profile to the calibration database. Value must be a float and must be greater than \definevariable{text:c_slit_min}{qc\_slit\_min}}
{qc\_slit\_max}{0.0}
{\calSLIT}{\constantsfile}{\calSLIT.\progMAIN}{Public}

% qc_max_signal
\item \namedlabel{text:qc_max_signal} \ParameterEntry{Saturation point}
{Defines the maximum signal allowed (when defining saturation limit). Currently this does not contribute to failing the quality test. Value must be a float greater than zero.}
{qc\_max\_signal}{65500}
{\calextractRAW}{\constantsfile}{\calextractRAW.\progMAIN}{Public}
\DevNote{Currently this does not stop the file from passing the quality control criteria, it either should fail or should be removed.}


% QC_HC_RMS_LITTROW_MAX
\item \namedlabel{text:qc_hc_rms_littrow_max} \ParameterEntry{Maximum Littrow RMS (HC)}
{Defines the maximum Littrow RMS value for \calHC.}
{QC\_HC\_RMS\_LITTROW\_MAX}{0.1}
{\calHC}{\constantsfile}{\calHC.\progMAIN}{Public}

% QC_HC_DEV_LITTROW_MAX
\item \namedlabel{text:qc_hc_dev_littrow_max} \ParameterEntry{Maximum Littrow Deviation (HC)}
{Defines the maximum Littrow deviation from the wave solution for \calHC.}
{QC\_HC\_DEV\_LITTROW\_MAX}{0.4}
{\calHC}{\constantsfile}{\calHC.\progMAIN}{Public}

% QC_WAVE_RMS_LITTROW_MAX
\item \namedlabel{text:qc_wave_rms_littrow_max} \ParameterEntry{Maximum Littrow RMS (WAVE)}
{Defines the maximum Littrow RMS value for \calWAVE}
{QC\_WAVE\_RMS\_LITTROW\_MAX}{0.1}
{\calWAVE}{\constantsfile}{\calWAVE.\progMAIN}{Public}

% QC_WAVE_DEV_LITTROW_MAX
\item \namedlabel{text:qc_wave_dev_littrow_max} \ParameterEntry{Maximum Littrow Deviation (WAVE)}
{Defines the maximum Littrow deviation from the wave solution for \calWAVE.}
{QC\_WAVE\_DEV\_LITTROW\_MAX}{0.3}
{\calWAVE}{\constantsfile}{\calWAVE.\progMAIN}{Public}

% QC_WAVE_IDRIFT_NBORDEROUT
\item \namedlabel{text:qc_wave_idrift_nborderout} \ParameterEntry{Instrumental drift, maximum No. order removed}
{Defines the maximum number of orders allowed to be removed from the RV calculation in order to pass the quality control, for the instrumental drift calculation.}
{QC\_WAVE\_IDRIFT\_NBORDEROUT}{15}
{\calWAVE}{\constantsfile}{\spirouWAVE.\path{calculate_instrument_drift}}{Public}

% QC_WAVE_IDRIFT_RV_MAX
\item \namedlabel{text:qc_wave_idrift_rv_max} \ParameterEntry{Instrumental drift, maximum allowed RV}
{Defines the maximum allowed RV drift (in m/s) allowed for the instrumental drift calculation.}
{QC\_WAVE\_IDRIFT\_RV\_MAX}{150.0}
{\calWAVE}{\constantsfile}{\spirouWAVE.\path{calculate_instrument_drift}}{Public}


\end{itemize}







%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
\clearpage
\newpage
\section{Calibration database variables}
\label{ch:variables:calibdb}
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{itemize}

% ic_calibDB_filename
\item \namedlabel{text:ic_calibDB_filename} \ParameterEntry{The calibration database master filename}
{Defines the name of the master \calibdb text file for use in all \calibdb operation.}
{ic\_calibDB\_filename}{master\_calib{\hskip 0pt}\_SPIROU.txt}
{\AllRecipes}{\constantsfile}{\spirouConst.CALIBDB\_MASTERFILE()}{Public}
\DevNote{This should probably be private, unless we want the user to be able to change calibDB files.}


% calib_max_wait
\item \ParameterEntry{Maximum wait time for locked calibration database}
{Defines the maximum time the code waits for the \calibdb when it is locked. A locked file is created every time the \calibdb is open (and subsequently closed when reading of the database was successful). If a lock file is present the code will wait a maximum of this many seconds and keep checking whether the lock file has been removed. After which time the code will exit with an error. Value must be a positive float greater than zero. Measured in seconds.}
{calib\_max\_wait}{3600}
{\AllRecipes}{\constantsfile}{\spirouCDB.get\_check\_lock\_file()}{Public}


% calib_db_match
\item \namedlabel{text:calib_db_match} \ParameterEntry{Calibration database duplicate key handler}
{Defines the mechanism to use in deciding between duplicate keys in the \calibdb file. Value must be a string and must be either 'older' or 'closest'. If 'older' the \calibdb will only use keys that are older than the timestamp in the input fits file (first argument) using the key \defineinkeyword{text:acqtime1}{kw\_ACQTIME\_KEY}}
{calib\_db\_match}{'closest'}
{\AllRecipes}{\constantsfile}{\spirouCDB.get\_check\_lock\_file()}{Public}

\end{itemize}








\ifdevguide
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
\clearpage
\newpage
\section{Startup variables}
\label{ch:variables:startup}
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{itemize}


% config_folder
\item \namedlabel{text:config_folder} \ParameterEntry{Configuration Folder Path}
{Defines the location of the configuration directory relative to the module directory (defined in variable = `package'). Value must be a string containing a valid directory location.}
{config\_folder}{\configdirrelpath}
{\AllRecipes}{\spirouConst.CONFIGFOLDER()}{\AllRecipes}{Private}


% config_file
\item \namedlabel{text:config_file} \ParameterEntry{Configuration file name}
{Defines the main configuration (containing the data directories etc).  Value must be a string containing a valid file name i.e. the main configuration file should be at \definevariable{text:tdata}{TDATA}/\definevariable{text:config_folder}{config\_folder}/\definevariable{text:config_file}{config\_file}.}
{config\_file}{\configtxtfile}
{\AllRecipes}{\spirouConst.CONFIGFILE()}{\AllRecipes}{Private}


% cdata_folder
\item \namedlabel{text:cdata_folder} \ParameterEntry{Constant data folder relative path}
{Defines the storage folder for data files that are used in the DRS. This included masks and lookup tables used by the DRS and not changed by the user. Value should be a string with a path that is relative to the DRS module folder (i.e. SpirouDRS) for example the path `./data' would be located under the SpirouDRS folder.}
{const\_data\_folder}{'./data'}
{\AllRecipes}{\spirouConst.CDATA\_FOLDER}{\AllRecipes}{Private}


% arg_file_names
\item \namedlabel{text:arg_file_names} \PseudoParamEntry{Filenames from run time arguments}
{Gets the filenames from run time arguments.}
{arg\_file\_names}
{\AllRecipes}{\spirouConst.ARG\_FILE\_NAMES()}{\spirouStartup.run\_time\_args()}


% arg_night_name
\item \namedlabel{text:arg_night_name} \PseudoParamEntry{Night name from run time arguments}
{Gets the night name from run time arguments.}
{arg\_night\_name}
{\AllRecipes}{\spirouConst.ARG\_NIGHT\_NAME()}{\spirouStartup.run\_time\_args()}


% calibdb_masterfile
\item \PseudoParamEntry{Calibration database file path}
{Gets the full \calibdb file path}
{masterfilepath}
{\AllRecipes}{\spirouConst.CALIBDB\_MASTERFILE()}{\spirouCDB.write\_files\_to\_master(), \spirouCDB.read\_master\_file(), \spirouImage.correct\_for\_dark()}


% calibdb_lockfile
\item \PseudoParamEntry{Calibration database lock file path}
{Gets the full \calibdb lock file path}
{lockfilepath}
{\AllRecipes}{\spirouConst.CALIBDB\_LOCKFILE()}{\spirouCDB.get\_check\_lock\_file()}


% calib_prefix
\item \PseudoParamEntry{Calibration database file prefix}
{Defines the prefix for \calibdb files. Value must be a string.}
{calib\_prefix}
{\AllRecipes}{\spirouConst.CALIB\_PREFIX(()}{\calDARK.\progMAIN, \callocRAW.\progMAIN, \calSLIT.\progMAIN, \calFFraw.\progMAIN}


% fitsfilename
\item \namedlabel{text:fitsfilename} \PseudoParamEntry{Fits file name}
{Gets the full file path of the first file in `arg\_file\_names'}
{fitsfilename}
{\AllRecipes}{\spirouConst.FITSFILENAME()}{\spirouStartup.run\_time\_args()}


% log_opt
\item \namedlabel{text:log_opt} \PseudoParamEntry{Log program name}
{Chooses the display format for the program in the logging system.}
{log\_opt}
{\AllRecipes}{\spirouConst.LOG\_OPT()}{\spirouStartup.run\_time\_args()}


% recipe
\item \namedlabel{text:recipe} \PseudoParamEntry{The Recipe name}
{The definition of the recipe name (usually from \_\_NAME\_\_).}
{recipe}
{\AllRecipes}{\AllRecipes}{\AllRecipes}


% manual_file
\item \PseudoParamEntry{Documentation info manual file path}
{Gets the full documentation info manual file path}
{manual\_file}
{\AllRecipes}{\spirouConst.MANUAL\_FILE()}{\spirouStartup.display\_help\_file()}


% nbframes
\item \namedlabel{text:nbframes} \PseudoParamEntry{Number of frames}
{Gets the number of frames from the list of files (`arg\_file\_names').}
{nbframes}
{\AllRecipes}{\spirouConst.NBFRAMES}{\spirouStartup.run\_time\_args()}


% program
\item \PseudoParamEntry{Program name from run time}
{Gets the run program name from run time.}
{program}
{\AllRecipes}{\spirouConst.PROGRAM()}{\spirouStartup.run\_time\_args()}


% raw_dir
\item \PseudoParamEntry{Full path of raw data directory}
{Gets the full path of the raw data directory.}
{raw\_dir}
{\AllRecipes}{\spirouConst.RAW\_DIR()}{\spirouFITS.math\_controller(), \spirouImage.get\_all\_similar\_files(), \spirouStartup.display\_run\_files()}


% reduced_dir
\item \namedlabel{text:reduced_dir} \PseudoParamEntry{Full path of reduced data directory}
{Gets the full path of the reduced data directory.}
{reduced\_dir}
{\AllRecipes}{\spirouConst.\path{REDUCED_DIR()}}{\spirouStartup.run\_time\_args()}

\end{itemize}

\fi


\ifdevguide
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
\clearpage
\newpage
\section{Output file variables}
\label{ch:variables:outputvariables}
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% darkfile
\begin{itemize}
	\item \namedlabel{text:darkfile} \PseudoParamEntry{The dark calibration filename}
	{The full path of the processed dark calibration file}
	{darkfile}
	{\calDARK}{\spirouConst.\path{DARK\_FILE()}}{\calDARK}
\end{itemize}

% darkbadpixfile
\begin{itemize}
	\item \namedlabel{text:darkbadpixfile} \PseudoParamEntry{The dark bad pixel map calibration file}
	{The full path of the processed dark bad pixel map calibration filename}
	{darkbadpixfile}
	{\calDARK}{\spirouConst.\path{DARK_BADPIX_FILE()}}{\calDARK}
\end{itemize}

% badpixelfits
\begin{itemize}
	\item \namedlabel{text:badpixelfits} \PseudoParamEntry{The bad pixel map calibration filename}
	{The full path of the processed bad pixel map calibration file}
	{badpixfile}
	{\calbadpix}{\spirouConst.\path{BADPIX_FILE()}}{\calbadpix}
\end{itemize}

% order_profile
\begin{itemize}
	\item \namedlabel{text:order_profile} \PseudoParamEntry{The order profile image filename}
	{The full path of the order profile image file.}
	{orderpfile}
	{\callocRAW}{\spirouConst.\path{LOC_ORDER_PROFILE_FILE()}}{\callocRAW}
\end{itemize}

% locofits
\begin{itemize}
	\item \namedlabel{text:locofitsfile} \PseudoParamEntry{Localization filename 1}
	{The full path of the processed localisation file containing the center fits for each order.}
	{locofits}
	{\callocRAW}{\spirouConst.\path{LOC_LOCO_FILE()}}{\callocRAW}
\end{itemize}

% locofits2
\begin{itemize}
	\item \namedlabel{text:locofitsfile2} \PseudoParamEntry{Localization filename 2}
	{The full path of the processed localisation file containing the width fits for each order}
	{locofits2}
	{\callocRAW}{\spirouConst.\path{LOC_LOCO_FILE2()}}{\callocRAW}
\end{itemize}

% locofits3
\begin{itemize}
	\item \namedlabel{text:locofitsfile3} \PseudoParamEntry{Localization filename 3}
	{The full path of the fits super-imposed onto the original image file.}
	{locofits3}
	{\callocRAW}{\spirouConst.\path{LOC_LOCO_FILE3()}}{\callocRAW}
\end{itemize}

% tiltfits
\begin{itemize}
	\item \namedlabel{text:tiltfits} \PseudoParamEntry{Tilt filename}
	{The full path of the processed tilt file.}
	{tiltfits}
	{\calSLIT}{\spirouConst.\path{SLIT_TILT_FILE()}}{\calSLIT}
\end{itemize}

% blazefits
\begin{itemize}
	\item \namedlabel{text:blazefits} \PseudoParamEntry{Blaze filename}
	{The full path of the processed blaze file.}
	{blazefits}
	{\calFFraw}{\spirouConst.\path{FF_BLAZE_FILE()}}{\calFFraw}
\end{itemize}


% flatfits
\begin{itemize}
	\item \namedlabel{text:flatfits} \PseudoParamEntry{Flat filename}
	{The full path of the processed flat file}
	{flatfits}
	{\calFFraw}{\spirouConst.\path{FF_FLAT_FILE()}}{\calFFraw}
\end{itemize}


% e2ds file
\begin{itemize}
	\item \namedlabel{text:e2ds_file} \PseudoParamEntry{E2DS filename}
	{The full path of the processed and extracted E2DS file}
	{e2dsfits}
	{\calextractRAW, \calextractRAWAB, \calextractRAWC()}{\spirouConst.\path{EXTRACT_E2DS_FILE}}{\calextractRAW}
\end{itemize}


% all extract types
\begin{itemize}
	\item \namedlabel{text:exfitslist} \PseudoParamEntry{The extraction filenames}
	{Defines the extraction names (and locations) for the extraction process for all types of E2DS file. i.e. the filenames for `simple', `tilt', `tiltweight', `tiltweight2' and `weight'}
	{exfitslist}
	{\calextractRAW}{\spirouConst.\path{EXTRACT_E2DS_ALL_FILES()}}{\calextractRAW}
\end{itemize}


% driftfits_raw
\begin{itemize}
	\item \namedlabel{text:driftfits_raw} \PseudoParamEntry{The raw drift filename}
	{Defines the raw drift fits file name and location}
	{driftfits\_raw}
	{\calDRIFTRAW}{\spirouConst.\path{DRIFT_RAW_FILE()}}{\calDRIFTRAW}
\end{itemize}

% driftfits_e2ds
\begin{itemize}
	\item \namedlabel{text:driftfits_e2ds} \PseudoParamEntry{The E2DS drift filename}
	{Defines the E2DS drift fits filename and location}
	{driftfits\_e2ds}
	{\calDRIFTE}{\spirouConst.\path{DRIFT_E2DS_FITS_FILE()}}{\calDRIFTE}
\end{itemize}


% drifttblfilename_e2ds
\begin{itemize}
	\item \namedlabel{text:drifttblfilename_e2ds} \PseudoParamEntry{The E2DS drift table filename}
	{Defines the E2DS drift table filename and location}
	{drifttblfilename\_e2ds}
	{\calDRIFTE}{\spirouConst.\path{DRIFT_E2DS_TBL_FILE()}}{\calDRIFTE}
\end{itemize}


% driftfits_peak_e2ds
\begin{itemize}
	\item \namedlabel{text:driftfits_peak_e2ds} \PseudoParamEntry{The E2DS drift-peak fits filename}
	{Defines the E2DS drift-peak fits filename and location}
	{driftfits\_peak\_e2ds}
	{\calDRIFTPEAK}{\spirouConst.\path{DRIFTPEAK_E2DS_FITS_FILE}}{\calDRIFTPEAK}
\end{itemize}


% drifttblfilename_peak_e2ds
\begin{itemize}
	\item \namedlabel{text:drifttblfilename_peak_e2ds} \PseudoParamEntry{The E2DS drift-peak table filename}
	{Defines the E2DS drift-peak table filename and location}
	{drifttblfilename\_peak\_e2ds}
	{\calDRIFTPEAK}{\spirouConst.\path{DRIFTPEAK_E2DS_TBL_FILE}}{\calDRIFTPEAK}
\end{itemize}


% corfile
\begin{itemize}
	\item \namedlabel{text:corfile} \PseudoParamEntry{CCF filename and location}
	{Defines the CCF fits filename and location}
	{corfile}
	{\calCCF}{\spirouConst.\path{CCF_FITS_FILE}}{\calCCF}
\end{itemize}

% ccf_table_file
\begin{itemize}
	\item \namedlabel{text:ccf_table_file} \PseudoParamEntry{CCF table filename and location}
	{Defines the CCF table file location and name}
	{ccf\_table\_file}
	{\calCCF}{\spirouConst.\path{CCF_TABLE_FILE}}{\calCCF}
\end{itemize}


\fi

\ifdevguide
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
\clearpage
\newpage
\section{Formatting variables}
\label{ch:variables:formatting}
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{itemize}

% date_fmt_header
\item \ParameterEntry{Header date format}
{Defines the format of the date in the FITS rec header files}
{date\_fmt\_header}{\%Y-\%m-\%d-\%H:\%M:\%S.\%f}
{\spirouCDB}{\spirouConst.DATE\_FMT\_HEADER()}{\spirouCDB.update\_database(), \spirouCDB.get\_database()}{Private}


% date_fmt_header
\item \ParameterEntry{Calibration database date format}
{Defines the format of the date in the \calibdb file}
{date\_fmt\_calibdb}{\%Y-\%m-\%d-\%H:\%M:\%S.\%f}
{\spirouCDB}{\spirouConst.DATE\_FMT\_CALIBDB()}{\spirouCDB.update\_database(), \spirouCDB.get\_database()}{Private}

\end{itemize}

\fi







\ifdevguide
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
\clearpage
\newpage
\section{FITS rec variables}
\label{ch:variables:fitsrec}
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{itemize}

% forbidden_keys
\item \namedlabel{text:forbidden_keys}
\begin{minipage}[t]{\textwidth}
\textbf{Forbidden copy keys}

\begin{thighlight}

\textcolor{brown}{Lists the keys that should not be copied when call to copy all FITS rec keys is made. Should be a list of python strings.} \\

\begin{pythonboxblank}
forbidden_keys = ['SIMPLE', 'BITPIX', 'NAXIS', 'NAXIS1', 'NAXIS2', 'EXTEND', 
                  'COMMENT', 'CRVAL1', 'CRPIX1', 'CDELT1', 'CRVAL2', 'CRPIX2', 
                  'CDELT2', 'BSCALE', 'BZERO', 'PHOT_IM', 'FRAC_OBJ', 'FRAC_SKY', 
                  'FRAC_BB']
\end{pythonboxblank}
\begin{tabular}{>{\color{red}}l c l}
&&\\
\textcolor{blue}{Used in:}  & \multicolumn{2}{p{10cm}}{\AllRecipes} \\
\textcolor{blue}{Defined in:} & \multicolumn{2}{p{10cm}}{\spirouConst.FORBIDDEN\_COPY\_KEYS()} \\
\ifdevguide
\textcolor{blue}{Called in:} & \multicolumn{2}{p{10cm}}{\textcolor{codegreen}{\spirouFITS}} \\
\textcolor{blue}{Level:} & \multicolumn{2}{p{10cm}}{Private} \\
\fi
\end{tabular}
\end{thighlight}
\end{minipage}

\end{itemize}

\fi






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
\clearpage
\newpage
\section{Logging and printing variables}
\label{ch:variables:log_print}
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{itemize}

% PRINT_LEVEL
\item \namedlabel{text:print_level} \ParameterEntry{Print message level}
{The level of messages to print, values can be as follows:
\begin{itemize}
	\item "all" -- prints all events
	\item "info" -- prints info, warning and error events
	\item "warning" -- prints warning and error events
	\item "error" -- print only error events
\end{itemize}
Value must be a valid string. \ifdevguide See section \ref{ch:rules:drs_specific:logger} for more details. \fi}
{PRINT\_LEVEL}{all}{\AllRecipes}{\configtxtfile}{\spirouConfig.check\_params()}{Public}

% LOG_LEVEL
\item \namedlabel{text:log_level} \ParameterEntry{Log message level}
{The level of messages to print, values can be as follows:
\begin{itemize}
	\item "all" -- prints all events
	\item "info" -- prints info, warning and error events
	\item "warning" -- prints warning and error events
	\item "error" -- print only error events
\end{itemize}
Value must be a valid string. \ifdevguide See section \ref{ch:rules:drs_specific:logger} for more details. \fi}
{LOG\_LEVEL}{all}{\AllRecipes}{\configtxtfile}{\spirouConfig.writelog()}{Public}


% trig_keys
\ifdevguide

\item \namedlabel{text:trig_keys}
\begin{minipage}[t]{\textwidth}
\ParameterEntry{Logging keys}
{Defines the logging keys to use for each logging levels. Value should be a dictionary of key value pairs (where all keys and values are strings). When using the \spirouLog.logger() (aliases to \WLOG in recipes) the first argument must be one of these keys and the returned string is the corresponding value. The keys of \definevariable{text:write_level}{write\_level} and \definevariable{text:trig_keys}{trig\_key} must be identical. See section \ref{ch:rules:drs_specific:logger} for more details.}
{trig\_key}
{\lstinline[style=pythoninline]| dict(all=' ', error='!', warning='@', info='*', graph='~') |}
{\AllRecipes}{\spirouConst.LOG\_TRIG\_KEYS()}{\AllRecipes}{Private}
\vspace{-0.25cm}
\begin{thighlight}
i.e.: 
\begin{pythonbox}
trig_key = dict(error='!')
WLOG('error', 'program', 'Message')
\end{pythonbox}
returns
\begin{cmdboxprint}
HH:MM:SS.s - ! |program|Message
\end{cmdboxprint}
\end{thighlight}
\end{minipage}
\fi

% write_level
\ifdevguide

\item \namedlabel{text:write_level}
\begin{minipage}[t]{\textwidth}
\ParameterEntry{Write level}
{Defines the write levels to use for each write level. A write level is defined by a number. The higher the number to more exclusive the level i.e. if A and B are write levels and A $>$ B and write level is set to A, any log or print messages at level B will not be logged/printed. Printing is controlled by variable \definevariable{text:print_level}{PRINT\_LEVEL} and logging by variable \definevariable{text:log_level}{LOG\_LEVEL}. The keys of \definevariable{text:write_level}{write\_level} and \definevariable{text:trig_keys}{trig\_key} must be identical. See section \ref{ch:rules:drs_specific:logger} for more details.}
{write\_level}
{\lstinline[style=pythoninline]| dict(error=3, warning=2, info=1, graph=0, all=0) |}
{\AllRecipes}{\spirouConst.LOG\_TRIG\_KEYS()}{\AllRecipes}{Private}
\vspace{-0.25cm}
\begin{thighlight}
i.e.: 
\begin{pythonbox}
write_level = dict(error=3, warning=2, info=1)
trig_key = dict(all=' ', error='!', warning='@', info='*', graph='~')
PRINT_LEVEL = 'warning'

WLOG('error', 'program', 'Error message')
WLOG('warning', 'program', 'Warning message')
WLOG('info', 'program', 'Info message')
\end{pythonbox}
returns
\begin{cmdboxprint}
HH:MM:SS.s - ! |program|Error message
HH:MM:SS.s - @ |program|Warning message
\end{cmdboxprint}
\begin{note}
Note the info message was not shown as info=1 and \definevariable{text:print_level}{PRINT\_LEVEL} is set to warning=2.
\end{note}
\end{thighlight}
\end{minipage}
\fi


% log_exit_type
\ifdevguide
\item \namedlabel{text:log_exit_type} \ParameterEntry{Logger exit type}
{What to do when a logging `error' is raise. Options are: 'None', 'os' or 'sys'. If 'None' the code continues on an `error', if 'os' then python executes a `os.\_exit' command (a hard exit), if 'sys' then python executes a 'sys.exit' command (a soft exit).}
{log\_exit\_type}{sys}
{\AllRecipes}{\spirouConst.LOG\_EXIT\_TYPE()}{\spirouConst.EXIT() which is called in \spirouLog}{Private}
\fi

% exit controller
\ifdevguide
\item \namedlabel{text:exit_controller} \PseudoParamEntry{Exit controller}
{Controls the exit type from `log\_exit\_type' and \definevariable{text:log_exit_type}{\spirouConst.LOG\_EXIT\_TYPE()}.}
{exit}
{\AllRecipes}{\spirouConst.EXIT()}{\spirouLog}
\fi


% exit levels
\ifdevguide
\item \namedlabel{text:exit_levels} \PseudoParamEntry{Exit levels}
{Controls which levels (defined in \definevariable{text:write_level}{write\_level} and \definevariable{text:trig_keys}{trig\_key}) will lead to the exit statement (given in \definevariable{text:exit_controller}{exit} and \definevariable{text:log_exit_type}{log\_exit\_type}). Values must be a list of strings where each entry must be in \definevariable{text:write_level}{write\_level} and \definevariable{text:trig_keys}{trig\_key}.}
{exit\_levels}
{\AllRecipes}{\spirouConst.EXIT\_LEVELS()}{\spirouLog}
\fi


% log_caught_warnings
\ifdevguide
\item \ParameterEntry{Log caught warnings}
{If True or 1, then if warnings are passed to \spirouLog.warninglogger() and there are warnings present, will attempt to log these warnings using the \spirouLog.logger function. i.e. will print the warning to screen/log file depending on logging settings.}
{log\_caught\_warnings}{True}
{\AllRecipes}{\spirouConst.LOG\_CAUGHT\_WARNINGS()}{\spirouLog}{Private}
\fi

% cmsg
\ifdevguide
\item \PseudoParamEntry{Configuration key error message}
{Defines the message that is used when a configuration key is missing}
{cerrmsg}
{\AllRecipes}{\spirouConst.CONFIG\_KEY\_ERROR}{\spirouLog.get\_logfilepath()}
\fi

% colouredlevels
\ifdevguide
\item \namedlabel{text:colouredlevels} \ParameterEntry{Colour of levels text}
{The text colour for each level in \definevariable{{text:trig_keys}}{trig\_key} and \definevariable{text:write_level}{write\_level}. Value must be a dictionary with the keys identical to the keys in \definevariable{{text:trig_keys}}{trig\_key} and \definevariable{text:write_level}{write\_level}. One can use \definevariable{text:redcolour}{REDCOLOUR()}, \definevariable{text:yellowcolour}{YELLOWCOLOUR()}, \definevariable{text:greencolour}{GREENCOLOUR()} to access the predefined values of red, yellow and green respectively. The default colour is given by \definevariable{text:normalcolour}{NORMALCOLOUR()}.}
{clevels}
{\lstinline[style=pythoninline]| dict(error=red, warning=yellow, info=green, graph=norm, all=green) |}
{\AllRecipes}{\spirouConst.COLOUREDLEVELS()}{\spirouLog.debug\_start(), \spirouLog.printlog()}
\fi

% normalcolour
\ifdevguide
\item \namedlabel{text:normalcolour} \ParameterEntry{Default text colour}
{Defines the string that describes the default text colour (retrieves colour from user). This in turn is turned into the colour defined by the python console/terminal that is default for that user. Value must be a string. This is used at the end of any colour change to set the text colour back to default (otherwise colour will remain until changed).}
{norm}{\lstinline[style=pythoninline]| "\\033[0;37;40m"|}
{\AllRecipes}{\spirouConst.NORMALCOLOUR()}{\spirouConst.COLOUREDLEVELS(), \spirouLog.debug\_start(), \spirouLog.printlog()}
\fi

% redcolour
\ifdevguide
\item \namedlabel{text:redcolour} \ParameterEntry{Red text colour}
{Defines the string that describes the colour "red".}
{red}{\lstinline[style=pythoninline]| "\\033[0;31;48m"|}
{\AllRecipes}{\spirouConst.REDCOLOUR()}{\spirouConst.COLOUREDLEVELS()}
\fi

% yellowcolour
\ifdevguide
\item \namedlabel{text:yellowcolour} \ParameterEntry{Yellow text colour}
{Defines the string that describes the colour "yellow".}
{yellow}{\lstinline[style=pythoninline]| "\\033[0;33;48m"|}
{\AllRecipes}{\spirouConst.YELLOWCOLOUR()}{\spirouConst.COLOUREDLEVELS()}
\fi

% greencolour
\ifdevguide
\item \namedlabel{text:greencolour} \ParameterEntry{Green text colour}
{Defines the string that describes the colour "green".}
{green}{\lstinline[style=pythoninline]| "\\033[0;32;48m"|}
{\AllRecipes}{\spirouConst.GREENCOLOUR()}{\spirouConst.COLOUREDLEVELS()}
\fi

% coloured_log
\item \namedlabel{text:coloured_log} \ParameterEntry{Toggle coloured log}
{Defines whether the log (printed to the standard output) is coloured \ifdevguide according to \definevariable{text:colouredlevels}{clevels} \fi. Value must be True or 1 to colour the log or False or 0 to use the default console colour throughout.}
{COLOURED\_LOG}{True}
{\AllRecipes}{\configtxtfile}{\spirouConst.COLOURED\_LOG()}{Public}

% clog
\ifdevguide
\item \PseudoParamEntry{Coloured log controller}
{Contoller for coloured log (value is set from \definevariable{text:coloured_log}{COLOURED\_LOG})}
{clog}
{\AllRecipes}{\spirouConst.COLOURED\_LOG()}{\spirouLog.debug\_start(), \spirouLog.printlog()}
\fi

\end{itemize}



