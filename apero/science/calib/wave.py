#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
# CODE NAME HERE

# CODE DESCRIPTION HERE

Created on 2019-06-27 at 13:54

@author: cook
"""
from astropy.table import Table
from astropy import constants as cc
from astropy import units as uu
import itertools
import numpy as np
import os
import warnings
import copy

from apero.base import base
from apero import lang
from apero.core import constants
from apero.core import math as mp
from apero.core.core import drs_log, drs_file
from apero.core.utils import drs_data
from apero.core.utils import drs_startup
from apero.core.core import drs_database
from apero.io import drs_table
from apero.io import drs_image
from apero.science import velocity
from apero.science.calib import general
from apero.science import extract
from apero.science.calib import flat_blaze


# =============================================================================
# Define variables
# =============================================================================
__NAME__ = 'science.calib.wave.py'
__INSTRUMENT__ = 'None'
__PACKAGE__ = base.__PACKAGE__
__version__ = base.__version__
__author__ = base.__author__
__date__ = base.__date__
__release__ = base.__release__
# get param dict
ParamDict = constants.ParamDict
DrsFitsFile = drs_file.DrsFitsFile
# Get Logging function
WLOG = drs_log.wlog
# Get the text types
textentry = lang.textentry
# alias pcheck
pcheck = constants.PCheck(wlog=WLOG)
# Speed of light
# noinspection PyUnresolvedReferences
speed_of_light_ms = cc.c.to(uu.m / uu.s).value
# noinspection PyUnresolvedReferences
speed_of_light = cc.c.to(uu.km / uu.s).value
# Get function string
display_func = drs_log.display_func


# =============================================================================
# Define user functions
# =============================================================================
def get_masterwave_filename(params, fiber, database=None):
    """
    Load the master wave solution

    Order of preference: WAVEM_FP >> WAVEM_HC >> WAVEM_D

    :param params:
    :param fiber:
    :param database:
    :return:
    """
    # set function name
    func_name = display_func(params, 'get_masterwave_filename', __NAME__)
    # get pseudo constants
    pconst = constants.pload(params['INSTRUMENT'])
    # deal with fibers that we don't have
    usefiber = pconst.FIBER_WAVE_TYPES(fiber)
    # ------------------------------------------------------------------------
    # load database
    if database is None:
        calibdbm = drs_database.CalibrationDatabase(params)
        calibdbm.load_db()
    else:
        calibdbm = database
    # ------------------------------------------------------------------------
    # get file definition (order of preference)
    keys = ['WAVEM_FP', 'WAVEM_HC', 'WAVEM_D']
    filename = None
    # loop around possible wave master keys
    for k_it in range(len(keys)):
        # first check for wave masters generated by the drs
        out_wave = drs_startup.get_file_definition(keys[k_it],
                                                   params['INSTRUMENT'],
                                                   kind='red', required=False)
        # if out_wave is None we need to check other keys
        if out_wave is None:
            continue
        # get calibration key
        key = out_wave.get_dbkey()
        # ---------------------------------------------------------------------
        # load master key
        filename = calibdbm.get_calib_file(key, no_times=True, nentries=1,
                                           required=False, fiber=usefiber)
        # stop loop if we have found our master file
        if filename is not None:
            break
    # if we still have None we have a problem
    if filename is None:
        eargs = [', '.join(keys), func_name]
        WLOG(params, 'error', textentry('09-017-00007', args=eargs))
    # return the last valid wave entry
    return filename


def get_wave_solution_from_wavefile(params, recipe, usefiber, inwavefile,
                                    header, database=None, master=False):
    # ------------------------------------------------------------------------
    # get file definitions (wave solution FP and wave solution HC)
    out_wave_fp = drs_startup.get_file_definition('WAVEM_FP',
                                                  params['INSTRUMENT'],
                                                  kind='red')
    out_wave_hc = drs_startup.get_file_definition('WAVEM_HC',
                                                  params['INSTRUMENT'],
                                                  kind='red')
    # ------------------------------------------------------------------------
    # deal with master = True
    if master is True:
        # get master path
        inwavefile = get_masterwave_filename(params, fiber=usefiber,
                                             database=database)
        source = 'master'
    else:
        # ---------------------------------------------------------------------
        # setup calib db keys
        # ---------------------------------------------------------------------
        # get calibration key
        key_fp = out_wave_fp.get_dbkey()
        key_hc = out_wave_hc.get_dbkey()
        # ---------------------------------------------------------------------
        if database is None:
            # load the calibration database
            calibdbm = drs_database.CalibrationDatabase(params)
            calibdbm.load_db()
        else:
            calibdbm = database
        # ---------------------------------------------------------------------
        # load filename from inputs/calibDB
        # ---------------------------------------------------------------------
        lkwargs = dict(userinputkey='WAVEFILE', database=calibdbm, key=key_fp,
                       inheader=header, filename=inwavefile, fiber=usefiber,
                       return_filename=True, required=False, return_source=True)
        # load wave fp file
        fout = general.load_calib_file(params, **lkwargs)
        # get filename and source from outputs
        inwavefile, source = fout
        if isinstance(source, str):
            source += '[FP]'
        # ---------------------------------------------------------------------
        # then check hc solution (if we don't have an fp solution filename
        if inwavefile is None:
            # need to re-add filename (may have changed value)
            lkwargs['filename'] = inwavefile
            lkwargs['key'] = key_hc
            # load wave hc file
            fout = general.load_calib_file(params, **lkwargs)
            # get filename and source from outputs
            filename, source = fout
            if isinstance(source, str):
                source += '[FP]'
        # ---------------------------------------------------------------------
        # if inwavefile is still None
        if inwavefile is None:
            # get master path
            inwavefile = get_masterwave_filename(params, fiber=usefiber,
                                                 database=database)
    # -------------------------------------------------------------------------
    # construct new infile instance (first fp solution then hc solutions)
    if out_wave_fp.suffix in str(inwavefile):
        wavefile = out_wave_fp.newcopy(filename=inwavefile, params=params,
                                       fiber=usefiber)
    else:
        wavefile = out_wave_hc.newcopy(filename=inwavefile, params=params,
                                       fiber=usefiber)
    # read data/header
    wavefile.read_file()
    # get wave map
    wavemap = wavefile.get_data(copy=True)
    # set wave source of wave file
    wavesource = source
    # get wave time
    wavetime = wavefile.get_hkey('KW_MID_OBS_TIME', dtype=float,
                                 has_default=True, default=0.0)
    # return to main get_wave function
    return wavefile, wavemap, wavesource, wavetime


def get_wave_solution_from_inheader(params, recipe, infile, header, usefiber):
    # set function
    func_name = display_func(params, 'get_wave_solution_from_inheader',
                             __NAME__)
    # ------------------------------------------------------------------------
    # type 1: just from header
    if infile is None:
        # get keywords from params
        outputkey = params['KW_OUTPUT'][0]
        dprtypekey = params['KW_DPRTYPE'][0]
        # first see if we are dealing with a reduced file
        if outputkey in header:
            # get filetype from header (KW_OUTPUT)
            filetype = header[outputkey]
            # set kind
            kind = 'red'
        # else we can't have a wavelength solution
        else:
            # get filetype from header (dprtype)
            filetype = header[dprtypekey]
            # log error
            eargs = [outputkey, dprtypekey, filetype, func_name]
            WLOG(params, 'error', textentry('00-017-00008', args=eargs))
            kind = None
        # get wave file instance
        wavefile = drs_startup.get_file_definition(filetype,
                                                   params['INSTRUMENT'],
                                                   kind=kind, fiber=usefiber)
        # set wave file properties (using header)
        wavefile.recipe = recipe
        wavefile.header = header
        wavefile.filename = header[params['KW_WAVEFILE'][0]]
        # if we have a wave time use it
        if params['KW_WAVETIME'][0] in header:
            wavetime = header[params['KW_WAVETIME'][0]]
        else:
            wavetime = header[params['KW_MID_OBS_TIME'][0]]
        # set the wave file data
        wavefile.data = np.zeros((header['NAXIS2'], header['NAXIS1']))
        # set the source as header
        wavesource = 'header'
        # get wave map
        wavemap = None
    # ------------------------------------------------------------------------
    # type 2: from infile DrsFitsFile
    else:
        wavefile = infile.completecopy(infile)
        # set the file name to the wave file
        wavefile.filename = wavefile.get_hkey('KW_WAVEFILE')
        # if we have a wave time use it
        if params['KW_WAVETIME'][0] in header:
            wavetime = wavefile.get_hkey('KW_WAVETIME')
        else:
            wavetime = wavefile.get_hkey('KW_MID_OBS_TIME', dtype=float,
                                         has_default=True, default=0.0)
        # wave source is the infile
        wavesource = 'infile'
        # get wave map
        wavemap = None
    # ------------------------------------------------------------------------
    return wavefile, wavemap, wavesource, wavetime


def get_wavesolution(params, recipe, header=None, infile=None, fiber=None,
                     master=False, database=None, **kwargs):
    """
    Get the wavelength solution

    1. From file (if "filename" set in call)
    2. From file (if --wavefile set in sys.argv from params['INPUTS'])
    3. From calibDB if force=True or master=True or keys missing from
       infile/header
    4. From header if not None and keys present
    5. From infile if not None and keys present

    :param params: parameter dictionary, ParamDict containing constants
    :param recipe: DrsRecipe instance, the recipe instance used
    :param header: FitsHeader or None, the header to use
    :param infile: DrsFitsFile or None, the infile associated with the header
                   can be used instead of header
    :param fiber: str, the fiber to get the wave solution for
    :param master: bool, if True forces use of the master wavelength solution
    :param kwargs: keyword arguments passed to function

    :keyword force: bool, if True forces wave solution to come from calibDB
    :keyword filename: str or None, the filename to get wave solution from
                       this will overwrite all other options
    :return:
    """
    # set function name
    func_name = display_func(params, 'get_wavesolution', __NAME__)
    # get parameters from params/kwargs
    inwavefile = kwargs.get('filename', None)
    force = pcheck(params, 'CALIB_DB_FORCE_WAVESOL', 'force', kwargs,
                   func_name)
    # ------------------------------------------------------------------------
    # get pseudo constants
    pconst = constants.pload(params['INSTRUMENT'])
    # deal with which fiber to use
    if kwargs.get('forcefiber', False):
        usefiber = str(fiber)
    elif master:
        usefiber = pconst.FIBER_WAVE_TYPES(fiber)
    else:
        usefiber = str(fiber)
    # ------------------------------------------------------------------------
    # deal with infile vs header (need one for either forced or unforced)
    #    exception is when we are getting a master
    # ------------------------------------------------------------------------
    # check infile is instance of DrsFitsFile
    if infile is not None:
        if not isinstance(infile, drs_file.DrsFitsFile):
            eargs = [type(infile), func_name]
            WLOG(params, 'error', textentry('00-017-00001', args=eargs))
    # ------------------------------------------------------------------------
    # deal with no header but an infile
    if header is None and infile is not None:
        header = infile.get_header()
    # we need a header unless master is True
    if not master and header is None:
        WLOG(params, 'error', textentry('00-017-00009', args=[func_name]))
    # ------------------------------------------------------------------------
    # Get in wave file
    # ------------------------------------------------------------------------
    # check whether we need to force from database
    force = force or master
    if master is False:
        force = force or (params['KW_WAVE_NBO'][0] not in header)
        force = force or (params['KW_WAVE_DEG'][0] not in header)
        force = force or (params['KW_CDBWAVE'][0] not in header)
        # deal with header having different fiber value that usefiber
        if not force and (params['KW_FIBER'][0] in header):
            if header[params['KW_FIBER'][0]] != usefiber:
                force = True
    # ------------------------------------------------------------------------
    # Mode 1: forced from input filename or calibDB i.e. from a wave file
    # ------------------------------------------------------------------------
    if force:
        wargs = [usefiber, inwavefile, header, database, master]
        wout = get_wave_solution_from_wavefile(params, recipe, *wargs)
        wavefile, wavemap, wavesource, wavetime = wout
    # ------------------------------------------------------------------------
    # Mode 2: using header or infile only i.e. from the input files header
    # ------------------------------------------------------------------------
    else:
        wargs = [infile, header, usefiber]
        wout = get_wave_solution_from_inheader(params, recipe, *wargs)
        wavefile, wavemap, wavesource, wavetime = wout
    # ------------------------------------------------------------------------
    # Log progress
    # -------------------------------------------------------------------------
    wargs = [wavesource, wavefile.filename]
    WLOG(params, '', textentry('40-017-00036', args=wargs))
    # ------------------------------------------------------------------------
    # Now deal with using wavefile
    # -------------------------------------------------------------------------
    # wavefile must have params set
    wavefile.params = params
    # extract keys from header
    nbo = wavefile.get_hkey('KW_WAVE_NBO', dtype=int)
    deg = wavefile.get_hkey('KW_WAVE_DEG', dtype=int)
    # get the wfp keys
    wfp_file = wavefile.get_hkey('KW_WFP_FILE', dtype=str,
                                         required=False)
    wfp_drift = wavefile.get_hkey('KW_WFP_DRIFT', dtype=float,
                                         required=False)
    wfp_fwhm = wavefile.get_hkey('KW_WFP_FWHM', dtype=float,
                                        required=False)
    wfp_contrast = wavefile.get_hkey('KW_WFP_CONTRAST', dtype=float,
                                            required=False)
    wfp_mask = wavefile.get_hkey('KW_WFP_MASK', dtype=float,
                                        required=False)
    wfp_lines = wavefile.get_hkey('KW_WFP_LINES', dtype=float,
                                         required=False)
    wfp_target_rv = wavefile.get_hkey('KW_TARG_RV', dtype=float,
                                             required=False)
    wfp_width = wavefile.get_hkey('KW_WFP_WIDTH', dtype=float,
                                         required=False)
    wfp_step = wavefile.get_hkey('KW_WFP_STEP', dtype=float,
                                        required=False)
    # extract cofficients from header
    wave_coeffs = wavefile.get_hkey_2d('KW_WAVECOEFFS',
                                       dim1=nbo, dim2=deg + 1)
    # -------------------------------------------------------------------------
    # if wavemap is unset create it from wave coefficients
    if wavemap is None:
        # get image dimensions
        if infile is not None:
            nby, nbx = infile.get_data().shape
        else:
            nby, nbx = header['NAXIS2'], header['NAXIS1']
        wavemap = get_wavemap_from_coeffs(wave_coeffs, nbo, nbx)
    # -------------------------------------------------------------------------
    # store wave properties in parameter dictionary
    wprops = ParamDict()
    wprops['WAVEFILE'] = wavefile.filename
    wprops['WAVEINIT'] = wavefile.filename
    wprops['WAVESOURCE'] = wavesource
    wprops['NBO'] = nbo
    if wavemap is not None:
        wprops['NBPIX'] = wavemap.shape[1]
    else:
        wprops['NBPIX'] = None
    wprops['DEG'] = deg
    wprops['COEFFS'] = wave_coeffs
    wprops['WAVEMAP'] = wavemap
    wprops['WAVEINST'] = wavefile.completecopy(wavefile)
    wprops['WAVETIME'] = wavetime
    # add the wfp keys
    wfp_keys = ['WFP_FILE', 'WFP_DRIFT', 'WFP_FWHM', 'WFP_CONTRAST', 'WFP_MASK',
                'WFP_LINES', 'WFP_TARG_RV', 'WFP_WIDTH', 'WFP_STEP']
    wfp_values = [wfp_file, wfp_drift, wfp_fwhm, wfp_contrast, wfp_mask,
                  wfp_lines, wfp_target_rv, wfp_width, wfp_step]
    # add keys accounting for 'None' and blanks
    for wfpi in range(len(wfp_keys)):
        if wfp_values[wfpi] == '' or wfp_values[wfpi] == 'None':
            wprops[wfp_keys[wfpi]] = None
        else:
            wprops[wfp_keys[wfpi]] = wfp_values[wfpi]
    # set the source
    keys = ['WAVEMAP', 'WAVEFILE', 'WAVEINIT', 'WAVESOURCE', 'NBO', 'DEG',
            'COEFFS', 'WAVETIME', 'WAVEINST', 'NBPIX'] + wfp_keys
    wprops.set_sources(keys, func_name)
    # -------------------------------------------------------------------------
    # return the map and properties
    return wprops


def get_wavemap_from_coeffs(wave_coeffs, nbo, nbx):
    # set up storage
    wavemap = np.zeros((nbo, nbx))
    xpixels = np.arange(nbx)
    # loop aroun each order
    for order_num in range(nbo):
        # get this order coefficients
        ocoeffs = wave_coeffs[order_num][::-1]
        # calculate polynomial values and push into wavemap
        wavemap[order_num] = np.polyval(ocoeffs, xpixels)
    return wavemap


def get_wavelines(params, recipe, fiber, header=None, infile=None,
                  database=None, **kwargs):
    # set up function name
    func_name = display_func(params, 'get_wavelines', __NAME__)
    # get psuedo constants
    pconst = constants.pload(params['INSTRUMENT'])
    # get parameters from params/kwargs
    hclinefile = kwargs.get('hclinefile', None)
    fplinefile = kwargs.get('fplinefile', None)
    required = kwargs.get('required', True)
    # deal with fibers that we don't have
    usefiber = pconst.FIBER_WAVE_TYPES(fiber)
    # ------------------------------------------------------------------------
    # load database
    if database is None:
        calibdbm = drs_database.CalibrationDatabase(params)
        calibdbm.load_db()
    else:
        calibdbm = database
    # ------------------------------------------------------------------------
    # log progress
    WLOG(params, '', textentry('40-017-00040'))
    # ------------------------------------------------------------------------
    # check infile is instance of DrsFitsFile
    if infile is not None:
        if not isinstance(infile, drs_file.DrsFitsFile):
            eargs = [type(infile), func_name]
            WLOG(params, 'error', textentry('00-017-00001', args=eargs))
    # ------------------------------------------------------------------------
    # deal with no header but an infile
    if header is None and infile is not None:
        header = infile.get_header()
    # deal with still having no header
    if header is None:
        # log error: header not defined.
        eargs = [func_name]
        WLOG(params, 'error', textentry('00-017-00009', args=eargs))
    # ------------------------------------------------------------------------
    # get file definitions (wave solution FP and wave solution HC)
    out_wave_fp = drs_startup.get_file_definition('WAVE_FPLIST_MASTER',
                                                  params['INSTRUMENT'],
                                                  kind='red')
    out_wave_hc = drs_startup.get_file_definition('WAVE_HCLIST_MASTER',
                                                  params['INSTRUMENT'],
                                                  kind='red')
    # get calibration key
    key_fp = out_wave_fp.get_dbkey()
    key_hc = out_wave_hc.get_dbkey()
    # ------------------------------------------------------------------------
    # get hc lines
    # ------------------------------------------------------------------------
    lkwargs = dict(database=calibdbm, fiber=usefiber, return_filename=True,
                   inheader=header)

    hclinefile = general.load_calib_file(params, key_hc,  filename=hclinefile,
                                         userinputkey='HCLINEFILE', **lkwargs)
    # construct new infile instance
    hclfile = out_wave_fp.newcopy(filename=hclinefile, params=params,
                                  fiber=usefiber)
    # read data/header
    hclfile.read_file()
    # get wave map
    hclines = hclfile.get_data(copy=True)
    # set wave source of wave file
    hcsource = hclfile.filename
    # ------------------------------------------------------------------------
    # get fp lines
    # ------------------------------------------------------------------------
    fplinefile = general.load_calib_file(params, key_fp,  filename=fplinefile,
                                         userinputkey='FPLINEFILE', **lkwargs)
    # construct new infile instance
    fplfile = out_wave_fp.newcopy(filename=fplinefile, params=params,
                                  fiber=usefiber)
    # read data/header
    fplfile.read_file()
    # get wave map
    fplines = fplfile.get_data(copy=True)
    # set wave source of wave file
    fpsource = fplfile.filename
    # ------------------------------------------------------------------------
    # return the lines and sources
    return hclines, hcsource, fplines, fpsource


def add_wave_keys(params, infile, props):
    # set function name
    _ = display_func(params, 'add_wave_keys', __NAME__)
    # add wave parameters
    infile.add_hkey('KW_WAVEFILE', value=props['WAVEFILE'])
    infile.add_hkey('KW_WAVETIME', value=props['WAVETIME'])
    infile.add_hkey('KW_WAVESOURCE', value=props['WAVESOURCE'])
    infile.add_hkey('KW_WAVE_NBO', value=props['NBO'])
    infile.add_hkey('KW_WAVE_DEG', value=props['DEG'])
    infile.add_hkey_2d('KW_WAVECOEFFS', values=props['COEFFS'],
                       dim1name='order', dim2name='coeffs')
    # add wave fp parameters
    infile.add_hkey('KW_WFP_FILE', value=props['WFP_FILE'])
    infile.add_hkey('KW_WFP_DRIFT', value=props['WFP_DRIFT'])
    infile.add_hkey('KW_WFP_FWHM', value=props['WFP_FWHM'])
    infile.add_hkey('KW_WFP_CONTRAST', value=props['WFP_CONTRAST'])
    infile.add_hkey('KW_WFP_MASK', value=props['WFP_MASK'])
    # WFP_LINES should be a list of ints or None or 'None'
    #     (deal with it either way)
    if props['WFP_LINES'] is None:
        infile.add_hkey('KW_WFP_LINES', None)
    elif isinstance(props['WFP_LINES'], str):
        infile.add_hkey('KW_WFP_LINES', value=props['WFP_LINES'])
    else:
        infile.add_hkey('KW_WFP_LINES', value=mp.nansum(props['WFP_LINES']))
    infile.add_hkey('KW_WFP_TARG_RV', value=props['WFP_TARG_RV'])
    infile.add_hkey('KW_WFP_WIDTH', value=props['WFP_WIDTH'])
    infile.add_hkey('KW_WFP_STEP', value=props['WFP_STEP'])
    # return infile
    return infile


def check_wave_consistency(params, props, **kwargs):
    func_name = display_func(params, 'check_wave_consistency', __NAME__)
    # get constants from params/kwargs
    required_deg = pcheck(params, 'WAVE_FIT_DEGREE', 'num_coeffs', kwargs,
                          func_name)
    # get dimension from data
    nbo, ncoeffs = props['COEFFS'].shape
    # get the fit degree from dimensions
    deg = ncoeffs - 1
    # check dimensions
    if required_deg == deg:
        # log that fit degrees match
        WLOG(params, '', textentry('40-017-00002', args=[deg]))
    # if not correct remap coefficients
    else:
        # log that fit degrees don't match
        wargs = [deg, required_deg]
        WLOG(params, 'warning', textentry('10-017-00003', args=wargs))
        # setup output storage
        output_coeffs = np.zeros([nbo, required_deg + 1])
        output_map = np.zeros_like(props['WAVEMAP'])
        # define pixel array
        xfit = np.arange(output_map.shape[1])
        # loop around each order
        for order_num in range(nbo):
            # get the wave map for this order
            yfit = np.polyval(props['COEFFS'][order_num][::-1], xfit)
            # get the new coefficients based on a fit to this wavemap
            coeffs = mp.nanpolyfit(xfit, yfit, required_deg)[::-1]
            # push into storage
            output_coeffs[order_num] = coeffs
            output_map[order_num] = yfit
        # update props
        props['WAVEMAP'] = output_map
        props['COEFFS'] = output_coeffs
        props['DEG'] = required_deg
        props.set_sources(['WAVEMAP', 'COEFFS', 'DEG'], func_name)
    # return props
    return props


# =============================================================================
# Define wave ref functions
# =============================================================================
def get_master_lines(params, recipe, e2dsfile, wavemap, cavity_poly=None,
                     hclines=None, fplines=None, **kwargs):
    # set the function name
    func_name = display_func(params, 'get_master_lines', __NAME__)
    # get parameters from params and kwargs
    nsig_min = pcheck(params, 'WAVEREF_NSIG_MIN', 'nsig_min', kwargs, func_name)
    wmax = pcheck(params, 'WAVEREF_EDGE_WMAX', 'wmax', kwargs, func_name)
    hcboxsize = pcheck(params, 'WAVEREF_HC_BOXSIZE', 'hcboxsize', kwargs,
                       func_name)
    hcfibtypes = pcheck(params, 'WAVEREF_HC_FIBTYPES', 'hcfibtypes', kwargs,
                        func_name, mapf='list', dtype=str)
    fpfibtypes = pcheck(params, 'WAVEREF_FP_FIBTYPES', 'fpfibtypes', kwargs,
                        func_name, mapf='list', dtype=str)
    fitdeg = pcheck(params, 'WAVEREF_FITDEG', 'fitdeg', kwargs, func_name)
    fp_nlow = pcheck(params, 'WAVEREF_FP_NLOW', 'fp_nlow', kwargs,
                     func_name)
    fp_nhigh = pcheck(params, 'WAVEREF_FP_NHIGH', 'fp_nhigh', kwargs,
                      func_name)
    fp_inv_itr = pcheck(params, 'WAVEREF_FP_POLYINV', 'fp_inv_itr', kwargs,
                        func_name)
    iteration = kwargs.get('iteration', None)

    # ------------------------------------------------------------------
    # get psuedo constants
    pconst = constants.pload(params['INSTRUMENT'])
    # get the shape from the wavemap
    nbo, nbpix = wavemap.shape
    # get dprtype
    dprtype = e2dsfile.get_hkey('KW_DPRTYPE', dtype=str)
    # get fiber type
    fiber = e2dsfile.get_hkey('KW_FIBER', dtype=str)
    # get fiber type
    fibtype = pconst.FIBER_DPR_POS(dprtype, fiber)
    # set up the xpixels
    xpix = np.arange(nbpix)

    # ----------------------------------------------------------------------
    # get the lines for HC files from hclines input
    # ----------------------------------------------------------------------
    if hclines is not None:
        list_waves = hclines['WAVE_REF']
        list_orders = hclines['ORDER']
        list_pixels = hclines['PIXEL_REF']
        list_wfit = hclines['WFIT']
        peak_number = hclines['PEAK_NUMBER']

    # ----------------------------------------------------------------------
    # get the lines for HC files from fplines input
    # ----------------------------------------------------------------------
    elif fplines is not None:
        list_waves = fplines['WAVE_REF']
        list_orders = fplines['ORDER']
        list_pixels = fplines['PIXEL_REF']
        list_wfit = fplines['WFIT']
        peak_number = fplines['PEAK_NUMBER']

    # ----------------------------------------------------------------------
    # get the lines for HC files
    # ----------------------------------------------------------------------
    elif fibtype in hcfibtypes:
        # print progress Running get ref lines for HC
        WLOG(params, 'info', textentry('40-017-00049'))
        # load the line list
        wavell, ampll = drs_data.load_linelist(params)
        # storage for outputs
        list_waves, list_orders, list_pixels = [], [], []
        # loop around orders and get the lines that fall within each
        #    diffraction order
        for order_num in range(nbo):
            # we have a wavelength value, we get an approximate pixel
            # value by fitting wavelength to pixel
            owave = wavemap[order_num]
            with warnings.catch_warnings(record=True) as _:
                fit_reverse = np.polyfit(owave, xpix, fitdeg)
            # we find lines within the order
            good = (wavell > np.min(owave)) & (wavell < np.max(owave))
            # we check that there is at least 1 line and append our line list
            if np.sum(good) != 0:
                # get the pixels positions based on out owave fit
                pixfit = np.polyval(fit_reverse, wavell[good])
                # append lists
                list_waves += list(wavell[good])
                list_orders += list(np.repeat(order_num, np.sum(good)))
                list_pixels += list(pixfit)
        # make line lists np arrays
        list_waves = np.array(list_waves)
        list_orders = np.array(list_orders)
        list_pixels = np.array(list_pixels)
        # keep lines that are  not too close to image edge
        keep = (list_pixels > wmax) & (list_pixels < (nbpix - wmax))
        # apply to list arrays
        list_waves = list_waves[keep]
        list_orders = list_orders[keep]
        list_pixels = list_pixels[keep]
        # set wfit to a constant for HC
        list_wfit = np.repeat(hcboxsize, len(list_pixels))

        # just for the sake of consistency, we need to attribute a fractional
        # FP cavity number to HC peaks. This ensures that the table saved at
        # then end of this code has the same format as for FPs.
        peak_number = np.repeat(np.nan, len(list_pixels))

    # ----------------------------------------------------------------------
    # get the lines for FP files
    # ----------------------------------------------------------------------
    elif fibtype in fpfibtypes:
        # print progress Running get ref lines for FP
        WLOG(params, 'info', textentry('40-017-00050'))
        # ------------------------------------------------------------------
        # deal with getting cavity poly
        if cavity_poly is not None:
            cavity_length_poly = np.array(cavity_poly)
        else:
            # load the cavity polynomial from file
            _, fit_ll = drs_data.load_cavity_files(params)
            cavity_length_poly = fit_ll
        # ------------------------------------------------------------------
        # range of the N FP peaks
        nth_peak = np.arange(fp_nlow, fp_nhigh)
        # storage for the wavelength centers
        wave0 = np.ones_like(nth_peak, dtype=float)
        # start the wave inversion of the polynomial at a sensible value
        wave0 = wave0 * np.nanmean(wavemap)
        # need a few iterations to invert polynomial relations
        for _ in range(fp_inv_itr):
            wave0 = np.polyval(cavity_length_poly, wave0)
            wave0 = wave0 * 2 / nth_peak
        # keep lines within the master_wavelength domain
        keep = (wave0 > np.min(wavemap)) & (wave0 < np.max(wavemap))
        wave0 = wave0[keep]
        # sort by wavelength
        wave0 = wave0[np.argsort(wave0)]
        # storage for outputs
        list_waves, list_orders, list_pixels, list_wfit = [], [], [], []
        # loop around orders and get the lines that fall within each
        #    diffraction order
        for order_num in range(nbo):
            # we have a wavelength value, we get an approximate pixel
            # value by fitting wavelength to pixel
            owave = wavemap[order_num]
            with warnings.catch_warnings(record=True) as _:
                # fit_reverse = np.polyfit(owave, xpix, fitdeg)

                ord_owave = np.argsort(owave)
                spline_fit_reverse = mp.iuv_spline(owave[ord_owave],
                                                   xpix[ord_owave])

            # we find lines within the order
            good = (wave0 > np.min(owave)) & (wave0 < np.max(owave))
            # we check that there is at least 1 line and append our line list
            if np.sum(good) != 0:
                # get the pixels positions based on out owave fit
                # pixfit = np.polyval(fit_reverse, wave0[good])
                pixfit = spline_fit_reverse(wave0[good])
                # get the dpix coeffs
                dpixc = np.polyfit(pixfit[1:], pixfit[1:] - pixfit[:-1], 2)
                # use this to get the rounded width?
                wfit = np.ceil(np.polyval(dpixc, pixfit))
                # append to the lists
                list_waves += list(wave0[good])
                list_orders += list(np.repeat(order_num, np.sum(good)))
                list_pixels += list(pixfit)
                list_wfit += list(wfit)
        # make line lists np arrays
        list_waves = np.array(list_waves)
        list_orders = np.array(list_orders)
        list_pixels = np.array(list_pixels)
        list_wfit = np.array(list_wfit, dtype=int)
        # keep lines that are  not too close to image edge
        keep = (list_pixels > wmax) & (list_pixels < (nbpix - wmax))
        # apply to list arrays
        list_waves = list_waves[keep]
        list_orders = list_orders[keep]
        list_pixels = list_pixels[keep]
        list_wfit = list_wfit[keep]

        # Once we have a cavity length, we find the integer FP peak number.
        # This will be compiled in the table later and used for nightly
        # wavelength solutions by changing the achromatic part of the cavity
        # length relative to the master night. By construction, this is
        # always an integer. The factor 2 comes from the FP equation.
        # It arrises from the back-and-forth within the FP cavity
        cavfit = np.polyval(cavity_length_poly, list_waves)
        peak_number = np.array(cavfit * 2 / list_waves, dtype=int)

    # ----------------------------------------------------------------------
    # else we break
    # ----------------------------------------------------------------------
    else:
        # log error and break
        eargs = [e2dsfile.name, dprtype, fiber, func_name, hcfibtypes,
                 fpfibtypes]
        WLOG(params, 'error', textentry('00-017-00012', args=eargs))
        list_waves = []
        list_orders = []
        list_pixels = []
        list_wfit = []
        peak_number = []

    # ----------------------------------------------------------------------
    # Fit the peaks
    # ----------------------------------------------------------------------
    # set up storage
    pixel_m = np.array(list_pixels)
    wave_m = np.zeros_like(list_waves)
    ewidth = np.zeros_like(list_pixels)
    amp = np.zeros_like(list_pixels)
    nsig = np.repeat(np.nan, len(list_pixels))

    # ----------------------------------------------------------------------
    # loop around orders
    for order_num in range(nbo):
        # get the order spectrum
        sorder = e2dsfile.get_data()[order_num]
        # find all lines in this order
        good = np.where(list_orders == order_num)[0]
        # get order lines
        order_waves = list_waves[good]
        order_pixels = list_pixels[good]
        order_wfit = list_wfit[good]
        # ------------------------------------------------------------------
        # loop around lines
        valid_lines = 0
        for it in range(len(order_waves)):
            # get the x pixel position
            xpixi = int(np.round(order_pixels[it]))
            # get the width
            wfit = int(np.round(order_wfit[it]))
            # get the pixels within this peak
            index = np.arange(xpixi - wfit, xpixi + wfit + 1)
            # Need to check that index is in bounds
            if (np.min(index) < 0) or (np.max(index) >= nbpix):
                eargs = [order_num, it, index, xpixi, wfit, func_name]
                WLOG(params, 'warning', textentry('09-017-00005', args=eargs))
                continue
            # get the flux value in this peak
            ypix = sorder[index]
            # deal with less points than fit (shouldn't happen but worth
            #    catching before an exception happens in fit_gauss_with_slope)
            if len(ypix) < 5:
                eargs = [order_num, it, index, ypix]
                WLOG(params, 'warning', textentry('09-017-00006', args=eargs))
                continue
            # --------------------------------------------------------------
            # only continue if we have some finite values
            if np.all(np.isfinite(ypix)):
                # try fitting a gaussian with a slope
                try:
                    # get ypix max and min
                    ymax, ymin = mp.nanmax(ypix), mp.nanmin(ypix)
                    # get up a gauss fit guess
                    guess = [ymax - ymin, xpixi, 1, ymin, 0]
                    # if HC fit a gaussian with a slope
                    if fibtype in hcfibtypes:
                        out = mp.fit_gauss_with_slope(index, ypix, guess, True)
                        # get parameters from fit
                        popt, pcov, model = out
                        # get width condition
                        cond2 = (popt[2] < 2) and (popt[2] > 0.5)
                    # else fit ea airy function to FP
                    else:
                        out = velocity.fit_fp_peaks(index, ypix, wfit,
                                                    return_model=True)
                        # get parameters from fit
                        p0, popt, pcov, warns, model = out
                        # get width condition
                        cond2 = np.abs(popt[2] / wfit - 1) < 0.5
                    # calculate the RMS of the fit
                    rms = mp.nanstd(ypix - model)
                    # if we find 'good' values add to storage
                    cond1 = np.abs(popt[1] - xpixi) < wfit
                    if cond1 and cond2:
                        amp[good[it]] = popt[0]
                        pixel_m[good[it]] = popt[1]
                        ewidth[good[it]] = popt[2]
                        nsig[good[it]] = popt[0] / rms
                        # line is valid
                        valid_lines += 1
                # ignore any bad lines
                except RuntimeError:
                    pass
        # log progress: Order {0}/{1} Fiber {2} Valid lines: {3}/{4} (type={5})
        eargs = [order_num, nbo - 1, fiber, valid_lines, len(order_waves),
                 fibtype]
        WLOG(params, '', textentry('40-017-00051', args=eargs))

    # lines that are not at a high enough SNR are flagged as NaN
    # we do NOT remove these lines as we want all tables to have
    # exactly the same length
    with warnings.catch_warnings(record=True) as _:
        bad = ~(nsig > nsig_min)
    nsig[bad] = np.nan
    ewidth[bad] = np.nan
    amp[bad] = np.nan
    pixel_m[bad] = np.nan
    wave_m[bad] = np.nan
    # calculate the difference
    diffpix = pixel_m - list_pixels

    # ----------------------------------------------------------------------
    # Plot the expected lines vs measured line positions
    # ----------------------------------------------------------------------
    # debug plot expected lines vs measured positions
    recipe.plot('WAVEREF_EXPECTED', orders=list_orders, wavemap=list_waves,
                diff=diffpix, fiber=fiber, nbo=nbo, fibtype=fibtype,
                iteration=iteration)

    # ----------------------------------------------------------------------
    # Create table to store them in
    # ----------------------------------------------------------------------
    columnnames = ['WAVE_REF', 'WAVE_MEAS', 'PIXEL_REF', 'PIXEL_MEAS',
                   'ORDER', 'WFIT', 'EWIDTH_MEAS', 'AMP_MEAS', 'NSIG',
                   'DIFF', 'PEAK_NUMBER']
    columnvalues = [list_waves, wave_m, list_pixels, pixel_m, list_orders,
                    list_wfit, ewidth, amp, nsig, diffpix, peak_number]
    # make table
    table = drs_table.make_table(params, columnnames, columnvalues)
    # return table
    return table


def write_master_lines(params, recipe, hce2ds, fpe2ds, hclines, fplines,
                       fpwavefile, fiber):
    # set function name
    _ = display_func(params, 'write_master_lines', __NAME__)
    # ------------------------------------------------------------------
    # write hc lines
    # ------------------------------------------------------------------
    # get copy of instance of wave file (WAVE_HCMAP)
    hcfile = recipe.outputs['WAVEM_HCLIST'].newcopy(params=params,
                                                    fiber=fiber)
    # construct the filename from file instance
    hcfile.construct_filename(infile=hce2ds)
    # ------------------------------------------------------------------
    # copy keys from hcwavefile
    hcfile.copy_hdict(fpwavefile)
    # set output key
    hcfile.add_hkey('KW_OUTPUT', value=hcfile.name)
    # set data
    hcfile.data = hclines
    hcfile.datatype = 'table'
    # ------------------------------------------------------------------
    # log that we are saving rotated image
    wargs = [fiber, hcfile.filename]
    WLOG(params, '', textentry('40-017-00039', args=wargs))
    # write image to file
    hcfile.write_file(kind=recipe.outputtype, runstring=recipe.runstring)
    # add to output files (for indexing)
    recipe.add_output_file(hcfile)
    # ------------------------------------------------------------------
    # write fp lines
    # ------------------------------------------------------------------
    # get copy of instance of wave file (WAVE_HCMAP)
    fpfile = recipe.outputs['WAVEM_FPLIST'].newcopy(params=params,
                                                    fiber=fiber)
    # construct the filename from file instance
    fpfile.construct_filename(infile=fpe2ds)
    # ------------------------------------------------------------------
    # copy keys from hcwavefile
    fpfile.copy_hdict(fpwavefile)
    # set output key
    fpfile.add_hkey('KW_OUTPUT', value=fpfile.name)
    # set data
    fpfile.data = fplines
    fpfile.datatype = 'table'
    # ------------------------------------------------------------------
    # log that we are saving rotated image
    wargs = [fiber, fpfile.filename]
    WLOG(params, '', textentry('40-017-00039', args=wargs))
    # write image to file
    fpfile.write_file(kind=recipe.outputtype, runstring=recipe.runstring)
    # add to output files (for indexing)
    recipe.add_output_file(fpfile)
    # ------------------------------------------------------------------
    # return hc  and fp line files
    return hcfile, fpfile


def update_wavelength_measured(params, reftable, wavemap, kind):
    """
    Update a line table with a wavelength solution

    Takes the measured pixel values and splines the wavelength solution to
    derive the equivalent measured wavelengths

    :param params:
    :param reftable:
    :param wavemap:
    :param kind:

    :return:
    """
    # set function name
    func_name = display_func(params, 'update_wavelength_measured', __NAME__)
    # check columns for table
    keys = ['ORDER', 'PIXEL_MEAS', 'WAVE_MEAS']
    for key in keys:
        if key not in reftable.colnames:
            eargs = [key, kind, func_name]
            WLOG(params, 'error', textentry('00-017-00011', args=eargs))
            return None
    # get columns from table
    orders = reftable['ORDER']
    pix_measured = reftable['PIXEL_MEAS']
    wave_measured = reftable['WAVE_MEAS']

    # loop around orders
    for order_num in np.unique(orders):
        # index array
        indices = np.arange(len(wavemap[order_num]))
        # find all lines in this order
        good = (order_num == orders) & np.isfinite(pix_measured)
        # create spline for these lines
        spline = mp.iuv_spline(indices, wavemap[order_num])
        # add values for each line
        wave_measured[good] = spline(pix_measured[good])
    # push measured wavelength back into table
    reftable['WAVE_MEAS'] = wave_measured
    # return table
    return reftable


# =============================================================================
# Define wave solution functions
# =============================================================================
def hc_wavesol(params, recipe, iprops, e2dsfile, blaze, fiber, **kwargs):
    # set function name
    func_name = display_func(params, 'hc_wavesol', __NAME__)
    # get parameters from params / kwargs
    wave_mode_hc = pcheck(params, 'WAVE_MODE_HC', 'wave_mode_hc', kwargs,
                          func_name)
    try:
        wave_mode_hc = int(wave_mode_hc)
    except ValueError:
        pass
    # log the mode which is being used
    WLOG(params, 'info', textentry('40-017-00014', args=[wave_mode_hc]))

    # ----------------------------------------------------------------------
    # Read UNe solution
    # ----------------------------------------------------------------------
    wavell, ampll = drs_data.load_linelist(params, **kwargs)
    # ----------------------------------------------------------------------
    # Generate wave map from wave solution
    #     (with possible intercept/slope shift)
    # ----------------------------------------------------------------------
    # TODO: Revisit use of this
    iprops = generate_shifted_wave_map(params, iprops, **kwargs)
    # ----------------------------------------------------------------------
    # Create new wavelength solution (method 0, old cal_HC_E2DS_EA)
    # ----------------------------------------------------------------------
    if wave_mode_hc == 0:
        llprops = hc_wavesol_ea(params, recipe, iprops, e2dsfile, fiber,
                                wavell, ampll)
    else:
        # log that mode is not currently supported
        WLOG(params, 'error', textentry('09-017-00001', args=[wave_mode_hc]))
        llprops = None
    # ----------------------------------------------------------------------
    # add mode to llprops
    llprops['WAVE_MODE_HC'] = wave_mode_hc
    llprops.set_source('WAVE_MODE_HC', func_name)
    # ------------------------------------------------------------------
    # LITTROW SECTION - common to all methods
    # ------------------------------------------------------------------
    # set up hc specific terms
    start = pcheck(params, 'WAVE_LITTROW_ORDER_INIT_1')
    end = pcheck(params, 'WAVE_LITTROW_ORDER_FINAL_1')
    wavell = llprops['LL_OUT_1']
    # run littrow test
    llprops = littrow(params, recipe, llprops, start, end, wavell, e2dsfile,
                      blaze, iteration=1, fiber=fiber)
    # ------------------------------------------------------------------
    # get copy of instance of wave file (WAVE_HCMAP)
    # TODO: remove if once we only use cal_wave or cal_wave_master/night
    if 'WAVEM_HCMAP' in recipe.outputs:
        wavefile = recipe.outputs['WAVEM_HCMAP'].newcopy(params=params,
                                                         fiber=fiber)
    else:
        wavefile = recipe.outputs['WAVE_HCMAP'].newcopy(params=params,
                                                        fiber=fiber)
    # construct the filename from file instance
    wavefile.construct_filename(infile=e2dsfile)
    # ----------------------------------------------------------------------
    # set wprops values (expected for output)
    wprops = ParamDict()
    wprops['WAVEFILE'] = wavefile.filename
    wprops['WAVETIME'] = e2dsfile.get_hkey('KW_MID_OBS_TIME', dtype=float)
    wprops['WAVESOURCE'] = recipe.name + 'HC'
    wprops['COEFFS'] = llprops['POLY_WAVE_SOL']
    wprops['WAVEMAP'] = llprops['WAVE_MAP2']
    wprops['NBO'] = llprops['NBO']
    wprops['DEG'] = llprops['WAVE_FIT_DEGREE']
    wprops['NBPIX'] = llprops['NBPIX']
    # FP values (set to None for HC)
    wprops['WFP_FILE'] = None
    wprops['WFP_DRIFT'] = None
    wprops['WFP_FWHM'] = None
    wprops['WFP_CONTRAST'] = None
    wprops['WFP_MASK'] = None
    wprops['WFP_LINES'] = None
    wprops['WFP_TARG_RV'] = None
    wprops['WFP_WIDTH'] = None
    wprops['WFP_STEP'] = None
    # set the source
    keys = ['WAVEMAP', 'WAVEFILE', 'WAVESOURCE', 'NBO', 'DEG', 'NBPIX',
            'COEFFS', 'WAVETIME',
            'WFP_DRIFT', 'WFP_FWHM', 'WFP_CONTRAST', 'WFP_MASK',
            'WFP_LINES', 'WFP_TARG_RV', 'WFP_WIDTH', 'WFP_STEP']
    wprops.set_sources(keys, func_name)
    # ----------------------------------------------------------------------
    # Add constants to llprops
    # ----------------------------------------------------------------------
    llprops['USED_N_INIT'] = start
    llprops['USED_N_FIN'] = end
    # define keys
    keys = ['USED_N_INIT', 'USED_N_FIN', 'USED_BLAZE_THRES', 'USED_CAVFIT_DEG',
            'USED_XDIFF_MIN', 'USED_XDIFF_MAX', 'USED_DOPD0', 'USED_LARGE_JUMP',
            'USED_LL_OFFSET', 'USED_DV_MAX', 'USED_LL_FIT_DEG', 'USED_CM_INDEX',
            'USED_BORDER', 'USED_BOX_SIZE', 'USED_SIGLIM', 'USED_LAMP',
            'USED_IPEAK_SPACE', 'USED_EXPWIDTH', 'USED_CUTWIDTH',
            'USED_DV_MAX', 'USED_LL_FIT_DEG', 'USED_UPDATE_CAV',
            'USED_FP_CAV_MODE', 'USED_LL_FIT_MODE', 'USED_ERRX_MIN',
            'USED_MAX_LL_FIT_RMS', 'USED_T_ORD_START', 'USED_WEIGHT_THRES',
            'CCF_SIGDET', 'CCF_BOXSIZE', 'CCF_MAXFLUX', 'CCF_NMAX', 'MASK_MIN',
            'MASK_WIDTH', 'MASK_UNITS']

    # deal with fp keys (that arent used in hcwave sol)
    for key in keys:
        if key not in llprops:
            llprops[key] = 'None'
    llprops.set_sources(keys, func_name)
    # ------------------------------------------------------------------
    # return llprops
    # ------------------------------------------------------------------
    return llprops, wprops


def hc_wavesol_ea(params, recipe, iprops, e2dsfile, fiber, wavell, ampll):
    # set function name
    _ = display_func(params, 'hc_wavesol_ea', __NAME__)
    # ------------------------------------------------------------------
    # Find Gaussian Peaks in HC spectrum
    # ------------------------------------------------------------------
    llprops = find_hc_gauss_peaks(params, recipe, iprops, e2dsfile, fiber)
    # ------------------------------------------------------------------
    # Fit Gaussian peaks (in triplets) to
    # ------------------------------------------------------------------
    llprops = fit_gaussian_triplets(params, recipe, llprops, iprops, wavell,
                                    ampll)
    # ------------------------------------------------------------------
    # Generate Resolution map and line profiles
    # ------------------------------------------------------------------
    llprops = generate_resolution_map(params, recipe, llprops, e2dsfile)
    # ------------------------------------------------------------------
    # Set up all_lines storage
    # ------------------------------------------------------------------
    llprops = all_line_storage(params, llprops)
    # ------------------------------------------------------------------
    # return llprops
    # ------------------------------------------------------------------
    return llprops


def fp_wavesol(params, recipe, hce2dsfile, fpe2dsfile, hcprops, wprops,
               blaze, fiber, **kwargs):
    # set function name
    func_name = display_func(params, 'fp_wavesol', __NAME__)
    # get parameters from params / kwargs
    wave_mode_fp = pcheck(params, 'WAVE_MODE_FP', 'wave_mode_fp', kwargs,
                          func_name)
    try:
        wave_mode_fp = int(wave_mode_fp)
    except ValueError:
        pass
    # ----------------------------------------------------------------------
    # deep copy hcprops into llprops
    llprops = ParamDict()
    for key in hcprops.keys():
        llprops[key] = copy.deepcopy(hcprops[key])
        llprops.set_source(key, hcprops.sources[key])

    # ----------------------------------------------------------------------
    # Incorporate FP into solution
    # ----------------------------------------------------------------------
    if wave_mode_fp == 0:
        # ------------------------------------------------------------------
        # Using the Bauer15 (WAVE_E2DS_EA) method:
        # ------------------------------------------------------------------
        # log progress
        wargs = [wave_mode_fp, 'Bauer 2015']
        WLOG(params, 'info', textentry('40-017-00021', args=wargs))
        # calculate wave solution
        llprops = fp_wavesol_bauer(params, recipe, llprops, fpe2dsfile, blaze,
                                   fiber)
    elif wave_mode_fp == 1:
        # ------------------------------------------------------------------
        # Using the C Lovis (WAVE_NEW_2) method:
        # ------------------------------------------------------------------
        # log progress
        wargs = [wave_mode_fp, 'Lovis Method']
        WLOG(params, 'info', textentry('40-017-00021', args=wargs))
        # calculate wave solution
        llprops = fp_wavesol_lovis(params, recipe, llprops, fpe2dsfile,
                                   hce2dsfile, blaze, fiber)
    else:
        # log that mode is not currently supported
        WLOG(params, 'error', textentry('09-017-00003', args=[wave_mode_fp]))
        llprops = None

    # ----------------------------------------------------------------------
    # LITTROW SECTION - common to all methods
    # ----------------------------------------------------------------------
    # set up hc specific terms
    # TODO: Remove? Now using all orders?
    # start = pcheck(params, 'WAVE_LITTROW_ORDER_INIT_2', 'littrow_start',
    #                kwargs, func_name)
    # end = pcheck(params, 'WAVE_LITTROW_ORDER_FINAL_2', 'littrow_end', kwargs,
    #              func_name)
    start, end = 0, len(llprops['LL_OUT_2']) - 1
    # Copy LL_OUT_1 and LL_PARAM_1 into new constants (for FP integration)
    llprops['LTTROW_EXTRAP_SOL_1'] = np.array(llprops['LL_OUT_1'])
    llprops['LITTORW_EXTRAP_PARAM_1'] = np.array(llprops['LL_PARAM_1'])
    # run littrow test
    llprops = littrow(params, recipe, llprops, start, end, llprops['LL_OUT_2'],
                      fpe2dsfile, blaze, iteration=2, fiber=fiber)

    # ------------------------------------------------------------------
    # Join 0-47 and 47-49 solutions
    # ------------------------------------------------------------------
    # TODO: Remove section? Don't need to extrapolate --> just use for QC
    # start = pcheck(params, 'WAVE_N_ORD_START', 'n_ord_start', kwargs, func_name)
    # end = pcheck(params, 'WAVE_N_ORD_FINAL', 'n_ord_fin', kwargs, func_name)
    # llprops = join_orders(llprops, start, end)

    llprops['LL_FINAL'] = llprops['LL_OUT_2']
    llprops['LL_PARAM_FINAL'] = llprops['LL_PARAM_2']
    llprops.set_sources(['LL_FINAL', 'LL_PARAM_FINAL'], func_name)

    # ------------------------------------------------------------------
    # Plot single order, wavelength-calibrated, with found lines
    # ------------------------------------------------------------------
    recipe.plot('WAVE_FP_SINGLE_ORDER', order=None, llprops=llprops,
                hcdata=hce2dsfile.get_data())

    # ------------------------------------------------------------------
    # get copy of instance of wave file (WAVE_HCMAP)
    # TODO: remove if once we only use cal_wave or cal_wave_master/night
    if 'WAVEM_FPMAP' in recipe.outputs:
        wavefile = recipe.outputs['WAVEM_FPMAP'].newcopy(params=params,
                                                         fiber=fiber)
    else:
        wavefile = recipe.outputs['WAVE_FPMAP'].newcopy(params=params,
                                                        fiber=fiber)
    # construct the filename from file instance
    wavefile.construct_filename(infile=hce2dsfile)
    # ----------------------------------------------------------------------
    # Update wprops
    # ----------------------------------------------------------------------
    wprops['WAVEFILE'] = wavefile.filename
    wprops['WAVESOURCE'] = recipe.name
    wprops['WAVETIME'] = fpe2dsfile.get_hkey('KW_MID_OBS_TIME', dtype=float)
    wprops['COEFFS'] = llprops['LL_PARAM_FINAL']
    wprops['WAVEMAP'] = llprops['LL_FINAL']
    wprops['NBO'] = llprops['LL_PARAM_FINAL'].shape[0]
    wprops['DEG'] = llprops['LL_PARAM_FINAL'].shape[1] - 1
    wprops['NBPIX'] = llprops['NBPIX']
    # set source
    keys = ['WAVEMAP', 'WAVEFILE', 'WAVESOURCE', 'NBO', 'DEG', 'COEFFS',
            'NBPIX', 'WAVETIME']
    wprops.set_sources(keys, func_name)

    # ------------------------------------------------------------------
    # return llprops
    # ------------------------------------------------------------------
    return llprops, wprops


def fp_wavesol_bauer(params, recipe, llprops, fpe2dsfile, blaze, fiber,
                     **kwargs):
    # set function name
    func_name = display_func(params, 'fp_wavesol_bauer', __NAME__)
    # get parameters from params/kwargs
    start = pcheck(params, 'WAVE_N_ORD_START')
    end = pcheck(params, 'WAVE_N_ORD_FINAL')
    dopd0 = pcheck(params, 'WAVE_FP_DOPD0', 'dopd0', kwargs, func_name)
    fit_deg = pcheck(params, 'WAVE_FP_CAVFIT_DEG', 'fit_deg', kwargs, func_name)
    fp_large_jump = pcheck(params, 'WAVE_FP_LARGE_JUMP', 'fp_large_jump',
                           kwargs, func_name)
    ll_fit_degree = pcheck(params, 'WAVE_FP_LL_DEGR_FIT', 'll_fit_degree',
                           kwargs, func_name)
    cm_ind = pcheck(params, 'WAVE_FP_CM_IND', 'cm_ind', kwargs, func_name)
    errx_min = pcheck(params, 'WAVE_FP_ERRX_MIN', 'errx_min', kwargs, func_name)
    max_ll_fit_rms = pcheck(params, 'WAVE_FP_MAX_LLFIT_RMS', 'max_ll_fit_rms',
                            kwargs, func_name)
    t_order_start = pcheck(params, 'WAVE_T_ORDER_START', 't_order_start',
                           kwargs, func_name)
    weight_thres = pcheck(params, 'WAVE_FP_WEIGHT_THRES', 'weight_thres',
                          kwargs, func_name)

    # Log the file we are using
    wargs = [fpe2dsfile.filename]
    WLOG(params, '', textentry('40-017-00022', args=wargs))
    # ------------------------------------------------------------------
    # Find the fp lines and measure the cavity width dependency
    # ------------------------------------------------------------------
    llprops = add_fpline_calc_cwid(params, llprops, fpe2dsfile, blaze, dopd0,
                                   fit_deg, fp_large_jump, start, end, cm_ind)
    # ------------------------------------------------------------------
    # FP solution plots
    # ------------------------------------------------------------------
    recipe.plot('WAVE_FP_FINAL_ORDER', llprops=llprops, fiber=fiber,
                iteration=1, end=end, fpdata=fpe2dsfile.get_data())
    recipe.plot('WAVE_FP_LWID_OFFSET', llprops=llprops)
    recipe.plot('WAVE_FP_WAVE_RES', llprops=llprops)

    # ------------------------------------------------------------------
    # Create new wavelength solution
    # ------------------------------------------------------------------
    # get wavelengths for 1d fit
    wavell = llprops['LITTROW_EXTRAP_SOL_1'][start:end]
    # fit the 1d solution
    llprops = fit_1d_solution(params, llprops, wavell, start, end, fiber,
                              errx_min, ll_fit_degree, max_ll_fit_rms,
                              t_order_start, weight_thres, iteration=2)
    # ----------------------------------------------------------------------
    # add data to llprops (set in lovis method only
    llprops['FP_ONE_M_D'] = None
    llprops['FP_D_ARR'] = None
    llprops['FP_HC_LL_TEST'] = None
    llprops['FP_ORD_TEST'] = None
    llprops['FP_FIT_1M_D'] = None
    llprops['FP_FIT_LL_D'] = None
    # add sources
    keys = ['FP_ONE_M_D', 'FP_D_ARR', 'FP_HC_LL_TEST', 'FP_ORD_TEST',
            'FP_FIT_1M_D', 'FP_FIT_LL_D']
    llprops.set_sources(keys, func_name)

    # ----------------------------------------------------------------------
    # Add constants to llprops
    # ----------------------------------------------------------------------
    llprops['USED_N_INIT'] = start
    llprops['USED_N_FIN'] = end
    llprops['USED_BLAZE_THRES'] = 'None'
    llprops['USED_XDIFF_MIN'] = 'None'
    llprops['USED_XDIFF_MAX'] = 'None'
    llprops['USED_DOPD0'] = dopd0
    llprops['USED_LL_OFFSET'] = 'None'
    llprops['USED_DV_MAX'] = 'None'
    llprops['USED_LL_FIT_DEG'] = ll_fit_degree
    llprops['USED_UPDATE_CAV'] = 'None'
    llprops['USED_FP_CAV_MODE'] = 'None'
    llprops['USED_LL_FIT_MODE'] = 'None'
    llprops['USED_ERRX_MIN'] = errx_min
    llprops['USED_MAX_LL_FIT_RMS'] = max_ll_fit_rms
    llprops['USED_T_ORD_START'] = t_order_start
    llprops['USED_WEIGHT_THRES'] = weight_thres
    llprops['USED_CAVFIT_DEG'] = fit_deg
    llprops['USED_LARGE_JUMP'] = fp_large_jump
    llprops['USED_CM_INDEX'] = cm_ind

    keys = ['USED_N_INIT', 'USED_N_FIN', 'USED_BLAZE_THRES', 'USED_CAVFIT_DEG',
            'USED_XDIFF_MIN', 'USED_XDIFF_MAX', 'USED_DOPD0', 'USED_LARGE_JUMP',
            'USED_LL_OFFSET', 'USED_DV_MAX', 'USED_LL_FIT_DEG', 'USED_CM_INDEX',
            'USED_DV_MAX', 'USED_LL_FIT_DEG', 'USED_UPDATE_CAV',
            'USED_FP_CAV_MODE', 'USED_LL_FIT_MODE', 'USED_ERRX_MIN',
            'USED_MAX_LL_FIT_RMS', 'USED_T_ORD_START', 'USED_WEIGHT_THRES']
    llprops.set_sources(keys, func_name)
    # ------------------------------------------------------------------
    return llprops


def fp_wavesol_lovis(params, recipe, llprops, fpe2dsfile, hce2dsfile,
                     blaze, fiber, **kwargs):
    # set function name
    func_name = display_func(params, 'fp_wavesol_lovis', __NAME__)
    # get parameters from params/kwargs
    n_init = pcheck(params, 'WAVE_N_ORD_START', 'n_init', kwargs, func_name)
    n_fin = pcheck(params, 'WAVE_N_ORD_FINAL', 'n_fin', kwargs, func_name)
    wave_blaze_thres = pcheck(params, 'WAVE_FP_BLAZE_THRES', 'wave_blaze_thres',
                              kwargs, func_name)
    xdiff_min = pcheck(params, 'WAVE_FP_XDIF_MIN', 'xdiff_min', kwargs,
                       func_name)
    xdiff_max = pcheck(params, 'WAVE_FP_XDIF_MAX', 'xdiff_max', kwargs,
                       func_name)
    dopd0 = pcheck(params, 'WAVE_FP_DOPD0', 'dopd0', kwargs, func_name)
    ll_offset = pcheck(params, 'WAVE_FP_LL_OFFSET', 'll_offset', kwargs,
                       func_name)
    dv_max = pcheck(params, 'WAVE_FP_DV_MAX', 'dv_max', kwargs, func_name)
    ll_fit_degree = pcheck(params, 'WAVE_FP_LL_DEGR_FIT', 'll_fit_degree',
                           kwargs, func_name)
    update_cavity = pcheck(params, 'WAVE_FP_UPDATE_CAVITY', 'update_cavity',
                           kwargs, func_name)
    fp_cavfit_mode = pcheck(params, 'WAVE_FP_CAVFIT_MODE', 'fp_cavfit_mode',
                            kwargs, func_name)
    fp_llfit_mode = pcheck(params, 'WAVE_FP_LLFIT_MODE', 'ff_llfit_mode',
                           kwargs, func_name)
    errx_min = pcheck(params, 'WAVE_FP_ERRX_MIN', 'errx_min', kwargs, func_name)
    max_ll_fit_rms = pcheck(params, 'WAVE_FP_MAX_LLFIT_RMS', 'max_ll_fit_rms',
                            kwargs, func_name)
    t_order_start = pcheck(params, 'WAVE_T_ORDER_START', 't_order_start',
                           kwargs, func_name)
    weight_thres = pcheck(params, 'WAVE_FP_WEIGHT_THRES', 'weight_thres',
                          kwargs, func_name)

    # Log the file we are using
    wargs = [fpe2dsfile.filename]
    WLOG(params, '', textentry('40-017-00022', args=wargs))

    # ------------------------------------------------------------------
    # Find FP lines
    # ------------------------------------------------------------------
    # find the fp lines
    llprops = find_fp_lines_new(params, llprops, fpe2dsfile)

    # ------------------------------------------------------------------
    # Number FP peaks differentially and identify gaps
    # ------------------------------------------------------------------
    fout = find_num_fppeak_diff(llprops, blaze, n_init, n_fin, wave_blaze_thres,
                                xdiff_min, xdiff_max)
    fp_ll, dif_n, fp_order, fp_xx, fp_amp = fout

    # ----------------------------------------------------------------------
    # Assign absolute FP numbers for reddest order
    # ----------------------------------------------------------------------
    # determine absolute number for reference peak of reddest order
    # take reddest FP line and apply FP equation
    m_init = int(round(dopd0 / fp_ll[-1][-1]))
    # absolute numbers for reddest order:
    # get differential numbers for reddest order peaks
    aux_n = dif_n[n_fin - n_init - 1]
    # calculate absolute peak numbers for reddest order
    m_aux = m_init - aux_n + aux_n[-1]
    # set m vector
    m_vec = m_aux
    # initialise vector of order numbers for previous order
    m_ord_prev = m_aux

    # ----------------------------------------------------------------------
    # Assign absolute FP numbers for rest of orders by wavelength matching
    # ----------------------------------------------------------------------
    m_vec = assign_abs_fp_numbers(params, fp_ll, dif_n, m_vec, m_ord_prev,
                                  n_init, n_fin, ll_offset)

    # ----------------------------------------------------------------------
    # Derive d for each HC line
    # ----------------------------------------------------------------------
    hout = get_d_for_each_hcline(params, recipe, llprops, fp_order, fp_xx,
                                 m_vec, blaze, n_init, n_fin, wave_blaze_thres,
                                 dv_max, ll_fit_degree)
    one_m_d, d_arr, hc_ll_test, hc_ord_test = hout

    # ----------------------------------------------------------------------
    # Fit (1/m) vs d
    # ----------------------------------------------------------------------
    fout = fit_1m_vs_d(params, recipe, one_m_d, d_arr, hc_ll_test,
                       update_cavity, m_init, fp_ll, fiber)
    fit_1m_d, fit_ll_d, one_m_d, d_arr = fout

    # ----------------------------------------------------------------------
    # Get lines from the fp now that we have a proper cavity length
    #   including orders that we didn't fit before
    # ----------------------------------------------------------------------
    llout = fit_wavemap_cav_iteratively(params, recipe,
                                        inwavemap=llprops['WAVE'],
                                        e2dsfile=fpe2dsfile,
                                        cavity_poly=fit_ll_d)
    ll_out_2, ll_params_2, xmean2, xvar2 = llout[:4]
    xdetails2, lldetails2, scale2, totallines2 = llout[4:]
    # update llprops
    llprops['LL_OUT_2'] = ll_out_2
    llprops['LL_PARAM_2'] = ll_params_2
    llprops['X_MEAN_2'] = xmean2
    llprops['X_VAR_2'] = xvar2
    llprops['X_DETAILS_2'] = xdetails2
    llprops['LL_DETAILS_2'] = lldetails2
    llprops['SCALE_2'] = scale2
    llprops['TOTAL_LINES_2'] = totallines2
    # set source
    keys = ['LL_OUT_2', 'LL_PARAM_2', 'X_MEAN_2', 'X_VAR_2', 'X_DETAILS_2',
            'LL_DETAILS_2', 'LL_DETAILS_2', 'SCALE_2']
    llprops.set_sources(keys, func_name)

    # # ----------------------------------------------------------------------
    # # Update FP peak wavelengths
    # # ----------------------------------------------------------------------
    # llprops = update_fp_peak_wavelengths(params, recipe, llprops, fit_ll_d,
    #                                      m_vec, fp_order, fp_xx, fp_amp,
    #                                      fp_cavfit_mode, n_init, n_fin)
    #
    # # ----------------------------------------------------------------------
    # # Fit wavelength solution from FP peaks
    # # ----------------------------------------------------------------------
    # llprops = fit_wavesol_from_fppeaks(params, llprops, fp_ll, fiber, n_init,
    #                                    n_fin, fp_llfit_mode, ll_fit_degree,
    #                                    errx_min, max_ll_fit_rms, t_order_start,
    #                                    weight_thres)

    # ----------------------------------------------------------------------
    # Multi-order HC lines plot
    # ----------------------------------------------------------------------
    # get graph starting point
    n_plot_init = params['WAVE_FP_PLOT_MULTI_INIT']
    # get the number of orders to plot
    n_nbo = params['WAVE_FP_PLOT_MULTI_NBO']
    # deal with n_plot_init being out of bounds
    if n_plot_init >= n_fin:
        wargs = [n_plot_init, n_fin, 'WAVE_FP_MULTI_ORDER']
        WLOG(params, 'warning', textentry('10-017-00012', args=wargs))
    else:
        recipe.plot('WAVE_FP_MULTI_ORDER', hc_ll=hc_ll_test, hc_ord=hc_ord_test,
                    hcdata=hce2dsfile.get_data(), wave=llprops['LL_OUT_2'],
                    init=n_plot_init, fin=n_fin, nbo=n_nbo, params=params)

    # ----------------------------------------------------------------------
    # add data to llprops
    llprops['FP_ONE_M_D'] = one_m_d
    llprops['FP_D_ARR'] = d_arr
    llprops['FP_HC_LL_TEST'] = hc_ll_test
    llprops['FP_ORD_TEST'] = hc_ord_test
    llprops['FP_FIT_1M_D'] = fit_1m_d
    llprops['FP_FIT_LL_D'] = fit_ll_d
    # add sources
    keys = ['FP_ONE_M_D', 'FP_D_ARR', 'FP_HC_LL_TEST', 'FP_ORD_TEST',
            'FP_FIT_1M_D', 'FP_FIT_LL_D']
    llprops.set_sources(keys, func_name)

    # ----------------------------------------------------------------------
    # Add constants to llprops (Needs to have all from fp_wavesol_bauer
    #    AND fp_wavesol_lovis)
    # ----------------------------------------------------------------------
    llprops['USED_N_INIT'] = n_init
    llprops['USED_N_FIN'] = n_fin
    llprops['USED_BLAZE_THRES'] = wave_blaze_thres
    llprops['USED_XDIFF_MIN'] = xdiff_min
    llprops['USED_XDIFF_MAX'] = xdiff_max
    llprops['USED_DOPD0'] = dopd0
    llprops['USED_LL_OFFSET'] = ll_offset
    llprops['USED_DV_MAX'] = dv_max
    llprops['USED_LL_FIT_DEG'] = ll_fit_degree
    llprops['USED_UPDATE_CAV'] = update_cavity
    llprops['USED_FP_CAV_MODE'] = fp_cavfit_mode
    llprops['USED_LL_FIT_MODE'] = fp_llfit_mode
    llprops['USED_ERRX_MIN'] = errx_min
    llprops['USED_MAX_LL_FIT_RMS'] = max_ll_fit_rms
    llprops['USED_T_ORD_START'] = t_order_start
    llprops['USED_WEIGHT_THRES'] = weight_thres
    llprops['USED_CAVFIT_DEG'] = 'None'
    llprops['USED_LARGE_JUMP'] = 'None'
    llprops['USED_CM_INDEX'] = 'None'

    keys = ['USED_N_INIT', 'USED_N_FIN', 'USED_BLAZE_THRES', 'USED_CAVFIT_DEG',
            'USED_XDIFF_MIN', 'USED_XDIFF_MAX', 'USED_DOPD0', 'USED_LARGE_JUMP',
            'USED_LL_OFFSET', 'USED_DV_MAX', 'USED_LL_FIT_DEG', 'USED_CM_INDEX',
            'USED_DV_MAX', 'USED_LL_FIT_DEG', 'USED_UPDATE_CAV',
            'USED_FP_CAV_MODE', 'USED_LL_FIT_MODE', 'USED_ERRX_MIN',
            'USED_MAX_LL_FIT_RMS', 'USED_T_ORD_START', 'USED_WEIGHT_THRES']
    llprops.set_sources(keys, func_name)

    # return llprops
    return llprops


def fit_wavemap_cav_iteratively(params, recipe, inwavemap, e2dsfile,
                                cavity_poly):
    # set function name
    display_func(params, __NAME__, 'fit_wavemap_cav_iteratively')
    # get parameters from params and/or kwargs
    n_iterations = 5
    fit_deg = params['WAVE_FIT_DEGREE']
    nsig = params['WAVE_NIGHT_NSIG_FIT_CUT']
    # copy wave map
    wavemap = np.array(inwavemap)
    # get the number of orders and number of pixels
    nbo, nbpix = wavemap.shape
    # set up coefficient storage
    wcoeffs_arr = np.zeros((nbo, fit_deg + 1))
    # set fp lines for stats storage
    fplines = None
    # loop around iterations
    for ite in range(n_iterations):
        # TODO: language database
        WLOG(params, 'info', 'Iteration {0} of {1}'.format(ite + 1, n_iterations))
        # get master line table
        fpargs = dict(e2dsfile=e2dsfile, wavemap=wavemap,
                      cavity_poly=cavity_poly, iteration=(ite + 1))
        fplines = get_master_lines(params, recipe, **fpargs)
        # get data from table
        pixel_meas = fplines['PIXEL_MEAS']
        wave_ref = fplines['WAVE_REF']
        # loop around orders
        for order_num in range(nbo):
            # get lines in this order
            good = (fplines['ORDER'] == order_num)
            # only keep valid lines
            good &= np.isfinite(pixel_meas)
            # fit the lines in this order
            # We do *not* use a sigma-clipping here as some orders may
            #  have very structured residuals that would be seen as
            #  high-sigma outliers. The last 2 iterations will have
            #  a sigma-clipping

            # for the first iteration just polyfit - update the coefficients
            if ite == 0:
                # fit the pixels to wavelength
                wcoeffs = mp.nanpolyfit(pixel_meas[good], wave_ref[good],
                                        fit_deg)
                # update the coefficient array
                wcoeffs_arr[order_num] = wcoeffs
            # for other iterations we are fitting the residuals
            #   thus we must add to the wcoeffs from iteration = 0
            else:
                # calculate the difference between wavelength from coeffs
                #   and model predicted wavelength
                wavemap_coeff = np.polyval(wcoeffs_arr[order_num],
                                           pixel_meas[good])
                diffwavemap = wave_ref[good] - wavemap_coeff
                # fit the residuals (of the lines) in this order
                #   if we are on early iterations do not sigma clip (just use
                #   a poly fit
                if ite < (n_iterations - 2):
                    wcoeffs = mp.nanpolyfit(pixel_meas[good], diffwavemap,
                                            fit_deg)
                # if we are on the last two iterations sigma clip
                else:
                    wcoeffs, mask = mp.robust_polyfit(pixel_meas[good],
                                                      diffwavemap, fit_deg,
                                                      nsig)
                # update the coefficient array (add as we fit the residuals
                wcoeffs_arr[order_num] += wcoeffs
                # calculate the dv of the lines (in m/s)
                dv_lines = diffwavemap / wave_ref[good] * speed_of_light_ms
                # log message: Order: median abs dev for order m/s
                wargs = [order_num, np.nanmedian(np.abs(dv_lines))]
                WLOG(params, '', textentry('40-017-00041', args=wargs))
            # update the wave map
            wavemap[order_num] = np.polyval(wcoeffs_arr[order_num],
                                            np.arange(nbpix))
    # get stats for storage
    scale = []
    xdetails, lldetails = [], []
    # loop around orders
    for order_num in range(nbo):
        # get the lines for this order
        good = fplines['ORDER'] == order_num
        good &= np.isfinite(fplines['WAVE_MEAS'])
        # get values
        x_fit = fplines['PIXEL_MEAS'][good]
        lines = fplines['WAVE_REF'][good]
        cfit = np.repeat(np.nan, len(x_fit))
        weight = np.ones_like(x_fit)
        # get the derivative of the central pixel
        cent_wder = np.polyval(np.polyder(wcoeffs_arr[order_num]), lines)
        # get the wave value at the central pixel
        cent_wave = np.polyval(wcoeffs_arr[order_num], lines)
        # get the scale
        scale.append((cent_wder / cent_wave) * speed_of_light)
        xdetails.append([lines, x_fit, cfit, weight])
        icfit = np.polyval(wcoeffs_arr[order_num], x_fit)
        res = icfit - lines
        nres = speed_of_light * (res / lines)
        lldetails.append([nres, weight])
    # get mean, variance and total number of lines
    xmean = mp.nanmean(fplines['PIXEL_REF'] - fplines['PIXEL_MEAS'])
    xvar = mp.nanstd(fplines['PIXEL_REF'] - fplines['PIXEL_MEAS'])
    tlines = np.sum(np.isfinite(fplines['WAVE_MEAS']))
    # need to flip coefficients
    wave_params = wcoeffs_arr[:, ::-1]
    # return parameters
    return wavemap, wave_params, xmean, xvar, xdetails, lldetails, scale, tlines


# =============================================================================
# Define hc aux functions
# =============================================================================
def hc_quality_control(params, hcprops):
    # set function name
    _ = display_func(params, 'hc_quality_control', __NAME__)
    # set passed variable and fail message list
    fail_msg = []
    qc_values, qc_names, qc_logic, qc_pass = [], [], [], []
    # --------------------------------------------------------------
    # quality control on sigma clip (sig1 > qc_hc_wave_sigma_max
    hc_wave_sigma = params['WAVE_HC_QC_SIGMA_MAX']
    # find if sigma is greater than limit
    if hcprops['SIG1'] > hc_wave_sigma:
        fargs = [hcprops['SIG1'], hc_wave_sigma]
        fail_msg.append(textentry('40-017-00015', args=fargs))
        qc_pass.append(0)
    else:
        qc_pass.append(1)
    # add to qc header lists
    qc_values.append(hcprops['SIG1'])
    qc_names.append('SIG1 HC')
    qc_logic.append('SIG1 > {0:.2f}'.format(hc_wave_sigma))
    # --------------------------------------------------------------
    # check the difference between consecutive orders is always
    #     positive
    # get the differences
    wave_diff = hcprops['WAVE_MAP2'][1:] - hcprops['WAVE_MAP2'][:-1]
    if mp.nanmin(wave_diff) < 0:
        fail_msg.append(textentry('40-017-00016'))
        qc_pass.append(0)
    else:
        qc_pass.append(1)
    # add to qc header lists
    qc_values.append(mp.nanmin(wave_diff))
    qc_names.append('MIN WAVE DIFF HC')
    qc_logic.append('MIN WAVE DIFF < 0')
    # --------------------------------------------------------------
    # check the difference between consecutive pixels along an
    #     order is always positive
    # loop through the orders
    ord_check = np.zeros(hcprops['NBO'], dtype=bool)
    for order in range(hcprops['NBO']):
        wave0 = hcprops['WAVE_MAP2'][order, :-1]
        wave1 = hcprops['WAVE_MAP2'][order, 1:]
        ord_check[order] = np.all(wave1 > wave0)
    if np.all(ord_check):
        qc_pass.append(1)
        qc_values.append('None')
    else:
        fail_msg.append(textentry('40-017-00017'))
        qc_pass.append(0)
        badvalues = np.where(~ord_check)[0].astype(str)
        qc_values.append(','.join(list(badvalues)))
    # add to qc header lists
    qc_names.append('WAVE DIFF ALONG ORDER HC')
    qc_logic.append('WAVE DIFF ALONG ORDER < 0')
    # --------------------------------------------------------------
    # finally log the failed messages and set QC = 1 if we pass the
    #     quality control QC = 0 if we fail quality control
    if np.sum(qc_pass) == len(qc_pass):
        WLOG(params, 'info', textentry('40-005-10001'))
    else:
        for farg in fail_msg:
            WLOG(params, 'warning', textentry('40-005-10002') + farg)
    # store in qc_params
    qc_params = [qc_names, qc_values, qc_logic, qc_pass]
    # return qc_params
    return qc_params


def hc_log_global_stats(params, hcprops, e2dsfile, fiber):
    # set function name
    _ = display_func(params, 'hc_log_global_stats', __NAME__)
    # calculate catalog-fit residuals in km/s
    res_hc = []
    sumres_hc = 0.0
    sumres2_hc = 0.0
    # loop around orders
    for order in range(e2dsfile.get_data().shape[0]):
        # get HC line wavelengths for the order
        order_mask = hcprops['ORD_T'] == order
        hc_x_ord = hcprops['XGAU_T'][order_mask]
        hc_ll_ord = np.polyval(hcprops['POLY_WAVE_SOL'][order][::-1], hc_x_ord)
        hc_ll_cat = hcprops['WAVE_CATALOG'][order_mask]
        hc_ll_diff = hc_ll_ord - hc_ll_cat
        res_hc.append(hc_ll_diff * speed_of_light / hc_ll_cat)
        sumres_hc += mp.nansum(res_hc[order])
        sumres2_hc += mp.nansum(res_hc[order] ** 2)
    # get the total number of lines
    total_lines_hc = len(np.concatenate(res_hc))
    # get the final mean and varianace
    final_mean_hc = sumres_hc / total_lines_hc
    final_var_hc = (sumres2_hc / total_lines_hc) - (final_mean_hc ** 2)
    # log global hc stats
    wargs = [fiber, final_mean_hc * 1000.0, np.sqrt(final_var_hc) * 1000.0,
             total_lines_hc, 1000.0 * np.sqrt(final_var_hc / total_lines_hc)]
    WLOG(params, 'info', textentry('40-017-00018', args=wargs))


# TODO: remove if we are using master/night recipes
def hc_write_wavesolution(params, recipe, llprops, infile, fiber, combine,
                          rawhcfiles, qc_params, iwprops, wprops):
    # set function name
    _ = display_func(params, 'hc_write_wavesolution', __NAME__)
    # ------------------------------------------------------------------
    # get copy of instance of wave file (WAVE_HCMAP)
    wavefile = recipe.outputs['WAVE_HCMAP'].newcopy(params=params,
                                                    fiber=fiber)
    # construct the filename from file instance
    wavefile.construct_filename(infile=infile)
    # ------------------------------------------------------------------
    # define header keys for output file
    # copy keys from input file
    wavefile.copy_original_keys(infile)
    # add version
    wavefile.add_hkey('KW_VERSION', value=params['DRS_VERSION'])
    # add output tag
    wavefile.add_hkey('KW_OUTPUT', value=wavefile.name)
    wavefile.add_hkey('KW_FIBER', value=fiber)
    # add input files (and deal with combining or not combining)
    if combine:
        hfiles = rawhcfiles
    else:
        hfiles = [infile.basename]
    wavefile.add_hkey_1d('KW_INFILE1', values=hfiles, dim1name='file')
    # add initial wavelength solution used
    wavefile.add_hkey('KW_INIT_WAVE', value=iwprops['WAVEFILE'])
    # ------------------------------------------------------------------
    # add the order num, fit degree and fit coefficients
    wavefile = add_wave_keys(params, wavefile, wprops)
    # ------------------------------------------------------------------
    # add constants used (for reproduction)
    wavefile.add_hkey('KW_WAVE_FITDEG', value=llprops['WAVE_FIT_DEGREE'])
    wavefile.add_hkey('KW_WAVE_MODE_HC', value=llprops['WAVE_MODE_HC'])
    wavefile.add_hkey('KW_WAVE_MODE_FP', value='None')
    # - from find_hc_gauss_peaks
    wavefile.add_hkey('KW_WAVE_HCG_WSIZE', value=llprops['HCG_WSIZE'])
    wavefile.add_hkey('KW_WAVE_HCG_SIGPEAK', value=llprops['HCG_SIGPEAK'])
    wavefile.add_hkey('KW_WAVE_HCG_GFITMODE', value=llprops['HCG_GFITMODE'])
    wavefile.add_hkey('KW_WAVE_HCG_FB_RMSMIN',
                      value=llprops['HCG_FITBOX_RMSMIN'])
    wavefile.add_hkey('KW_WAVE_HCG_FB_RMSMAX',
                      value=llprops['HCG_FITBOX_RMSMAX'])
    wavefile.add_hkey('KW_WAVE_HCG_EWMIN', value=llprops['HCG_EWMIN'])
    wavefile.add_hkey('KW_WAVE_HCG_EWMAX', value=llprops['HCG_EWMAX'])
    # - from load_hc_init_linelist
    wavefile.add_hkey('KW_WAVE_HCLL_FILE', value=llprops['HCLLBASENAME'])
    # - from fit_gaussian_triplets
    wavefile.add_hkey('KW_WAVE_TRP_NBRIGHT', value=llprops['NMAX_BRIGHT'])
    wavefile.add_hkey('KW_WAVE_TRP_NITER', value=llprops['N_ITER'])
    wavefile.add_hkey('KW_WAVE_TRP_CATGDIST', value=llprops['CAT_GUESS_DIST'])
    wavefile.add_hkey('KW_WAVE_TRP_FITDEG', value=llprops['TRIPLET_DEG'])
    wavefile.add_hkey('KW_WAVE_TRP_MIN_NLINES', value=llprops['MIN_NUM_LINES'])
    wavefile.add_hkey('KW_WAVE_TRP_TOT_NLINES', value=llprops['MIN_TOT_LINES'])
    wavefile.add_hkey_1d('KW_WAVE_TRP_ORDER_FITCONT',
                         values=llprops['ORDER_FIT_CONT'], dim1name='fit')
    wavefile.add_hkey('KW_WAVE_TRP_SCLIPNUM', value=llprops['SIGMA_CLIP_NUM'])
    wavefile.add_hkey('KW_WAVE_TRP_SCLIPTHRES',
                      value=llprops['SIGMA_CLIP_THRES'])
    wavefile.add_hkey('KW_WAVE_TRP_DVCUTORD', value=llprops['DVCUT_ORDER'])
    wavefile.add_hkey('KW_WAVE_TRP_DVCUTALL', value=llprops['DVCUT_ALL'])
    # - from generate res map
    wavefile.add_hkey_1d('KW_WAVE_RES_MAPSIZE', dim1name='dim',
                         values=llprops['RES_MAP_SIZE'])
    wavefile.add_hkey('KW_WAVE_RES_WSIZE', value=llprops['RES_WSIZE'])
    wavefile.add_hkey('KW_WAVE_RES_MAXDEVTHRES', value=llprops['MAX_DEV_THRES'])
    # - from littrow
    wavefile.add_hkey('KW_WAVE_LIT_START_1', value=llprops['LITTROW_START_1'])
    wavefile.add_hkey('KW_WAVE_LIT_END_1', value=llprops['LITTROW_END_1'])
    wavefile.add_hkey('KW_WAVE_ECHELLE_START', value=llprops['T_ORDER_START'])
    # - from calculate littrow solution
    wavefile.add_hkey_1d('KW_WAVE_LIT_RORDERS', dim1name='rorder',
                         values=llprops['LITTROW_REMOVE_ORDERS'])
    wavefile.add_hkey('KW_WAVE_LIT_ORDER_INIT_1',
                      value=llprops['LITTROW_ORDER_INIT_1'])
    wavefile.add_hkey('KW_WAVE_LIT_ORDER_START_1',
                      value=llprops['LITTROW_ORDER_START_1'])
    wavefile.add_hkey('KW_WAVE_LIT_ORDER_END_1',
                      value=llprops['LITTROW_ORDER_END_1'])
    wavefile.add_hkey('KW_WAVE_LITT_XCUTSTEP_1',
                      value=llprops['LITTROW_X_CUT_STEP_1'])
    wavefile.add_hkey('KW_WAVE_LITT_FITDEG_1',
                      value=llprops['LITTROW_FIT_DEG_1'])
    # - from extrapolate littrow solution
    wavefile.add_hkey('KW_WAVE_LITT_EXT_FITDEG_1',
                      value=llprops['LITTROW_EXT_FITDEG_1'])
    wavefile.add_hkey('KW_WAVE_LITT_EXT_ORD_START_1',
                      value=llprops['LITTROW_EXT_ORD_START_1'])
    # add qc parameters
    wavefile.add_qckeys(qc_params)

    # copy data
    wavefile.data = llprops['WAVE_MAP2']
    # ------------------------------------------------------------------
    # log that we are saving rotated image
    wargs = [fiber, wavefile.filename]
    WLOG(params, '', textentry('40-017-00019', args=wargs))
    # write image to file
    wavefile.write_file(kind=recipe.outputtype, runstring=recipe.runstring)
    # add to output files (for indexing)
    recipe.add_output_file(wavefile)
    # ------------------------------------------------------------------
    # return hc wavefile
    return wavefile


# TODO: remove if we are using master/night recipes
def hc_write_resmap(params, recipe, llprops, infile, wavefile, fiber):
    # set function name
    _ = display_func(params, 'hc_write_resmap', __NAME__)
    # ------------------------------------------------------------------
    # get copy of instance of wave file (WAVE_HCMAP)
    resfile = recipe.outputs['WAVE_HCRES'].newcopy(params=params,
                                                   fiber=fiber)
    # construct the filename from file instance
    resfile.construct_filename(infile=infile)
    # ------------------------------------------------------------------
    # define header keys for output file
    # copy keys from wavefile
    resfile.copy_hdict(wavefile)
    # set output key
    resfile.add_hkey('KW_OUTPUT', value=resfile.name)
    # ------------------------------------------------------------------
    datalist, headerlist = generate_res_files(params, llprops, resfile)
    # ------------------------------------------------------------------
    # set data to an empty list
    resfile.data = []
    # ------------------------------------------------------------------
    # log that we are saving rotated image
    wargs = [fiber, resfile.filename]
    WLOG(params, '', textentry('40-017-00020', args=wargs))
    # write image to file
    resfile.write_multi(data_list=datalist, header_list=headerlist,
                        kind=recipe.outputtype, runstring=recipe.runstring)
    # add to output files (for indexing)
    recipe.add_output_file(resfile)


def hc_write_wavesol_master(params, recipe, llprops, infile, fiber, combine,
                            rawhcfiles, qc_params, iwprops, wprops):
    # set function name
    _ = display_func(params, 'hc_write_wavesol_master', __NAME__)
    # ------------------------------------------------------------------
    # get copy of instance of wave file (WAVE_HCMAP)
    wavefile = recipe.outputs['WAVEM_HCMAP'].newcopy(params=params,
                                                     fiber=fiber)
    # construct the filename from file instance
    wavefile.construct_filename(infile=infile)
    # ------------------------------------------------------------------
    # define header keys for output file
    # copy keys from input file (exclude all current wave keys)
    wavefile.copy_original_keys(infile, exclude_groups=['wave'])
    # add version
    wavefile.add_hkey('KW_VERSION', value=params['DRS_VERSION'])
    # add dates
    wavefile.add_hkey('KW_DRS_DATE', value=params['DRS_DATE'])
    wavefile.add_hkey('KW_DRS_DATE_NOW', value=params['DATE_NOW'])
    # add process id
    wavefile.add_hkey('KW_PID', value=params['PID'])
    # add output tag
    wavefile.add_hkey('KW_OUTPUT', value=wavefile.name)
    wavefile.add_hkey('KW_FIBER', value=fiber)
    # add input files (and deal with combining or not combining)
    if combine:
        hfiles = rawhcfiles
    else:
        hfiles = [infile.basename]
    wavefile.add_hkey_1d('KW_INFILE1', values=hfiles, dim1name='file')
    # add initial wavelength solution used
    wavefile.add_hkey('KW_INIT_WAVE', value=iwprops['WAVEFILE'])
    # ------------------------------------------------------------------
    # add the order num, fit degree and fit coefficients
    wavefile = add_wave_keys(params, wavefile, wprops)
    # ------------------------------------------------------------------
    # add constants used (for reproduction)
    wavefile.add_hkey('KW_WAVE_FITDEG', value=llprops['WAVE_FIT_DEGREE'])
    wavefile.add_hkey('KW_WAVE_MODE_HC', value=llprops['WAVE_MODE_HC'])
    wavefile.add_hkey('KW_WAVE_MODE_FP', value='None')
    # - from find_hc_gauss_peaks
    wavefile.add_hkey('KW_WAVE_HCG_WSIZE', value=llprops['HCG_WSIZE'])
    wavefile.add_hkey('KW_WAVE_HCG_SIGPEAK', value=llprops['HCG_SIGPEAK'])
    wavefile.add_hkey('KW_WAVE_HCG_GFITMODE', value=llprops['HCG_GFITMODE'])
    wavefile.add_hkey('KW_WAVE_HCG_FB_RMSMIN',
                      value=llprops['HCG_FITBOX_RMSMIN'])
    wavefile.add_hkey('KW_WAVE_HCG_FB_RMSMAX',
                      value=llprops['HCG_FITBOX_RMSMAX'])
    wavefile.add_hkey('KW_WAVE_HCG_EWMIN', value=llprops['HCG_EWMIN'])
    wavefile.add_hkey('KW_WAVE_HCG_EWMAX', value=llprops['HCG_EWMAX'])
    # - from load_hc_init_linelist
    wavefile.add_hkey('KW_WAVE_HCLL_FILE', value=llprops['HCLLBASENAME'])
    # - from fit_gaussian_triplets
    wavefile.add_hkey('KW_WAVE_TRP_NBRIGHT', value=llprops['NMAX_BRIGHT'])
    wavefile.add_hkey('KW_WAVE_TRP_NITER', value=llprops['N_ITER'])
    wavefile.add_hkey('KW_WAVE_TRP_CATGDIST', value=llprops['CAT_GUESS_DIST'])
    wavefile.add_hkey('KW_WAVE_TRP_FITDEG', value=llprops['TRIPLET_DEG'])
    wavefile.add_hkey('KW_WAVE_TRP_MIN_NLINES', value=llprops['MIN_NUM_LINES'])
    wavefile.add_hkey('KW_WAVE_TRP_TOT_NLINES', value=llprops['MIN_TOT_LINES'])
    wavefile.add_hkey_1d('KW_WAVE_TRP_ORDER_FITCONT',
                         values=llprops['ORDER_FIT_CONT'], dim1name='fit')
    wavefile.add_hkey('KW_WAVE_TRP_SCLIPNUM', value=llprops['SIGMA_CLIP_NUM'])
    wavefile.add_hkey('KW_WAVE_TRP_SCLIPTHRES',
                      value=llprops['SIGMA_CLIP_THRES'])
    wavefile.add_hkey('KW_WAVE_TRP_DVCUTORD', value=llprops['DVCUT_ORDER'])
    wavefile.add_hkey('KW_WAVE_TRP_DVCUTALL', value=llprops['DVCUT_ALL'])
    # - from generate res map
    wavefile.add_hkey_1d('KW_WAVE_RES_MAPSIZE', dim1name='dim',
                         values=llprops['RES_MAP_SIZE'])
    wavefile.add_hkey('KW_WAVE_RES_WSIZE', value=llprops['RES_WSIZE'])
    wavefile.add_hkey('KW_WAVE_RES_MAXDEVTHRES', value=llprops['MAX_DEV_THRES'])
    # - from littrow
    wavefile.add_hkey('KW_WAVE_LIT_START_1', value=llprops['LITTROW_START_1'])
    wavefile.add_hkey('KW_WAVE_LIT_END_1', value=llprops['LITTROW_END_1'])
    wavefile.add_hkey('KW_WAVE_ECHELLE_START', value=llprops['T_ORDER_START'])
    # - from calculate littrow solution
    wavefile.add_hkey_1d('KW_WAVE_LIT_RORDERS', dim1name='rorder',
                         values=llprops['LITTROW_REMOVE_ORDERS'])
    wavefile.add_hkey('KW_WAVE_LIT_ORDER_INIT_1',
                      value=llprops['LITTROW_ORDER_INIT_1'])
    wavefile.add_hkey('KW_WAVE_LIT_ORDER_START_1',
                      value=llprops['LITTROW_ORDER_START_1'])
    wavefile.add_hkey('KW_WAVE_LIT_ORDER_END_1',
                      value=llprops['LITTROW_ORDER_END_1'])
    wavefile.add_hkey('KW_WAVE_LITT_XCUTSTEP_1',
                      value=llprops['LITTROW_X_CUT_STEP_1'])
    wavefile.add_hkey('KW_WAVE_LITT_FITDEG_1',
                      value=llprops['LITTROW_FIT_DEG_1'])
    # - from extrapolate littrow solution
    wavefile.add_hkey('KW_WAVE_LITT_EXT_FITDEG_1',
                      value=llprops['LITTROW_EXT_FITDEG_1'])
    wavefile.add_hkey('KW_WAVE_LITT_EXT_ORD_START_1',
                      value=llprops['LITTROW_EXT_ORD_START_1'])
    # add qc parameters
    wavefile.add_qckeys(qc_params)

    # copy data
    wavefile.data = llprops['WAVE_MAP2']
    # ------------------------------------------------------------------
    # log that we are saving rotated image
    wargs = [fiber, wavefile.filename]
    WLOG(params, '', textentry('40-017-00019', args=wargs))
    # write image to file
    wavefile.write_file(kind=recipe.outputtype, runstring=recipe.runstring)
    # add to output files (for indexing)
    recipe.add_output_file(wavefile)
    # ------------------------------------------------------------------
    # return hc wavefile
    return wavefile


def hc_write_resmap_master(params, recipe, llprops, infile, wavefile, fiber):
    # set function name
    _ = display_func(params, 'hc_write_resmap_master', __NAME__)
    # ------------------------------------------------------------------
    # get copy of instance of wave file (WAVE_HCMAP)
    resfile = recipe.outputs['WAVEM_HCRES'].newcopy(params=params,
                                                    fiber=fiber)
    # construct the filename from file instance
    resfile.construct_filename(infile=infile)
    # ------------------------------------------------------------------
    # define header keys for output file
    # copy keys from wavefile
    resfile.copy_hdict(wavefile)
    # set output key
    resfile.add_hkey('KW_OUTPUT', value=resfile.name)
    # ------------------------------------------------------------------
    datalist, headerlist = generate_res_files(params, llprops, resfile)
    # ------------------------------------------------------------------
    # set data to an empty list
    resfile.data = []
    # ------------------------------------------------------------------
    # log that we are saving rotated image
    wargs = [fiber, resfile.filename]
    WLOG(params, '', textentry('40-017-00020', args=wargs))
    # write image to file
    resfile.write_multi(data_list=datalist, header_list=headerlist,
                        kind=recipe.outputtype, runstring=recipe.runstring)
    # add to output files (for indexing)
    recipe.add_output_file(resfile)


# =============================================================================
# Define hc worker functions
# =============================================================================
def generate_shifted_wave_map(params, props, **kwargs):
    # set function name
    func_name = display_func(params, 'generate_shifted_wave_map', __NAME__)
    # get constants from p
    pixel_shift_inter = pcheck(params, 'WAVE_PIXEL_SHIFT_INTER', 'pixelshifti',
                               kwargs, func_name)
    pixel_shift_slope = pcheck(params, 'WAVE_PIXEL_SHIFT_SLOPE', 'pixelshifts',
                               kwargs, func_name)
    # get data from loc
    poly_wave_sol = props['COEFFS']
    nbo, nbpix = props['WAVEMAP'].shape
    # print a warning if pixel_shift is not 0
    if pixel_shift_slope != 0 or pixel_shift_inter != 0:
        wargs = [pixel_shift_slope, pixel_shift_inter]
        WLOG(params, 'warning', textentry('10-017-00004', args=wargs))
    else:
        return props
    # generate wave map with shift
    wave_map = np.zeros([nbo, nbpix])
    shift = pixel_shift_inter + pixel_shift_slope
    xpix = np.arange(nbpix) + shift * np.arange(nbpix)
    for iord in range(nbo):
        wave_map[iord, :] = np.polyval((poly_wave_sol[iord, :])[::-1], xpix)
    # save wave map to loc
    props['WAVEMAP'] = wave_map
    props.set_source('WAVEMAP', func_name)
    # return loc
    return props


def find_hc_gauss_peaks(params, recipe, iprops, e2dsfile, fiber, **kwargs):
    """
    Find the first guess at the guass peaks in the HC image

    :param params:
    :param recipe:
    :param iprops:
    :param e2dsfile:
    :param fiber:
    :param kwargs:
    :return:
    """
    # set function name
    func_name = display_func(params, 'find_hc_gauss_peaks', __NAME__)
    # get constants from params/kwargs
    wsize = pcheck(params, 'WAVE_HC_FITBOX_SIZE', 'wsize', kwargs,
                   func_name)
    sigma_peak = pcheck(params, 'WAVE_HC_FITBOX_SIGMA', 'sigma_peak', kwargs,
                        func_name)
    gfitmode = pcheck(params, 'WAVE_HC_FITBOX_GFIT_DEG', 'gfitmode', kwargs,
                      func_name)
    gauss_rms_dev_min = pcheck(params, 'WAVE_HC_FITBOX_RMS_DEVMIN',
                               'grms_devmin', kwargs, func_name)
    gauss_rms_dev_max = pcheck(params, 'WAVE_HC_FITBOX_RMS_DEVMAX',
                               'grms_devmax', kwargs, func_name)
    ew_min = pcheck(params, 'WAVE_HC_FITBOX_EWMIN', 'ew_min', kwargs,
                    func_name)
    ew_max = pcheck(params, 'WAVE_HC_FITBOX_EWMAX', 'ew_max', kwargs,
                    func_name)
    filefmt = pcheck(params, 'WAVE_HCLL_FILE_FMT', 'filefmt', kwargs, func_name)
    # get image
    hc_sp = e2dsfile.get_data()
    # get dimensions from image
    nbo, nbpix = e2dsfile.get_data().shape
    # print process
    WLOG(params, '', textentry('40-017-00003'))
    # get initial line list
    llprops, exists = load_hc_init_linelist(params, recipe, e2dsfile, fiber)
    # if we dont have line list need to generate it
    if not exists:
        # ------------------------------------------------------------------
        # else we need to populate llprops
        # ------------------------------------------------------------------
        # set the first "previous peak" to -1
        xprev = -1
        # loop around orders
        for order_num in range(nbo):
            # print progress for user: processing order N of M
            wargs = [order_num, nbo - 1]
            WLOG(params, '', textentry('40-017-00004', args=wargs))
            # set number of peaks found
            npeaks = 0
            # extract this orders spectrum
            hc_sp_order = np.array(hc_sp[order_num, :])
            # loop around boxes in each order 1/3rd of wsize at a time
            bstart, bend = wsize * 2, hc_sp.shape[1] - wsize * 2 - 1
            bstep = wsize // 3
            for indmax in range(bstart, bend, bstep):
                # get this iterations start and end
                istart, iend = indmax - wsize, indmax + wsize
                # get the pixels for this iteration
                xpix = np.arange(istart, iend, 1)
                # get the spectrum at these points
                segment = np.array(hc_sp_order[istart:iend])
                # check there are not too many nans in segment:
                # if total not-nans is smaller than gaussian params +1
                if np.sum(~np.isnan(segment)) < gfitmode + 1:
                    # continue to next segment
                    continue
                # calculate the RMS
                rms = mp.nanmedian(np.abs(segment[1:] - segment[:-1]))
                # find the peak pixel value
                peak = mp.nanmax(segment) - mp.nanmedian(segment)
                # ----------------------------------------------------------
                # keep only peaks that are well behaved:
                # RMS not zero
                keep = rms != 0
                # peak not zero
                keep &= peak != 0
                # peak at least a few sigma from RMS
                with warnings.catch_warnings(record=True) as _:
                    keep &= (peak / rms > sigma_peak)
                # ----------------------------------------------------------
                # position of peak within segement - it needs to be close
                #   enough to the center of the segment if it is at the edge
                #   we'll catch it in the following iteration
                imax = np.argmax(segment) - wsize
                # keep only if close enough to the center
                keep &= np.abs(imax) < wsize // 3
                # ----------------------------------------------------------
                # if keep is still True we have a good peak worth fitting
                #    a Gaussian
                if keep:
                    # fit a gaussian with a slope
                    gargs = [xpix, segment, gfitmode]
                    popt_left, gfit = mp.gauss_fit_nn(*gargs)
                    # residual of the fit normalized by peak value similar to
                    #    an 1/SNR value
                    gauss_rms_dev0 = mp.nanstd(segment - gfit) / popt_left[0]
                    # all values that will be added (if keep_peak=True) to the
                    #    vector of all line parameters
                    zp0 = popt_left[3]
                    slope0 = popt_left[4]
                    ew0 = popt_left[2]
                    xgau0 = popt_left[1]
                    peak0 = popt_left[0]
                    # test whether we will add peak to our master list of peak
                    keep_peak = gauss_rms_dev0 > gauss_rms_dev_min
                    keep_peak &= gauss_rms_dev0 < gauss_rms_dev_max
                    keep_peak &= ew0 > ew_min
                    keep_peak &= ew0 < ew_max
                    # must be > 1 pix from previous peak
                    keep_peak &= np.abs(xgau0 - xprev) > 1
                    # if all if fine, we keep the value of the fit
                    if keep_peak:
                        # update number of peaks
                        npeaks += 1
                        # update the value of previous peak
                        xprev = xgau0
                        # append values
                        llprops['ZP_INI'].append(zp0)
                        llprops['SLOPE_INI'].append(slope0)
                        llprops['EW_INI'].append(ew0)
                        llprops['XGAU_INI'].append(xgau0)
                        llprops['PEAK_INI'].append(peak0)
                        llprops['ORD_INI'].append(order_num)
                        llprops['GAUSS_RMS_DEV_INI'].append(gauss_rms_dev0)
                        # add values for plotting
                        llprops['XPIX_INI'].append(xpix)
                        llprops['GFIT_INI'].append(gfit)
            # display the number of peaks found
            WLOG(params, '', textentry('40-017-00005', args=[npeaks]))
        # ------------------------------------------------------------------
        # construct column names/values
        columnnames, columnvalues = llprops['HCLLCOLUMNS'], []
        for colname in columnnames:
            columnvalues.append(llprops[colname])
        # construct table
        ini_table = drs_table.make_table(params, columnnames, columnvalues)
        # log that we are saving hc line-list to file
        wargs = [llprops['HCLLBASENAME']]
        WLOG(params, '', textentry('40-017-00006', args=wargs))
        # save the table to file
        drs_table.write_table(params, ini_table, llprops['HCLLFILENAME'],
                              fmt=filefmt)
        # plot all orders w/fitted gaussians
        if __name__ == '__main__':
            recipe.plot('WAVE_HC_GUESS', params=params, wave=iprops['WAVEMAP'],
                        spec=hc_sp, llprops=llprops, nbo=nbo)
    # ----------------------------------------------------------------------
    # add constants to llprops
    llprops['NBO'] = nbo
    llprops['NBPIX'] = nbpix
    llprops['HCG_WSIZE'] = wsize
    llprops['HCG_SIGPEAK'] = sigma_peak
    llprops['HCG_GFITMODE'] = gfitmode
    llprops['HCG_FITBOX_RMSMIN'] = gauss_rms_dev_min
    llprops['HCG_FITBOX_RMSMAX'] = gauss_rms_dev_max
    llprops['HCG_EWMIN'] = ew_min
    llprops['HCG_EWMAX'] = ew_max
    # set sources
    keys = ['NBO', 'NBPIX', 'HCG_WSIZE', 'HCG_SIGPEAK', 'HCG_GFITMODE',
            'HCG_FITBOX_RMSMIN', 'HCG_FITBOX_RMSMAX', 'HCG_EWMIN', 'HCG_EWMAX']
    llprops.set_sources(keys, func_name)
    # ------------------------------------------------------------------
    # return lprops
    return llprops


def load_hc_init_linelist(params, recipe, e2dsfile, fiber, **kwargs):
    """
    Load the initial guess at the gaussian positions (if file already exists)
    else the llprops returned in an empty placeholder waiting to be filled

    :param params:
    :param recipe:
    :param e2dsfile:
    :param fiber:
    :param kwargs:
    :return:
    """
    # set function name
    func_name = display_func(params, 'load_hc_init_linelist', __NAME__)
    # get parameters from params/kwargs
    filefmt = pcheck(params, 'WAVE_HCLL_FILE_FMT', 'filefmt', kwargs, func_name)

    # construct hcll file
    hcllfile = recipe.outputs['WAVE_HCLL'].newcopy(params=params)
    hcllfile.construct_filename(infile=e2dsfile, fiber=fiber)
    # get filename
    hcllfilename = hcllfile.filename
    # define columns for hc line list
    columns = ['ZP_INI', 'SLOPE_INI', 'EW_INI', 'XGAU_INI', 'PEAK_INI',
               'ORD_INI', 'GAUSS_RMS_DEV_INI']
    # set up storage of properties
    llprops = ParamDict()
    # find if file exists
    if os.path.exists(hcllfile.filename):
        # read table
        initable = drs_table.read_table(params, hcllfilename, fmt=filefmt,
                                        colnames=columns)
        # push values into llprops
        for col in columns:
            llprops[col] = np.array(initable[col])
        # set source
        tsource = '{0} [{1}]'.format(func_name, hcllfile.basename)
        llprops.set_sources(columns, tsource)
        # set exists
        exists = True
    # if we have no initial values just set them empty
    else:
        # loop around columns
        for col in columns:
            llprops[col] = []
        # set the source
        tsource = '{0} [{1}]'.format(func_name, 'Empty')
        llprops.set_sources(columns, tsource)
        # set exists
        exists = False
    # add filename to llprops
    llprops['HCLLFILENAME'] = hcllfile.filename
    llprops['HCLLBASENAME'] = hcllfile.basename
    llprops['HCLLCOLUMNS'] = columns
    # set source
    keys = ['HCLLFILENAME', 'HCLLBASENAME', 'HCLLCOLUMNS']
    llprops.set_sources(keys, func_name)
    # add additional properties (for plotting)
    llprops['XPIX_INI'] = []
    llprops['GFIT_INI'] = []
    llprops.set_sources(['XPIX_INI', 'GFIT_INI'], func_name)
    # return properties param dict
    return llprops, exists


def fit_gaussian_triplets(params, recipe, llprops, iprops, wavell, ampll,
                          **kwargs):
    """
    Fits the Gaussian peaks with sigma clipping

    fits a second-order xpix vs wavelength polynomial and test it against
    all other fitted lines along the order we keep track of the best fit for
    the order, i.e., the fit that provides a solution with the largest number
    of lines within +-500 m/s

    We then assume that the fit is fine, we keep the lines that match the
    "best fit" and we move to the next order.

    Once we have "valid" lines for most/all orders, we attempt to fit a
    5th order polynomial of the xpix vs lambda for all orders.
    The coefficient of the fit must be continuous from one order to the next

    we perform the fit twice, once to get a coarse solution, once to refine
    as we will trim some variables, we define them on each loop
    not 100% elegant, but who cares, it takes 5s ...

    :param params:
    :param recipe:
    :param llprops:
    :param iprops:
    :param wavell:
    :param ampll:
    :param kwargs:
    :return:
    """
    # set function name
    func_name = display_func(params, 'fit_gaussian_triplets', __NAME__)
    # get constants from params/kwargs
    nmax_bright = pcheck(params, 'WAVE_HC_NMAX_BRIGHT', 'nmax_bright', kwargs,
                         func_name)
    n_iterations = pcheck(params, 'WAVE_HC_NITER_FIT_TRIPLET', 'n_iterations',
                          kwargs, func_name)
    cat_guess_dist = pcheck(params, 'WAVE_HC_MAX_DV_CAT_GUESS',
                            'cat_guess_dist', kwargs, func_name)
    triplet_deg = pcheck(params, 'WAVE_HC_TFIT_DEG', 'triplet_deg', kwargs,
                         func_name)
    cut_fit_threshold = pcheck(params, 'WAVE_HC_TFIT_CUT_THRES',
                               'cut_fit_thres', kwargs, func_name)
    min_num_lines = pcheck(params, 'WAVE_HC_TFIT_MINNUM_LINES', 'min_num_lines',
                           kwargs, func_name)
    min_tot_num_lines = pcheck(params, 'WAVE_HC_TFIT_MINTOT_LINES',
                               'min_tot_lines', kwargs, func_name)
    order_fit_cont = pcheck(params, 'WAVE_HC_TFIT_ORDER_FIT_CONT',
                            'order_fit_cont', kwargs, func_name, mapf='list',
                            dtype=int)
    sigma_clip_num = pcheck(params, 'WAVE_HC_TFIT_SIGCLIP_NUM',
                            'sigma_clip_num', kwargs, func_name)
    sigma_clip_thres = pcheck(params, 'WAVE_HC_TFIT_SIGCLIP_THRES',
                              'sigma_clip_thres', kwargs, func_name)
    dvcut_order = pcheck(params, 'WAVE_HC_TFIT_DVCUT_ORDER', 'dvcut_order',
                         kwargs, func_name)
    dvcut_all = pcheck(params, 'WAVE_HC_TFIT_DVCUT_ALL', 'dvcut_all',
                       kwargs, func_name)
    # get poly_wave_sol from iprops
    poly_wave_sol = iprops['COEFFS']
    ncoeff = poly_wave_sol.shape[1]
    # get dimensions
    nbo, nbpix = llprops['NBO'], llprops['NBPIX']

    # set up storage
    wave_catalog = []
    amp_catalog = []
    wave_map2 = np.zeros((nbo, nbpix))
    sig = np.nan
    # get coefficients
    xgau = np.array(llprops['XGAU_INI'])
    orders = np.array(llprops['ORD_INI'])
    gauss_rms_dev = np.array(llprops['GAUSS_RMS_DEV_INI'])
    ew = np.array(llprops['EW_INI'])
    peak2 = np.array(llprops['PEAK_INI'])
    dv = np.array([])
    recon0 = []

    # deal with order_fit_cont being a different degree from poly_wave_sol
    #   degree
    if len(order_fit_cont) > ncoeff:
        order_fit_cont_old = list(order_fit_cont)
        order_fit_cont = order_fit_cont[:ncoeff]
        wargs = [order_fit_cont, order_fit_cont_old]
        wmsg = ('Order fit cont length inconsistent with fit degree. '
                '\n\tSetting to: {0} \n\t Was: {1}')
        WLOG(params, 'warning', wmsg.format(*wargs))
    if len(order_fit_cont) < ncoeff:
        order_fit_cont_old = list(order_fit_cont)
        order_fit_cont += [1] * (ncoeff - len(order_fit_cont))
        wargs = [order_fit_cont, order_fit_cont_old]
        wmsg = ('Order fit cont length inconsistent with fit degree. '
                '\n\t Setting to: {0} \n\t Was: {1}')
        WLOG(params, 'warning', wmsg.format(*wargs))

    # ------------------------------------------------------------------
    # triplet loop
    # ------------------------------------------------------------------
    for sol_iteration in range(n_iterations):
        # log that we are fitting triplet N of M
        wargs = [sol_iteration + 1, n_iterations]
        WLOG(params, 'info', textentry('40-017-00007', args=wargs))
        # get coefficients
        xgau = np.array(llprops['XGAU_INI'])
        orders = np.array(llprops['ORD_INI'])
        gauss_rms_dev = np.array(llprops['GAUSS_RMS_DEV_INI'])
        ew = np.array(llprops['EW_INI'])
        peak = np.array(llprops['PEAK_INI'])
        # get peak again for saving (to make sure nothing goes wrong
        #     in selection)
        peak2 = np.array(llprops['PEAK_INI'])
        # --------------------------------------------------------------
        # find the brightest lines for each order, only those lines will
        #     be used to derive the first estimates of the per-order fit
        # ------------------------------------------------------------------
        brightest_lines = np.zeros(len(xgau), dtype=bool)
        # loop around order
        for order_num in np.unique(orders):
            # find all order_nums that belong to this order
            good = orders == order_num
            # get the peaks for this order
            order_peaks = peak[good]
            # we may have fewer lines within the order than nmax_bright
            if mp.nansum(good) <= nmax_bright:
                nmax = mp.nansum(good) - 1
            else:
                nmax = nmax_bright
            # Find the "nmax" brightest peaks
            smallest_peak = np.sort(order_peaks)[::-1][nmax]
            good &= (peak > smallest_peak)
            # apply good mask to brightest_lines storage
            brightest_lines[good] = True
        # ------------------------------------------------------------------
        # Calculate wave solution at each x gaussian center
        # ------------------------------------------------------------------
        ini_wave_sol = np.zeros_like(xgau)
        # get wave solution for these xgau values
        for order_num in np.unique(orders):
            # find all order_nums that belong to this order
            good = orders == order_num
            # get the xgau for this order
            xgau_order = xgau[good]
            # get wave solution for this order
            pargs = [poly_wave_sol[order_num][::-1], xgau_order]
            wave_sol_order = np.polyval(*pargs)
            # pipe wave solution for order into full wave_sol
            ini_wave_sol[good] = wave_sol_order
        # ------------------------------------------------------------------
        # match gaussian peaks
        # ------------------------------------------------------------------
        # keep track of the velocity offset between predicted and observed
        #    line centers
        dv = np.repeat(np.nan, len(ini_wave_sol))
        # wavelength given in the catalog for the matched line
        wave_catalog = np.repeat(np.nan, len(ini_wave_sol))
        # amplitude given in the catolog for the matched lines
        amp_catalog = np.zeros(len(ini_wave_sol))
        # loop around all lines in ini_wave_sol
        for w_it, wave0 in enumerate(ini_wave_sol):
            # find closest catalog line to the line considered
            id_match = np.argmin(np.abs(wavell - wave0))
            # find distance between catalog and ini solution  in m/s
            distv = ((wavell[id_match] / wave0) - 1) * speed_of_light_ms
            # check that distance is below threshold
            if np.abs(distv) < cat_guess_dist:
                wave_catalog[w_it] = wavell[id_match]
                amp_catalog[w_it] = ampll[id_match]
                dv[w_it] = distv

        # ------------------------------------------------------------------
        # loop through orders and reject bright lines not within
        #     +- HC_TFIT_DVCUT km/s histogram peak
        # ------------------------------------------------------------------
        # width in dv [km/s] - though used for number of bins?
        # TODO: Question: Why km/s --> number
        nbins = 2 * int(cat_guess_dist) // 1000

        # loop around all order
        for order_num in set(orders):
            # get the good pixels in this order
            good = (orders == order_num) & (np.isfinite(dv))
            # get histogram of points for this order
            histval, histcenters = np.histogram(dv[good], bins=nbins)
            # get the center of the distribution
            dv_cen = histcenters[np.argmax(histval)]
            # define a mask to remove points away from center of histogram
            with warnings.catch_warnings(record=True) as _:
                mask = (np.abs(dv - dv_cen) > dvcut_order) & good
            # apply mask to dv and to brightest lines
            dv[mask] = np.nan
            brightest_lines[mask] = False
        # re-get the histogram of points for whole image
        histval, histcenters = np.histogram(dv[np.isfinite(dv)], bins=nbins)
        # re-find the center of the distribution
        dv_cen = histcenters[np.argmax(histval)]
        # re-define the mask to remove poitns away from center of histogram
        with warnings.catch_warnings(record=True) as _:
            mask = (np.abs(dv - dv_cen) > dvcut_all)
        # re-apply mask to dv and to brightest lines
        dv[mask] = np.nan
        brightest_lines[mask] = False
        # ------------------------------------------------------------------
        # Find best trio of lines
        # ------------------------------------------------------------------
        for order_num in np.unique(orders):
            # find this order's lines
            good = orders == order_num
            # find all usable lines in this order
            good_all = good & (np.isfinite(wave_catalog))
            # good_all = good & (np.isfinite(dv))
            # find all bright usable lines in this order
            good_bright = good_all & brightest_lines
            # get the positions of lines
            pos_bright = np.where(good_bright)[0]
            pos = np.where(good)[0]
            # get number of good_bright
            num_gb = int(mp.nansum(good_bright))
            bestn = 0
            best_coeffs = np.zeros(triplet_deg + 1)
            # get the indices of the triplets of bright lines
            indices = itertools.combinations(range(num_gb), 3)
            # loop around triplets
            for index in indices:
                # get this iterations positions
                pos_it = pos_bright[np.array(index)]
                # get the x values for this iterations position
                xx = xgau[pos_it]
                # get the y values for this iterations position
                yy = wave_catalog[pos_it]
                # fit this position's lines and take it as the best-guess
                #    solution
                coeffs = mp.nanpolyfit(xx, yy, triplet_deg)
                # extrapolate out over all lines
                fit_all = np.polyval(coeffs, xgau[good_all])
                # work out the error in velocity
                ev = ((wave_catalog[good_all] / fit_all) - 1) * speed_of_light
                # work out the number of lines to keep
                # noinspection PyTypeChecker
                nmask = np.array(np.abs(ev) < cut_fit_threshold, dtype=float)
                nkeep = mp.nansum(nmask)
                # if number of lines to keep largest seen --> store
                if nkeep > bestn:
                    bestn = nkeep
                    best_coeffs = np.array(coeffs)
            # Log the total number of valid lines found
            wargs = [order_num, bestn, mp.nansum(good_all)]
            WLOG(params, '', textentry('40-017-00008', args=wargs))
            # if we have the minimum number of lines check that we satisfy
            #   the cut_fit_threshold for all good lines and reject outliers
            if bestn >= min_num_lines:
                # extrapolate out best fit coefficients over all lines in
                #    this order
                fit_best = np.polyval(best_coeffs, xgau[good])
                # work out the error in velocity
                ev = ((wave_catalog[good] / fit_best) - 1) * speed_of_light
                abs_ev = np.abs(ev)
                # if max error in velocity greater than threshold, remove
                #    those greater than cut_fit_threshold
                if mp.nanmax(abs_ev) > cut_fit_threshold:
                    # get outliers
                    with warnings.catch_warnings(record=True) as _:
                        outliers = pos[abs_ev > cut_fit_threshold]
                    # set outliers to NaN in wave catalog
                    wave_catalog[outliers] = np.nan
                    # set dv of outliers to NaN
                    dv[outliers] = np.nan
            # else set everything to NaN
            else:
                wave_catalog[good] = np.nan
                dv[good] = np.nan

        # ------------------------------------------------------------------
        # Plot wave catalogue all lines and brightest lines
        # ------------------------------------------------------------------
        recipe.plot('WAVE_HC_BRIGHTEST_LINES', wave=wave_catalog, dv=dv,
                    mask=brightest_lines, iteration=sol_iteration,
                    niters=n_iterations)
        # ------------------------------------------------------------------
        # Keep only wave_catalog where values are finite
        # -----------------------------------------------------------------
        # create mask
        good = np.isfinite(wave_catalog)
        # apply mask
        wave_catalog = wave_catalog[good]
        amp_catalog = amp_catalog[good]
        xgau = xgau[good]
        orders = orders[good]
        dv = dv[good]
        ew = ew[good]
        gauss_rms_dev = gauss_rms_dev[good]
        peak2 = peak2[good]

        # ------------------------------------------------------------------
        # Quality check on the total number of lines found
        # ------------------------------------------------------------------
        if mp.nansum(good) < min_tot_num_lines:
            # log error that we have insufficient lines found
            eargs = [mp.nansum(good), min_tot_num_lines, func_name]
            WLOG(params, 'error', textentry('00-017-00003', args=eargs))

        # ------------------------------------------------------------------
        # Linear model slice generation
        # ------------------------------------------------------------------
        # # storage for the linear model slice
        # lin_mod_slice = np.zeros((len(xgau), mp.nansum(order_fit_cont)))
        # # construct the unit vectors for wavelength model
        # # loop around order fit continuity values
        # ii = 0
        # for expo_xpix in range(len(order_fit_cont)):
        #     # loop around orders
        #     for expo_order in range(order_fit_cont[expo_xpix]):
        #         part1 = orders ** expo_order
        #         part2 = np.array(xgau) ** expo_xpix
        #         lin_mod_slice[:, ii] = part1 * part2
        #         # iterate
        #         ii += 1

        # ------------------------------------------------------------------
        # Sigma clipping
        # ------------------------------------------------------------------
        # storage for arrays
        recon0 = np.zeros_like(wave_catalog)
        # amps0 = np.zeros(mp.nansum(order_fit_cont))

        # Loop sigma_clip_num times for sigma clipping and numerical
        #    convergence. In most cases ~10 iterations would be fine but this
        #    is fast

        # set up the loop number
        sigma_it = 0
        # set the initial value of sig to a large number (but not as large as
        #   sig_prev
        sig = np.inf
        coeffs = None

        while sigma_it < sigma_clip_num:
            sig_prev = sig

            # calculate the linear minimization
            # largs = [wave_catalog - recon0, lin_mod_slice]
            # with warnings.catch_warnings(record=True) as _:
            #   amps, recon = mp.linear_minimization(*largs)
            #   recon  = np.zeros_like(largs[0])
            coeffs, recon = wave_lmfit(params, orders, xgau, wave_catalog,
                                       order_fit_cont, nbo)

            # # add the amps and recon to new storage
            # amps0 = amps0 + amps
            # recon0 = recon0 + recon
            # print(np.nanstd(wave_catalog-recon0))

            # # loop around the amplitudes and normalise
            # for a_it in range(len(amps0)):
            #     # work out the residuals
            #     res = (wave_catalog - recon0)
            #     # work out the sum of residuals
            #     sum_r = mp.nansum(res * lin_mod_slice[:, a_it])
            #     sum_l2 = mp.nansum(lin_mod_slice[:, a_it] ** 2)
            #     # normalise by sum squared
            #     ampsx = sum_r / sum_l2
            #     # add this contribution on
            #     amps0[a_it] += ampsx
            #     recon0 += (ampsx * lin_mod_slice[:, a_it])
            # recalculate dv [in km/s]
            dv = ((wave_catalog / recon) - 1) * speed_of_light
            # calculate the standard deviation
            sig = mp.nanstd(dv)
            # do not continue if sig is larger than sig_prev
            if sig > sig_prev:
                break

            absdev = np.abs(dv / sig)

            # initialize lists for saving
            recon0_aux = []
            # lin_mod_slice_aux = []
            wave_catalog_aux = []
            amp_catalog_aux = []
            xgau_aux = []
            orders_aux = []
            dv_aux = []
            ew_aux = []
            gauss_rms_dev_aux = []
            peak2_aux = []
            # Sigma clip worst line per order
            for order_num in set(orders):
                # mask for order
                omask = orders == order_num
                # get abs dev for order
                absdev_ord = absdev[omask]
                # check if above threshold
                if mp.nanmax(absdev_ord) > sigma_clip_thres:
                    # create mask for worst line
                    sig_mask = absdev_ord < mp.nanmax(absdev_ord)
                    # apply mask
                    recon0_aux.append(recon[omask][sig_mask])
                    # lin_mod_slice_aux.append(lin_mod_slice[omask][sig_mask])
                    wave_catalog_aux.append(wave_catalog[omask][sig_mask])
                    amp_catalog_aux.append(amp_catalog[omask][sig_mask])
                    xgau_aux.append(xgau[omask][sig_mask])
                    orders_aux.append(orders[omask][sig_mask])
                    dv_aux.append(dv[omask][sig_mask])
                    ew_aux.append(ew[omask][sig_mask])
                    gauss_rms_dev_aux.append(gauss_rms_dev[omask][sig_mask])
                    peak2_aux.append(peak2[omask][sig_mask])
                # if all below threshold keep all
                else:
                    recon0_aux.append(recon[omask])
                    # lin_mod_slice_aux.append(lin_mod_slice[omask])
                    wave_catalog_aux.append(wave_catalog[omask])
                    amp_catalog_aux.append(amp_catalog[omask])
                    xgau_aux.append(xgau[omask])
                    orders_aux.append(orders[omask])
                    dv_aux.append(dv[omask])
                    ew_aux.append(ew[omask])
                    gauss_rms_dev_aux.append(gauss_rms_dev[omask])
                    peak2_aux.append(peak2[omask])
            # save aux lists to initial arrays
            orders = np.concatenate(orders_aux)
            recon0 = np.concatenate(recon0_aux)
            # lin_mod_slice = np.concatenate(lin_mod_slice_aux)
            wave_catalog = np.concatenate(wave_catalog_aux)
            amp_catalog = np.concatenate(amp_catalog_aux)
            xgau = np.concatenate(xgau_aux)
            dv = np.concatenate(dv_aux)
            ew = np.concatenate(ew_aux)
            gauss_rms_dev = np.concatenate(gauss_rms_dev_aux)
            peak2 = np.concatenate(peak2_aux)

            # Log stats RMS/SIG/N
            sig1 = sig * 1000 / np.sqrt(len(wave_catalog))
            wargs = [sigma_it, sig, sig1, len(wave_catalog)]
            WLOG(params, '', textentry('40-017-00009', args=wargs))
            sigma_it += 1
        # ------------------------------------------------------------------
        # Plot wave catalogue all lines and brightest lines
        # ------------------------------------------------------------------
        recipe.plot('WAVE_HC_TFIT_GRID', orders=orders, wave=wave_catalog,
                    recon=recon0, rms=gauss_rms_dev, xgau=xgau, ew=ew,
                    iteration=sol_iteration, niters=n_iterations)

        # ------------------------------------------------------------------
        # Construct wave map
        # ------------------------------------------------------------------
        xpix = np.arange(nbpix)
        wave_map2 = np.zeros((nbo, nbpix))
        poly_wave_sol = np.array(coeffs)[:, ::-1]
        # poly_wave_sol = np.zeros_like(iprops['COEFFS'])

        # loop around the orders
        for order_num in range(nbo):
            order_mask = orders == order_num
            if mp.nansum(order_mask) == 0:
                # log that no values were found
                wargs = [order_num]
                WLOG(params, 'warning', textentry('10-017-00005', args=wargs))

            # poly_wave_map[order_num] =
            # loop around order fit continuum to propagate new coefficients
            # ii = 0

            # for iord in range(coeffs.shape[0]):
            # for expo_xpix in range(len(order_fit_cont)):
            #    for expo_order in range(order_fit_cont[expo_xpix]):
            #         # calculate new coefficient
            #         new_coeff = (order_num ** expo_order) * amps0[ii]
            #         # add to poly wave solution
            #         poly_wave_sol[order_num, expo_xpix] += new_coeff
            #         # iterate
            #         ii += 1
            # add to wave_map2
            wcoeffs = poly_wave_sol[order_num, :][::-1]
            wave_map2[order_num, :] = np.polyval(wcoeffs, xpix)

    # save parameters to llprops
    llprops['WAVE_CATALOG'] = wave_catalog
    llprops['AMP_CATALOG'] = amp_catalog
    llprops['SIG'] = sig
    llprops['SIG1'] = sig * 1000 / np.sqrt(len(wave_catalog))
    llprops['POLY_WAVE_SOL'] = poly_wave_sol
    llprops['WAVE_MAP2'] = wave_map2
    llprops['XGAU_T'] = xgau
    llprops['ORD_T'] = orders
    llprops['GAUSS_RMS_DEV_T'] = gauss_rms_dev
    llprops['DV_T'] = dv
    llprops['EW_T'] = ew
    llprops['PEAK_T'] = peak2
    # llprops['LIN_MOD_SLICE'] = lin_mod_slice
    llprops['RECON0'] = recon0
    # set sources
    keys = ['WAVE_CATALOG', 'AMP_CATALOG', 'SIG', 'SIG1', 'POLY_WAVE_SOL',
            'WAVE_MAP2', 'XGAU_T', 'ORD_T', 'GAUSS_RMS_DEV_T', 'DV_T',
            'EW_T', 'PEAK_T', 'RECON0']
    llprops.set_sources(keys, func_name)
    # save constants to llprops (required for reproduction)
    llprops['WAVE_FIT_DEGREE'] = iprops['DEG']
    llprops['NMAX_BRIGHT'] = nmax_bright
    llprops['N_ITER'] = n_iterations
    llprops['CAT_GUESS_DIST'] = cat_guess_dist
    llprops['TRIPLET_DEG'] = triplet_deg
    llprops['CUT_FIT_THRES'] = cut_fit_threshold
    llprops['MIN_NUM_LINES'] = min_num_lines
    llprops['MIN_TOT_LINES'] = min_tot_num_lines
    llprops['ORDER_FIT_CONT'] = order_fit_cont
    llprops['SIGMA_CLIP_NUM'] = sigma_clip_num
    llprops['SIGMA_CLIP_THRES'] = sigma_clip_thres
    llprops['DVCUT_ORDER'] = dvcut_order
    llprops['DVCUT_ALL'] = dvcut_all
    llprops['INIT_WAVEFILE'] = iprops['WAVEFILE']
    # set sources
    keys = ['WAVE_FIT_DEGREE', 'NMAX_BRIGHT', 'N_ITER', 'CAT_GUESS_DIST',
            'TRIPLET_DEG', 'CUT_FIT_THRES', 'MIN_NUM_LINES', 'MIN_TOT_LINES',
            'ORDER_FIT_CONT', 'SIGMA_CLIP_NUM', 'SIGMA_CLIP_THRES',
            'DVCUT_ORDER', 'DVCUT_ALL', 'INIT_WAVEFILE']
    llprops.set_sources(keys, func_name)
    # return llprops
    return llprops


def wave_lmfit(params, orders, xgau, wave_catalog, order_fit_cont, nbo):
    # set function name
    _ = display_func(params, 'wave_lmfit', __NAME__)
    # set up an empty set of coefficents
    coeffs = np.zeros([nbo, len(order_fit_cont)])
    # get degree from order fit continuum
    fitdeg = len(order_fit_cont) - 1
    # define an array for the order numbers
    ordpix = np.arange(nbo)
    # loop around orders
    for order_num in range(nbo):
        # find all places where orders is in the order
        good = orders == order_num
        # only fit orders with more points than the order fit continuum
        #  parameters
        if np.sum(good) > len(order_fit_cont):
            # calc residuals
            # res = wave_catalog - recon0
            # calculate coefficients
            coeffs[order_num] = np.polyfit(xgau[good], wave_catalog[good],
                                           fitdeg)
    # set up storage of the amps
    amps = []
    # loop around the coefficients in order fit continuum (backwards)
    for icoeff in list(range(len(order_fit_cont)))[::-1]:
        # only fit good coeffs (non-zero)
        good = coeffs[:, icoeff] != 0
        # calculate the fit in the order direction
        ordfit = np.polyfit(ordpix[good], coeffs[good, icoeff],
                            order_fit_cont[::-1][icoeff] - 1)
        # add to storage
        amps += list(ordfit[::-1])
        # recalculate the coeff values
        coeffs[~good, icoeff] = np.polyval(ordfit, ordpix[~good])
    # recalculate the recon
    recon = np.zeros_like(xgau)
    for order_num in range(nbo):
        # find all places where orders is in the order
        good = orders == order_num
        # calculate the recon for this order
        recon[good] = np.polyval(coeffs[order_num, :], xgau[good])
    # return amps and recon
    return coeffs, recon


def generate_resolution_map(params, recipe, llprops, e2dsfile, **kwargs):
    # set function name
    func_name = display_func(params, 'generate_resolution_map', __NAME__)
    # get constants from params / kwargs
    resmap_size = pcheck(params, 'WAVE_HC_RESMAP_SIZE', 'resmap_size',
                         kwargs, func_name, mapf='list', dtype=int)
    wsize = pcheck(params, 'WAVE_HC_FITBOX_SIZE', 'wsize', kwargs,
                   func_name)
    max_dev_thres = pcheck(params, 'WAVE_HC_RES_MAXDEV_THRES', 'max_dev_thres',
                           kwargs, func_name)
    # get image
    hc_sp = np.array(e2dsfile.get_data())
    xgau = np.array(llprops['XGAU_T'])
    orders = np.array(llprops['ORD_T'])
    gauss_rms_dev = np.array(llprops['GAUSS_RMS_DEV_T'])
    wave_catalog = np.array(llprops['WAVE_CATALOG'])
    wave_map2 = np.array(llprops['WAVE_MAP2'])
    # get dimensions from image
    nbo, nbpix = hc_sp.shape

    # log progress
    WLOG(params, '', textentry('40-017-00010'))

    # storage of resolution map
    resolution_map = np.zeros(resmap_size)
    map_dvs = []
    map_lines = []
    map_params = []

    # bin size in order direction
    bin_order = int(np.ceil(nbo / resmap_size[0]))
    bin_x = int(np.ceil(nbpix / resmap_size[1]))

    # determine the line spread function

    # loop around the order bins
    for order_num in range(0, nbo, bin_order):
        # storage of map parameters
        order_dvs = []
        order_lines = []
        order_params = []
        # loop around the x position
        for xpos in range(0, nbpix // bin_x):
            # we verify that the line is well modelled by a gaussian
            # fit. If the RMS to the fit is small enough, we include
            # the line in the profile measurement
            mask = gauss_rms_dev < 0.05
            # the line must fall in the right part of the array
            # in both X and cross-dispersed directions. The
            # resolution is expected to change slightly
            mask &= (orders // bin_order) == (order_num // bin_order)
            mask &= (xgau // bin_x) == xpos
            mask &= np.isfinite(wave_catalog)

            # get the x centers for this bin
            b_xgau = xgau[mask]
            b_orders = orders[mask]
            b_wave_catalog = wave_catalog[mask]

            # set up storage for lines and dvs
            all_lines = np.zeros((mp.nansum(mask), 2 * wsize + 1))
            all_dvs = np.zeros((mp.nansum(mask), 2 * wsize + 1))

            # set up base
            base = np.zeros(2 * wsize + 1, dtype=bool)
            base[0:3] = True
            base[2 * wsize - 2: 2 * wsize + 1] = True

            # loop around all good lines
            # we express everything in velocity space rather than
            # pixels. This allows us to merge all lines in a single
            # profile and removes differences in pixel sampling and
            # resolution.
            for it in range(int(mp.nansum(mask))):
                # get limits
                border = int(b_orders[it])
                start = int(b_xgau[it] + 0.5) - wsize
                end = int(b_xgau[it] + 0.5) + wsize + 1
                # get line
                line = np.array(hc_sp)[border, start:end]
                # subtract median base and normalise line
                line -= mp.nanmedian(line[base])
                line /= mp.nansum(line)
                # calculate velocity... express things in velocity
                ratio = wave_map2[border, start:end] / b_wave_catalog[it]
                dv = -speed_of_light * (ratio - 1)
                # store line and dv
                all_lines[it, :] = line
                all_dvs[it, :] = dv

            # flatten all lines and dvs
            all_dvs = all_dvs.ravel()
            all_lines = all_lines.ravel()
            # define storage for keep mask
            # keep = np.ones(len(all_dvs), dtype=bool)
            # TODO New hack: Do not keep as hardcoded
            with warnings.catch_warnings(record=True) as _:
                keep = np.abs(all_lines) < 5

            # set an initial maximum deviation
            maxdev = np.inf
            # set up the fix parameters and initial guess parameters
            popt = np.zeros(5)
            init_guess = [0.3, 0.0, 1.0, 0.0, 0.0]
            # loop around until criteria met
            n_it = 0

            # fit the merged line profile and do some sigma-clipping
            while maxdev > max_dev_thres:
                # fit with a guassian with a slope
                fargs = dict(x=all_dvs[keep], y=all_lines[keep],
                             guess=init_guess)
                # do curve fit on point
                try:
                    # note if we change this must update map_param_names below
                    popt, pcov = mp.fit_gauss_with_slope(**fargs)
                except Exception as e:
                    # log error: Resolution map curve_fit error
                    eargs = [type(e), e, func_name]
                    WLOG(params, 'error', textentry('09-017-00002', args=eargs))
                # calculate residuals for full line list
                res = all_lines - mp.gauss_fit_s(all_dvs, *popt)
                # calculate RMS of residuals
                rms = res / mp.nanmedian(np.abs(res))
                # calculate max deviation
                maxdev = mp.nanmax(np.abs(rms[keep]))
                # re-calculate the keep mask
                with warnings.catch_warnings(record=True) as _:
                    keep[np.abs(rms) > max_dev_thres] = False
                # increase value of iterator
                n_it += 1
            # calculate resolution
            resolution = popt[2] * mp.fwhm()
            # store order criteria
            order_dvs.append(all_dvs[keep])
            order_lines.append(all_lines[keep])
            order_params.append(popt)
            # push resolution into resolution map
            resolution1 = speed_of_light / resolution
            resolution_map[order_num // bin_order, xpos] = resolution1
            # log resolution output
            wargs = [order_num, order_num + bin_order, mp.nansum(mask), xpos,
                     resolution,
                     resolution1]
            WLOG(params, '', textentry('40-017-00011', args=wargs))
        # store criteria. All lines are kept for reference
        map_dvs.append(order_dvs)
        map_lines.append(order_lines)
        map_params.append(order_params)

    # set the names of each map parameter
    map_param_names = ['Amp', 'Pos', 'Sig', 'DC', 'Slope']
    # push to llprops
    llprops['RES_MAP_DVS'] = map_dvs
    llprops['RES_MAP_LINES'] = map_lines
    llprops['RES_MAP_PARAMS'] = map_params
    llprops['RES_MAP_PARAM_NAMES'] = map_param_names
    llprops['RES_MAP'] = resolution_map
    # set source
    keys = ['RES_MAP_DVS', 'RES_MAP_LINES', 'RES_MAP_PARAMS', 'RES_MAP']
    llprops.set_sources(keys, func_name)

    # add constants to llprops
    llprops['RES_MAP_SIZE'] = resmap_size
    llprops['RES_WSIZE'] = wsize
    llprops['MAX_DEV_THRES'] = max_dev_thres
    keys = ['RES_MAP_SIZE', 'RES_WSIZE', 'MAX_DEV_THRES']
    llprops.set_sources(keys, func_name)

    # print stats
    wargs = [mp.nanmean(resolution_map), mp.nanmedian(resolution_map),
             mp.nanstd(resolution_map)]
    WLOG(params, '', textentry('40-017-00012', args=wargs))

    # map line profile map
    recipe.plot('WAVE_HC_RESMAP', params=params, resmap_size=resmap_size,
                map_dvs=map_dvs, map_lines=map_lines, map_params=map_params,
                res_map=resolution_map, nbo=nbo, nbpix=nbpix)

    # return loc
    return llprops


def all_line_storage(params, llprops, **kwargs):
    func_name = __NAME__ + '.all_line_storage()'
    # initialise up all_lines storage
    all_lines_1 = []
    # get parameters from p
    n_ord_start = pcheck(params, 'WAVE_N_ORD_START', 'n_ord_start', kwargs,
                         func_name)
    n_ord_final = pcheck(params, 'WAVE_N_ORD_FINAL', 'n_ord_final', kwargs,
                         func_name)

    # get values from loc:
    # line centers in pixels
    xgau = np.array(llprops['XGAU_T'])
    # distance from catalogue in km/s - used for sanity checks
    dv = np.array(llprops['DV_T'])
    # fitted polynomials per order
    fit_per_order = np.array(llprops['POLY_WAVE_SOL'])
    # equivalent width of fitted gaussians to each line (in pixels)
    ew = np.array(llprops['EW_T'])
    # amplitude  of fitted gaussians to each line
    peak = np.array(llprops['PEAK_T'])
    # catalogue line amplitude
    amp_catalog = np.array(llprops['AMP_CATALOG'])
    # catalogue line wavelength
    wave_catalog = np.array(llprops['WAVE_CATALOG'])
    # spectral order for each line
    ord_t = np.array(llprops['ORD_T'])

    # loop through orders
    for iord in range(n_ord_start, n_ord_final):
        # keep relevant lines
        # -> right order
        # -> finite dv
        gg = (ord_t == iord) & (np.isfinite(dv))
        # put lines into ALL_LINES structure
        # reminder:
        # gparams[0] = output wavelengths
        # gparams[1] = output sigma(gauss fit width)
        # gparams[2] = output amplitude(gauss fit)
        # gparams[3] = difference in input / output wavelength
        # gparams[4] = input amplitudes
        # gparams[5] = output pixel positions
        # gparams[6] = output pixel sigma width (gauss fit width in pixels)
        # gparams[7] = output weights for the pixel position

        # dummy array for weights
        test = np.ones(np.shape(xgau[gg]), 'd') * 1e4
        # get the final wavelength value for each peak in the order
        output_wave_1 = np.polyval(fit_per_order[iord][::-1], xgau[gg])
        # convert the pixel equivalent width to wavelength units
        xgau_ew_ini = xgau[gg] - ew[gg] / 2
        xgau_ew_fin = xgau[gg] + ew[gg] / 2
        ew_ll_ini = np.polyval(fit_per_order[iord, :], xgau_ew_ini)
        ew_ll_fin = np.polyval(fit_per_order[iord, :], xgau_ew_fin)
        ew_ll = ew_ll_fin - ew_ll_ini
        # put all lines in the order into single array
        gau_params = np.column_stack((output_wave_1, ew_ll, peak[gg],
                                      wave_catalog[gg] - output_wave_1,
                                      amp_catalog[gg],
                                      xgau[gg], ew[gg], test))
        # append the array for the order into a list
        all_lines_1.append(gau_params)
    # add to loc
    llprops['ALL_LINES_1'] = all_lines_1
    llprops['LL_PARAM_1'] = np.array(fit_per_order)
    llprops['LL_OUT_1'] = np.array(llprops['WAVE_MAP2'])
    # set sources
    keys = ['ALL_LINES_1', 'LL_PARAM_1', 'LL_OUT_1']
    llprops.set_sources(keys, func_name)

    # For compatibility with already defined functions, I need to save
    # here all_lines_2
    llprops['ALL_LINES_2'] = list(all_lines_1)
    llprops.set_source('ALL_LINES_2', func_name)

    # return llprops
    return llprops


def generate_res_files(params, llprops, outfile, **kwargs):
    func_name = __NAME__ + '.generate_res_files()'
    # get constants from p
    resmap_size = pcheck(params, 'WAVE_HC_RESMAP_SIZE', 'resmap_size',
                         kwargs, func_name, mapf='list', dtype=int)
    # get data from loc
    map_dvs = np.array(llprops['RES_MAP_DVS'])
    map_lines = np.array(llprops['RES_MAP_LINES'])
    map_params = np.array(llprops['RES_MAP_PARAMS'])
    map_param_names = llprops['RES_MAP_PARAM_NAMES']
    resolution_map = np.array(llprops['RES_MAP'])
    # get dimensions
    nbo, nbpix = llprops['NBO'], llprops['NBPIX']
    # bin size in order direction
    bin_order = int(np.ceil(nbo / resmap_size[0]))
    bin_x = int(np.ceil(nbpix / resmap_size[1]))
    # get ranges of values
    order_range = np.arange(0, nbo, bin_order)
    x_range = np.arange(0, nbpix // bin_x)
    # loop around the order bins
    resdata, hdicts = [], []
    for order_num in order_range:
        # loop around the x position
        for xpos in x_range:
            # set up tmp file
            tmpfile = outfile.completecopy(outfile)
            # get the correct data
            all_dvs = map_dvs[order_num // bin_order][xpos]
            all_lines = map_lines[order_num // bin_order][xpos]
            gparams = map_params[order_num // bin_order][xpos]
            resolution = resolution_map[order_num // bin_order][xpos]
            # get start and end order
            start_order = order_num
            end_order = start_order + bin_order - 1
            # generate header keywordstores
            kw_numorders = ['NORDS', '', 'Total number of orders']
            kw_startorder = ['ORDSTART', '', 'First order covered in res map']
            kw_endorder = ['ORDEND', '', 'Last order covered in res map']
            kw_tot_regions = ['TREGIONS', '', 'Total number of regions']
            kw_region = ['REGION', '', 'Region along x-axis in res map']
            largs = [order_num, order_num + bin_order - 1, xpos]
            comment = 'Resolution: order={0}-{1} r={2}'
            kw_res = ['RESOL', '', comment.format(*largs)]
            # add keys to headed
            tmpfile.add_hkey(kw_numorders, value=nbo)
            tmpfile.add_hkey(kw_startorder, value=start_order)
            tmpfile.add_hkey(kw_endorder, value=end_order)
            tmpfile.add_hkey(kw_tot_regions, value=len(x_range))
            tmpfile.add_hkey(kw_region, value=xpos)
            tmpfile.add_hkey(kw_res, value=resolution)
            # loop aroound gaussian parameters
            for g_it, gparam in enumerate(gparams):
                # set up the gaussian parameter header comment
                gcomm = 'Gaussian {3}: order={0}-{1} r={2} '
                gargs = largs + [map_param_names[g_it]]
                # set up the gaussian parameter header keystore
                kw_params = ['GPARAM{0}'.format(g_it), '', gcomm.format(*gargs)]
                # add gaussian parameter header key to hdict
                tmpfile.add_hkey(kw_params, value=gparam)
            # append this hdict to hicts
            hdicts.append(tmpfile.hdict.to_fits_header())
            # push data into correct columns
            resdata.append(np.array(list(zip(all_dvs, all_lines))))
    # return data list and header list
    return resdata, hdicts


# =============================================================================
# Define littrow worker functions
# =============================================================================
def littrow(params, recipe, llprops, start, end, wavell, infile, blaze,
            iteration=1, fiber=None, **kwargs):
    func_name = display_func(params, 'littrow', __NAME__)
    # get parameters from params/kwargs
    t_order_start = pcheck(params, 'WAVE_T_ORDER_START', 't_order_start',
                           kwargs, func_name)

    # ------------------------------------------------------------------
    # Littrow test
    # ------------------------------------------------------------------
    # calculate echelle orders
    o_orders = np.arange(start, end)
    echelle_order = t_order_start - o_orders

    # Do Littrow check
    ckwargs = dict(infile=infile, wavell=wavell[start:end, :],
                   iteration=iteration, log=True, blaze=blaze[start:end, :])
    llprops = calculate_littrow_sol(params, llprops, echelle_order, **ckwargs)
    # ------------------------------------------------------------------
    # Littrow test plot
    # ------------------------------------------------------------------
    # Plot wave solution littrow check
    plotname = 'WAVE_LITTROW_CHECK{0}'.format(iteration)
    recipe.plot(plotname, params=params, llprops=llprops, iteration=iteration,
                fiber=fiber)
    # only plot summary plot for final iteration
    if iteration == 2:
        recipe.plot('SUM_WAVE_LITTROW_CHECK', params=params, llprops=llprops,
                    iteration=iteration, fiber=fiber)
    # ------------------------------------------------------------------
    # extrapolate Littrow solution
    # ------------------------------------------------------------------
    ekwargs = dict(infile=infile, wavell=wavell, iteration=iteration)
    llprops = extrapolate_littrow_sol(params, llprops, **ekwargs)

    # ------------------------------------------------------------------
    # Plot littrow solution
    # ------------------------------------------------------------------
    plotname = 'WAVE_LITTROW_EXTRAP{0}'.format(iteration)
    recipe.plot(plotname, params=params, llprops=llprops,
                iteration=iteration, fiber=fiber, image=infile.get_data())
    # only plot summary plot for final iteration
    if iteration == 2:
        recipe.plot('SUM_WAVE_LITTROW_EXTRAP', params=params, llprops=llprops,
                    iteration=iteration, fiber=fiber, image=infile.get_data())
    # ------------------------------------------------------------------
    # add parameters to llprops
    llprops['LITTROW_START_{0}'.format(iteration)] = start
    llprops['LITTROW_END_{0}'.format(iteration)] = end
    llprops['T_ORDER_START'] = t_order_start
    # add source
    keys = ['LITTROW_START_{0}'.format(iteration),
            'LITTROW_END_{0}'.format(iteration), 'T_ORDER_START']
    llprops.set_sources(keys, func_name)

    # ------------------------------------------------------------------
    # return props
    return llprops


def calculate_littrow_sol(params, llprops, echelle_order, wavell, infile,
                          blaze, iteration=1, log=False, **kwargs):
    """
    Calculate the Littrow solution for this iteration for a set of cut points

    Uses ALL_LINES_i  where i = iteration to calculate the littrow solutions
    for defined cut points (given a cut_step and fit_deg of
    IC_LITTROW_CUT_STEP_i and IC_LITTROW_FIT_DEG_i where i = iteration)

    :param params: parameter dictionary, ParamDict containing constants

    :param llprops: parameter dictionary, ParamDict containing data
        Must contain at least:
            ECHELLE_ORDERS: numpy array (1D), the echelle order numbers
            HCDATA: numpy array (2D), the image data (used for shape)
            ALL_LINES_i: list of numpy arrays, length = number of orders
                         each numpy array contains gaussian parameters
                         for each found line in that order

            where i = iteration

    :param echelle_order: numpy array (1D), the orders (labeled by echelle
                          diffraction number not position)

    :param wavell: numpy array (1D), the initial guess wavelengths for each line

    :param infile: DrsFitsFile, drs fits file instance containing the data
                   for the hc or file file (i.e. must have infile.data) -
                   used only to work out the number of orders and number of
                   pixels

    :param blaze: numpy array (2D), the blaze file

    :param iteration: int, the iteration number (used so we can store multiple
                      calculations in loc, defines "i" in input and outputs
                      from p and loc
    :param log: bool, if True will print a final log message on completion with
                some stats

    :return llprops: parameter dictionary, the updated parameter dictionary
            Adds/updates the following:
                X_CUT_POINTS_i: numpy array (1D), the x pixel cut points
                LITTROW_MEAN_i: list, the mean position of each cut point
                LITTROW_SIG_i: list, the mean FWHM of each cut point
                LITTROW_MINDEV_i: list, the minimum deviation of each cut point
                LITTROW_MAXDEV_i: list, the maximum deviation of each cut point
                LITTROW_PARAM_i: list of numpy arrays, the gaussian fit
                                 coefficients of each cut point
                LITTROW_XX_i: list, the order positions of each cut point
                LITTROW_YY_i: list, the residual fit of each cut point

                where i = iteration

    ALL_LINES_i definition:
        ALL_LINES_i[row] = [gparams1, gparams2, ..., gparamsN]

                    where:
                        gparams[0] = output wavelengths
                        gparams[1] = output sigma (gauss fit width)
                        gparams[2] = output amplitude (gauss fit)
                        gparams[3] = difference in input/output wavelength
                        gparams[4] = input amplitudes
                        gparams[5] = output pixel positions
                        gparams[6] = output pixel sigma width
                                          (gauss fit width in pixels)
                        gparams[7] = output weights for the pixel position
    """
    # set function name
    func_name = display_func(params, 'calculate_littrow_sol', __NAME__)
    # get parameters from params/kwrags
    remove_orders = pcheck(params, 'WAVE_LITTROW_REMOVE_ORDERS',
                           'remove_orders', kwargs, func_name, mapf='list',
                           dtype=int)
    # TODO: Fudge factor - Melissa will fix this :)
    n_order_init = pcheck(params, 'WAVE_LITTROW_ORDER_INIT_{0}'.format(1),
                          'n_order_init', kwargs, func_name)
    n_order_start = pcheck(params, 'WAVE_N_ORD_START', 'n_order_start',
                           kwargs, func_name)
    n_order_final = pcheck(params, 'WAVE_N_ORD_FINAL', 'n_order_final',
                           kwargs, func_name)
    x_cut_step = pcheck(params, 'WAVE_LITTROW_CUT_STEP_{0}'.format(iteration),
                        'x_cut_step', kwargs, func_name)
    fit_degree = pcheck(params, 'WAVE_LITTROW_FIG_DEG_{0}'.format(iteration),
                        'fit_degree', kwargs, func_name)
    # get parameters from loc
    torder = echelle_order
    ll_out = wavell
    # get the total number of orders to fit
    num_orders = len(echelle_order)
    # get dimensions from image
    ydim, xdim = infile.get_data().shape
    # ----------------------------------------------------------------------
    # test if n_order_init is in remove_orders
    if n_order_init in remove_orders:
        # TODO: Fudge factor - Melissa will fix this
        wargs = ['WAVE_LITTROW_ORDER_INIT_{0}'.format(1),
                 params['WAVE_LITTROW_ORDER_INIT_{0}'.format(1)],
                 "WAVE_LITTROW_REMOVE_ORDERS", func_name]
        WLOG(params, 'error', textentry('00-017-00004', args=wargs))
    # ----------------------------------------------------------------------
    # test if n_order_init is in remove_orders
    if n_order_final in remove_orders:
        wargs = ['WAVE_LITTROW_ORDER_FINAL_{0}'.format(1),
                 params['WAVE_LITTROW_ORDER_FINAL_{0}'.format(1)],
                 "WAVE_LITTROW_REMOVE_ORDERS", func_name]
        WLOG(params, 'error', textentry('00-017-00004', args=wargs))
    # ----------------------------------------------------------------------
    # check that all remove orders exist
    for remove_order in remove_orders:
        if remove_order not in np.arange(n_order_final):
            wargs = [remove_order, 'WAVE_LITTROW_REMOVE_ORDERS', n_order_init,
                     n_order_final, func_name]
            WLOG(params, 'error', textentry('00-017-00005', args=wargs))
    # ----------------------------------------------------------------------
    # check to make sure we have some orders left
    if len(np.unique(remove_orders)) == n_order_final - n_order_start:
        # log littrow error
        eargs = ['WAVE_LITTROW_REMOVE_ORDERS', func_name]
        WLOG(params, 'error', textentry('00-017-00006', args=eargs))
    # ----------------------------------------------------------------------
    # deal with removing orders (via weighting stats)
    rmask = np.ones(num_orders, dtype=bool)
    if len(remove_orders) > 0:
        rmask[np.array(remove_orders)] = False
    # storage of results
    keys = ['LITTROW_MEAN', 'LITTROW_SIG', 'LITTROW_MINDEV',
            'LITTROW_MAXDEV', 'LITTROW_PARAM', 'LITTROW_XX', 'LITTROW_YY',
            'LITTROW_INVORD', 'LITTROW_FRACLL', 'LITTROW_PARAM0',
            'LITTROW_MINDEVORD', 'LITTROW_MAXDEVORD', 'LITTROW_INIT']
    for key in keys:
        nkey = key + '_{0}'.format(iteration)
        llprops[nkey] = []
        llprops.set_source(nkey, func_name)
    # construct the Littrow cut points
    x_cut_points = np.arange(x_cut_step, xdim - x_cut_step, x_cut_step)
    # save to storage
    llprops['X_CUT_POINTS_{0}'.format(iteration)] = x_cut_points
    llprops.set_source('X_CUT_POINTS_{0}'.format(iteration), func_name)

    # loop around cut points and get littrow parameters and stats
    for it in range(len(x_cut_points)):
        # this iterations x cut point
        x_cut_point = x_cut_points[it]
        # get the echelle order values
        orderpos = torder[rmask]
        # get the inverse order number
        inv_orderpos = 1.0 / orderpos
        # get the fractional wavelength contrib. at each x cut point
        ll_point = ll_out[:, x_cut_point][rmask]
        ll_start_point = ll_out[n_order_init, x_cut_point]
        frac_ll_point = ll_point / ll_start_point
        # fit the inverse order numbers against the fractional
        #    wavelength contrib.
        coeffs = mp.nanpolyfit(inv_orderpos, frac_ll_point, fit_degree)[::-1]
        coeffs0 = mp.nanpolyfit(inv_orderpos, frac_ll_point, fit_degree)[::-1]
        # calculate the fit values
        cfit = np.polyval(coeffs[::-1], inv_orderpos)
        # calculate the residuals
        res = cfit - frac_ll_point
        # find the largest residual
        largest = mp.nanmax(abs(res))
        sigmaclip = abs(res) != largest
        # remove the largest residual
        inv_orderpos_s = inv_orderpos[sigmaclip]
        frac_ll_point_s = frac_ll_point[sigmaclip]
        # refit the inverse order numbers against the fractional
        #    wavelength contrib. after sigma clip
        coeffs = mp.nanpolyfit(inv_orderpos_s, frac_ll_point_s, fit_degree)
        coeffs = coeffs[::-1]
        # calculate the fit values (for all values - including sigma clipped)
        cfit = np.polyval(coeffs[::-1], inv_orderpos)
        # calculate the blaze mask
        blazemask = np.isfinite(blaze[:, x_cut_points[it]])
        # calculate residuals (in km/s) between fit and original values
        respix = speed_of_light * (cfit - frac_ll_point) / frac_ll_point
        # set values in respix to NaN where blaze is not finite (too low)
        respix[~blazemask] = np.nan
        # calculate stats
        mean = mp.nanmean(respix)
        mean2 = mp.nanmean(respix ** 2)
        rms = np.sqrt(mean2 - mean ** 2)
        mindev = mp.nanmin(respix)
        maxdev = mp.nanmax(respix)
        mindev_ord = mp.nanargmin(respix)
        maxdev_ord = mp.nanargmax(respix)
        # add to storage
        llprops['LITTROW_INVORD_{0}'.format(iteration)].append(inv_orderpos)
        llprops['LITTROW_FRACLL_{0}'.format(iteration)].append(frac_ll_point)
        llprops['LITTROW_MEAN_{0}'.format(iteration)].append(mean)
        llprops['LITTROW_SIG_{0}'.format(iteration)].append(rms)
        llprops['LITTROW_MINDEV_{0}'.format(iteration)].append(mindev)
        llprops['LITTROW_MAXDEV_{0}'.format(iteration)].append(maxdev)
        llprops['LITTROW_MINDEVORD_{0}'.format(iteration)].append(mindev_ord)
        llprops['LITTROW_MAXDEVORD_{0}'.format(iteration)].append(maxdev_ord)
        llprops['LITTROW_PARAM_{0}'.format(iteration)].append(coeffs)
        llprops['LITTROW_PARAM0_{0}'.format(iteration)].append(coeffs0)
        llprops['LITTROW_XX_{0}'.format(iteration)].append(orderpos)
        llprops['LITTROW_YY_{0}'.format(iteration)].append(respix)
        llprops['LITTROW_INIT_{0}'.format(iteration)].append(n_order_init)
        # if log then log output
        if log:
            # log: littrow check at X={0} mean/rms/min/max/frac
            eargs = [x_cut_point, mean * 1000, rms * 1000, mindev * 1000,
                     maxdev * 1000, mindev / rms, maxdev / rms]
            WLOG(params, '', textentry('40-017-00013', args=eargs))

    # add constants
    llprops['LITTROW_REMOVE_ORDERS'] = remove_orders
    llprops['LITTROW_ORDER_INIT_{0}'.format(iteration)] = n_order_init
    llprops['LITTROW_ORDER_START_{0}'.format(iteration)] = n_order_start
    llprops['LITTROW_ORDER_END_{0}'.format(iteration)] = n_order_final
    llprops['LITTROW_X_CUT_STEP_{0}'.format(iteration)] = x_cut_step
    llprops['LITTROW_FIT_DEG_{0}'.format(iteration)] = fit_degree
    # set sources
    keys = ['LITTROW_REMOVE_ORDERS',
            'LITTROW_ORDER_INIT_{0}'.format(iteration),
            'LITTROW_ORDER_START_{0}'.format(iteration),
            'LITTROW_ORDER_END_{0}'.format(iteration),
            'LITTROW_X_CUT_STEP_{0}'.format(iteration),
            'LITTROW_FIT_DEG_{0}'.format(iteration)]
    llprops.set_sources(keys, func_name)

    # return loc
    return llprops


def extrapolate_littrow_sol(params, llprops, wavell, infile, iteration=0,
                            **kwargs):
    """
    Extrapolate and fit the Littrow solution at defined points and return
    the wavelengths, solutions, and cofficients of the littorw fits

    :param params: parameter dictionary, ParamDict containing constants

    :param llprops: parameter dictionary, ParamDict containing data

    :param wavell: numpy array (1D), the initial guess wavelengths for each line

    :param infile: DrsFitsFile, drs fits file instance containing the data
                   for the hc or file file (i.e. must have infile.data) -
                   used only to work out the number of orders and number of
                   pixels

    :param iteration: int, the iteration number (used so we can store multiple
                      calculations in loc, defines "i" in input and outputs
                      from p and loc

    :return llprops: parameter dictionary, the updated parameter dictionary
            Adds/updates the following:
                LITTROW_EXTRAP_i: numpy array (2D),
                                  size=([no. orders] by [no. cut points])
                                  the wavelength values at each cut point for
                                  each order
                LITTROW_EXTRAP_SOL_i: numpy array (2D),
                                  size=([no. orders] by [no. cut points])
                                  the wavelength solution at each cut point for
                                  each order
                LITTROW_EXTRAP_PARAM_i: numy array (2D),
                                  size=([no. orders] by [the fit degree +1])
                                  the coefficients of the fits for each cut
                                  point for each order

                where i = iteration
    """
    func_name = __NAME__ + '.extrapolate_littrow_sol()'
    # get parameters from p
    fit_degree = pcheck(params, 'WAVE_LITTROW_EXT_ORDER_FIT_DEG', 'fig_degree',
                        kwargs, func_name)
    t_order_start = pcheck(params, 'WAVE_T_ORDER_START', 't_order_start',
                           kwargs, func_name)
    ikey = 'WAVE_LITTROW_ORDER_INIT_{0}'
    n_order_init = pcheck(params, ikey.format(iteration), 'n_order_init',
                          kwargs, func_name)
    # get parameters from llprop
    litt_param = llprops['LITTROW_PARAM_{0}'.format(iteration)]
    # get the dimensions of the data
    ydim, xdim = infile.get_data().shape
    # get the pixel positions
    x_points = np.arange(xdim)
    # construct the Littrow cut points (in pixels)
    x_cut_points = llprops['X_CUT_POINTS_{0}'.format(iteration)]
    # construct the Littrow cut points (in wavelength)
    ll_cut_points = wavell[n_order_init][x_cut_points]
    # set up storage
    littrow_extrap = np.zeros((ydim, len(x_cut_points)), dtype=float)
    littrow_extrap_sol = np.zeros_like(infile.get_data())
    littrow_extrap_param = np.zeros((ydim, fit_degree + 1), dtype=float)
    # calculate the echelle order position for this order
    echelle_order_nums = t_order_start - np.arange(ydim)
    # calculate the inverse echelle order nums
    inv_echelle_order_nums = 1.0 / echelle_order_nums
    # loop around the x cut points
    for it in range(len(x_cut_points)):
        # evaluate the fit for this x cut (fractional wavelength contrib.)
        cfit = np.polyval(litt_param[it][::-1], inv_echelle_order_nums)
        # evaluate littrow fit for x_cut_points on each order (in wavelength)
        litt_extrap_o = cfit * ll_cut_points[it]
        # add to storage
        littrow_extrap[:, it] = litt_extrap_o
    # loop around orders and extrapolate
    for order_num in range(ydim):
        # fit the littrow extrapolation
        param = mp.nanpolyfit(x_cut_points, littrow_extrap[order_num],
                              fit_degree)[::-1]
        # add to storage
        littrow_extrap_param[order_num] = param
        # evaluate the polynomial for all pixels in data
        littrow_extrap_sol[order_num] = np.polyval(param[::-1], x_points)

    # add to storage
    llprops['LITTROW_EXTRAP_{0}'.format(iteration)] = littrow_extrap
    llprops['LITTROW_EXTRAP_SOL_{0}'.format(iteration)] = littrow_extrap_sol
    llprops['LITTROW_EXTRAP_PARAM_{0}'.format(iteration)] = littrow_extrap_param

    sources = ['LITTROW_EXTRAP_{0}'.format(iteration),
               'LITTROW_EXTRAP_SOL_{0}'.format(iteration),
               'LITTROW_EXTRAP_PARAM_{0}'.format(iteration)]
    llprops.set_sources(sources, func_name)

    # add constants
    llprops['LITTROW_EXT_FITDEG_{0}'.format(iteration)] = fit_degree
    llprops['LITTROW_EXT_ORD_START_{0}'.format(iteration)] = n_order_init
    # set source
    keys = ['LITTROW_EXT_FITDEG_{0}'.format(iteration),
            'LITTROW_EXT_ORD_START_{0}'.format(iteration)]
    llprops.set_sources(keys, func_name)

    # return loc
    return llprops


# =============================================================================
# Define fp worker functions
# =============================================================================
def add_fpline_calc_cwid(params, llprops, fpe2dsfile, blaze, dopd0, fit_deg,
                         fp_large_jump, n_ord_start_fp, n_ord_final_fp,
                         cm_ind):
    """
    Derives the FP line wavelengths from the first solution
    Follows the Bauer et al 2015 procedure

    :param params: parameter dictionary, ParamDict containing constants

    :param llprops: parameter dictionary, ParamDict containing data
        Must contain at least:
            FPDATA: the FP e2ds data
            LITTROW_EXTRAP_SOL_1: the wavelength solution derived from the HC
                                  and Littrow-constrained
            LL_PARAM_1: the parameters of the wavelength solution
            ALL_LINES_2: list of numpy arrays, length = number of orders
                       each numpy array contains gaussian parameters
                       for each found line in that order
            BLAZE: numpy array (2D), the blaze data

    :param fpe2dsfile:
    :param blaze:
    :param dopd0:
    :param fit_deg:
    :param fp_large_jump:
    :param n_ord_start_fp:
    :param n_ord_final_fp:
    :param cm_ind:

    :return llprops: parameter dictionary, the updated parameter dictionary
            Adds/updates the following:
                FP_LL_POS: numpy array, the initial wavelengths of the FP lines
                FP_XX_POS: numpy array, the pixel positions of the FP lines
                FP_M: numpy array, the FP line numbers
                FP_DOPD_T: numpy array, the measured cavity width for each line
                FP_AMPL: numpy array, the FP line amplitudes
                FP_LL_POS_NEW: numpy array, the corrected wavelengths of the
                               FP lines
                ALL_LINES_2: list of numpy arrays, length = number of orders
                             each numpy array contains gaussian parameters
                             for each found line in that order

    """
    func_name = __NAME__ + '.add_fpline_calc_cwid()'
    # find FP lines
    llprops = find_fp_lines_new(params, llprops, fpe2dsfile)
    # get all_lines_2 from llprops
    all_lines_2 = llprops['ALL_LINES_2']
    # set up storage
    llpos_all, xxpos_all, ampl_all = [], [], []
    m_fp_all, weight_bl_all, order_rec_all, dopd_all = [], [], [], []
    ll_prev, m_prev = np.array([]), np.array([])
    # ----------------------------------------------------------------------
    # loop through the orders from red to blue
    for order_num in range(n_ord_final_fp, n_ord_start_fp - 1, -1):
        # select the lines in the order
        gg = llprops['ORDPEAK'] == order_num
        # store the initial wavelengths of the lines
        ctmp = llprops['LITTROW_EXTRAP_PARAM_1'][order_num][::-1]
        # store the pixel positions of the lines
        xxpos = llprops['XPEAK'][gg]
        llpos = np.polyval(ctmp, xxpos)
        # get the median pixel difference between successive lines
        #    (to check for gaps)
        xxpos_diff_med = mp.nanmedian(xxpos[1:] - xxpos[:-1])
        # store the amplitudes of the fp lines
        ampl = llprops['AMPPEAK'][gg]
        # store the values of the blaze at the pixel positions of the lines
        weight_bl = np.zeros_like(llpos)
        # get and normalize blaze for the order
        nblaze = blaze[order_num] / mp.nanmax(blaze[order_num])
        for it in range(1, len(llpos)):
            weight_bl[it] = nblaze[int(np.round(xxpos[it]))]
        # store the order numbers
        order_rec = llprops['ORDPEAK'][gg]
        # set up storage for line numbers
        mpeak = np.zeros_like(llpos)
        # line number for the last (reddest) line of the order (by FP equation)
        mpeak[-1] = int(dopd0 / llpos[-1])
        # calculate successive line numbers
        for it in range(len(llpos) - 2, -1, -1):
            # check for gap in x positions
            flocdiff = xxpos[it + 1] - xxpos[it]
            lowcond = xxpos_diff_med - (0.25 * xxpos_diff_med)
            highcond = xxpos_diff_med + (0.25 * xxpos_diff_med)
            if lowcond < flocdiff < highcond:
                # no gap: add 1 to line number of previous line
                mpeak[it] = mpeak[it + 1] + 1
            # if there is a gap, fix it
            #    Note we have to check if the gap has multiple jumps!
            else:
                # get line x positions
                flocx0 = xxpos[it]
                flocx1 = xxpos[it + 1]
                # get line wavelengths
                floc0 = llpos[it]
                floc1 = llpos[it + 1]
                # estimate the number of peaks missed
                m_offset = int(np.round((flocx1 - flocx0) / xxpos_diff_med))
                # add to m of previous peak
                mpeak[it] = mpeak[it + 1] + m_offset
                # verify there's no dopd jump, fix if present
                dopd_1 = (mpeak[it] * floc0 / 2 - dopd0 / 2)
                dopd_2 = (mpeak[it + 1] * floc1 / 2 - dopd0 / 2)
                # do loops to check jumps until it converges
                if dopd_1 - dopd_2 > fp_large_jump:
                    while (dopd_1 - dopd_2) > fp_large_jump:
                        mpeak[it] = mpeak[it] - 1
                        dopd_1 = (mpeak[it] * floc0 / 2 - dopd0 / 2)
                        dopd_2 = (mpeak[it + 1] * floc1 / 2 - dopd0 / 2)
                elif dopd_1 - dopd_2 < -fp_large_jump:
                    while (dopd_1 - dopd_2) < -fp_large_jump:
                        mpeak[it] = mpeak[it] + 1
                        dopd_1 = (mpeak[it] * floc0 / 2 - dopd0 / 2)
                        dopd_2 = (mpeak[it + 1] * floc1 / 2 - dopd0 / 2)
        # determination of observed effective cavity width
        dopd_t = mpeak * llpos / 2
        # store m and d
        m_fp = mpeak
        dopd_t = dopd_t
        # for orders other than the reddest, attempt to cross-match
        if order_num != n_ord_final_fp:
            # check for overlap
            if llpos[cm_ind] > ll_prev[0]:
                # find closest peak in overlap and get its m value
                ind = np.abs(ll_prev - llpos[cm_ind]).argmin()
                # the peak matching the reddest may not always be found!!
                # define maximum permitted difference
                llpos_diff_med = np.median(llpos[1:] - llpos[:-1])
                # print(llpos_diff_med)
                # print(abs(ll_prev[ind] - floc['llpos'][-1]))
                # check if the difference is over the limit
                if abs(ll_prev[ind] - llpos[-1]) > 1.5 * llpos_diff_med:
                    # print('overlap line not matched')
                    ll_diff = ll_prev[ind] - llpos[-1]
                    ind2 = -2
                    # loop over next reddest peak until they match
                    while ll_diff > 1.5 * llpos_diff_med:
                        # check there is still overlap
                        if llpos[ind2] > ll_prev[0]:
                            ind = np.abs(ll_prev - llpos[ind2]).argmin()
                            ll_diff = ll_prev[ind] - llpos[ind2]
                            ind2 -= 1
                        else:
                            break
                m_match = m_prev[ind]
                # save previous mpeak calculated
                m_init = mpeak[cm_ind]
                # recalculate m if there's an offset from cross_match
                m_offset_c = m_match - m_init
                if m_offset_c != 0:
                    mpeak = mpeak + m_offset_c
                    # print note for dev if different
                    wargs = [order_num, m_match - m_init]
                    WLOG(params, 'debug', textentry('90-017-00001', args=wargs))
                    # recalculate observed effective cavity width
                    dopd_t = mpeak * llpos / 2
                    # store new m and d
                    m_fp = mpeak
            else:
                # log that no overlap for order
                wargs = [order_num]
                WLOG(params, 'warning', textentry('10-017-00008', args=wargs))
                # save previous mpeak calculated
                m_init = mpeak[cm_ind]
                m_test = mpeak[cm_ind]
                # get dopd for last line of current & first of last order
                dopd_curr = (m_test * llpos[cm_ind] / 2 - dopd0 / 2)
                dopd_prev = (m_prev[0] * ll_prev[0] / 2 - dopd0 / 2)
                # do loops to check jumps
                if dopd_curr - dopd_prev > fp_large_jump:
                    while (dopd_curr - dopd_prev) > fp_large_jump:
                        m_test = m_test - 1
                        dopd_curr = (m_test * llpos[cm_ind] / 2 - dopd0 / 2)
                elif dopd_curr - dopd_prev < -fp_large_jump:
                    while (dopd_curr - dopd_prev) < -fp_large_jump:
                        m_test = m_test + 1
                        dopd_curr = (m_test * llpos[cm_ind] / 2 - dopd0 / 2)
                # recalculate m if there's an offset from cross_match
                m_offset_c = m_test - m_init
                if m_offset_c != 0:
                    mpeak = mpeak + m_offset_c
                    # print note for dev if different
                    # print note for dev if different
                    wargs = [order_num, mpeak[cm_ind] - m_init]
                    WLOG(params, 'debug', textentry('90-017-00001', args=wargs))
                    # recalculate observed effective cavity width
                    dopd_t = mpeak * llpos / 2
                    # store new m and d
                    m_fp = mpeak

        # add to storage
        llpos_all += list(llpos)
        xxpos_all += list(xxpos)
        ampl_all += list(ampl)
        m_fp_all += list(m_fp)
        weight_bl_all += list(weight_bl)
        order_rec_all += list(order_rec)
        # difference in cavity width
        dopd_all += list(dopd_t - dopd0 / 2)
        # save numpy arrays of current order to be previous in next loop
        ll_prev = np.array(llpos)
        m_prev = np.array(m_fp)
    # ----------------------------------------------------------------------
    # convert to numpy arrays
    llpos_all = np.array(llpos_all)
    xxpos_all = np.array(xxpos_all)
    ampl_all = np.array(ampl_all)
    m_fp_all = np.array(m_fp_all)
    weight_bl_all = np.array(weight_bl_all)
    order_rec_all = np.array(order_rec_all)
    dopd_all = np.array(dopd_all)
    # ----------------------------------------------------------------------
    # fit a polynomial to line number v measured difference in cavity
    #     width, weighted by blaze
    with warnings.catch_warnings(record=True) as w:
        coeffs = mp.nanpolyfit(m_fp_all, dopd_all, fit_deg,
                               w=weight_bl_all)[::-1]
    drs_log.warninglogger(params, w, funcname=func_name)
    # get the values of the fitted cavity width difference
    cfit = np.polyval(coeffs[::-1], m_fp_all)
    # update line wavelengths using the new cavity width fit
    newll = (dopd0 + 2 * cfit) / m_fp_all
    # ----------------------------------------------------------------------
    # insert fp lines into all_lines2 (at the correct positions)
    all_lines_2 = insert_fp_lines(params, newll, llpos_all, all_lines_2,
                                  order_rec_all, xxpos_all, ampl_all)
    # ----------------------------------------------------------------------
    # add to llprops
    llprops['FP_LL_POS'] = llpos_all
    llprops['FP_XX_POS'] = xxpos_all
    llprops['FP_M'] = m_fp_all
    llprops['FP_DOPD_OFFSET'] = dopd_all
    llprops['FP_AMPL'] = ampl_all
    llprops['FP_LL_POS_NEW'] = newll
    llprops['ALL_LINES_2'] = all_lines_2
    llprops['FP_DOPD_OFFSET_COEFF'] = coeffs
    llprops['FP_DOPD_OFFSET_FIT'] = cfit
    llprops['FP_ORD_REC'] = order_rec_all
    # set sources
    sources = ['FP_LL_POS', 'FP_XX_POS', 'FP_M', 'FP_DOPD_OFFSET',
               'FP_AMPL', 'FP_LL_POS_NEW', 'ALL_LINES_2',
               'FP_DOPD_OFFSET_COEFF', 'FP_DOPD_OFFSET_FIT', 'FP_ORD_REC']
    llprops.set_sources(sources, func_name)

    # return llprops
    return llprops


def find_fp_lines_new(params, llprops, fpe2dsfile, **kwargs):
    func_name = __NAME__ + '.find_fp_lines_new()'
    # get constants from params/kwargs
    normpercent = pcheck(params, 'WAVE_FP_NORM_PERCENTILE', 'normpercent',
                         kwargs, func_name)
    limit = pcheck(params, 'WAVE_FP_PEAK_LIM', 'limit', kwargs, func_name)
    cutwidth = pcheck(params, 'WAVE_FP_P2P_WIDTH_CUT', 'cutwidth',
                      kwargs, func_name)
    # get redefined variables (pipe inputs to llprops with correct names)
    # set fpfile as ref file
    llprops['SPEREF'] = fpe2dsfile.get_data()
    # set wavelength solution as the one from the HC lines
    llprops['WAVE'] = llprops['LITTROW_EXTRAP_SOL_1']
    # use rv module to get the position of FP peaks from reference file
    #   first need to set all input parameters (via ckwargs)
    ckwargs = dict(limit=limit, normpercent=normpercent)
    # measure the positions of the FP peaksKW_WFP_BSIZE
    llprops = velocity.measure_fp_peaks(params, llprops, **ckwargs)
    # use rv module to remove wide/spurious/double-fitted peaks
    # remove wide / double-fitted peaks
    llprops = velocity.remove_wide_peaks(params, llprops, cutwidth=cutwidth)

    # add constants to llprops
    llprops['USED_NORMPERCENT'] = normpercent
    llprops['USED_LIMIT'] = limit
    llprops['USED_CUTWIDTH'] = cutwidth
    # set sources
    keys = ['USED_NORMPERCENT', 'USED_BOX_SIZE', 'USED_CUTWIDTH']
    llprops.set_sources(keys, func_name)

    # return loc
    return llprops


# TODO: Melissa - needs to remove fp/hc start/final
def insert_fp_lines(params, newll, llpos_all, all_lines_2, order_rec_all,
                    xxpos_all, ampl_all, **kwargs):
    func_name = __NAME__ + '.insert_fp_lines()'
    # get constants from params/kwargs
    n_ord_start_fp = pcheck(params, 'WAVE_N_ORD_START', 'n_ord_start',
                            kwargs, func_name)
    n_ord_final_fp = pcheck(params, 'WAVE_N_ORD_FINAL', 'n_ord_final',
                            kwargs, func_name)
    n_ord_start_hc = pcheck(params, 'WAVE_N_ORD_START', 'n_ord_start',
                            kwargs, func_name)
    n_ord_final_hc = pcheck(params, 'WAVE_N_ORD_FINAL', 'n_ord_final',
                            kwargs, func_name)
    # ----------------------------------------------------------------------
    # insert FP lines into all_lines at the correct orders
    # ----------------------------------------------------------------------
    # define wavelength difference limit for keeping a line
    fp_cut = 3 * mp.nanstd(newll - llpos_all)
    # define correct starting order number
    start_order = min(n_ord_start_fp, n_ord_start_hc)
    # define starting point for prepended zeroes
    insert_count = 0
    for order_num in range(n_ord_start_fp, n_ord_final_fp):
        if order_num < n_ord_start_hc:
            # prepend zeros to all_lines if FP solution is fitted for
            #     bluer orders than HC was
            all_lines_2.insert(insert_count, np.zeros((1, 8), dtype=float))
            # add 1 to insertion counter for next order
            insert_count += 1
        elif order_num >= n_ord_final_hc:
            # append zeros to all_lines if FP solution is fitted for
            #     redder orders than HC was
            all_lines_2.append(np.zeros((1, 8), dtype=float))
        for it in range(len(order_rec_all)):
            # find lines corresponding to order number
            if order_rec_all[it] == order_num:
                # check wavelength difference below limit
                if abs(newll[it] - llpos_all[it]) < fp_cut:
                    # put FP line data into an array
                    # newdll = newll[it] - llpos_all[it]
                    fp_line = np.array([newll[it], 0.0, 0.0, 0.0,
                                        0.0, xxpos_all[it], 0.0, ampl_all[it]])
                    fp_line = fp_line.reshape((1, 8))
                    # append FP line data to all_lines
                    torder = order_num - start_order
                    tvalues = [all_lines_2[torder], fp_line]
                    all_lines_2[torder] = np.concatenate(tvalues)
    # return all lines 2
    return all_lines_2


# TODO: Not used any more?
def fit_1d_solution(params, llprops, wavell, start, end, fiber, errx_min,
                    fit_degree, max_ll_fit_rms, t_order_start, weight_thres,
                    iteration=0):
    func_name = __NAME__ + '.fit_1d_solution()'

    # get data from loc
    all_lines = llprops['ALL_LINES_{0}'.format(iteration)]
    # Get the number of orders
    num_orders = wavell.shape[0]
    # calculate echelle orders
    o_orders = np.arange(start, end)
    torder = t_order_start - o_orders

    # ------------------------------------------------------------------
    # fit 1d wavelength solution
    # ------------------------------------------------------------------
    # get maximum weight from errx_min
    max_weight = 1.0 / errx_min ** 2
    # -------------------------------------------------------------------------
    # set up all storage
    final_iter = []  # will fill [wmean, var, length]
    final_param = []  # will fill the fit coefficients
    final_details = []  # will fill [lines, x_fit, cfit, weight]
    final_dxdl = []  # will fill the derivative of the fit coefficients
    scale = []  # conversion factor to km/s
    # set up global stats
    sweight = 0.0
    wsumres = 0.0
    wsumres2 = 0.0
    # loop around orders
    for order_num in np.arange(num_orders):
        # ---------------------------------------------------------------------
        # get this orders parameters
        weights = all_lines[order_num][:, 7]
        diff_in_out = all_lines[order_num][:, 3]
        centers = all_lines[order_num][:, 0]
        pixelcenters = all_lines[order_num][:, 5]
        # ---------------------------------------------------------------------
        # only keep the lines that have postive weight
        goodlinemask = weights > weight_thres
        lines = centers[goodlinemask] + diff_in_out[goodlinemask]
        x_fit = pixelcenters[goodlinemask]
        # get the weights and modify by max_weight
        weight = (weights[goodlinemask] * max_weight)
        weight = weight / (weights[goodlinemask] + max_weight)
        # ---------------------------------------------------------------------
        # iteratively try to improve the fit
        improve = 1
        iter0, details = [], []
        wmean, var = 0, 0
        # sigma clip the largest rms until RMS < MAX_RMS
        while improve:
            # fit wavelength to pixel solution (with polynomial)
            ww = np.sqrt(weight)
            coeffs = mp.nanpolyfit(lines, x_fit, fit_degree, w=ww)[::-1]
            # calculate the fit
            cfit = np.polyval(coeffs[::-1], lines)
            # calculate the variance
            res = cfit - x_fit
            wsig = mp.nansum(res ** 2 * weight) / mp.nansum(weight)
            wmean = (mp.nansum(res * weight) / mp.nansum(weight))
            var = wsig - (wmean ** 2)
            # append stats
            iter0.append([np.array(wmean), np.array(var),
                          np.array(coeffs)])
            details.append([np.array(lines), np.array(x_fit),
                            np.array(cfit), np.array(weight)])
            # check improve condition (RMS > MAX_RMS)
            ll_fit_rms = abs(res) * np.sqrt(weight)
            badrms = np.array(ll_fit_rms > max_ll_fit_rms, dtype=float)
            improve = mp.nansum(badrms)
            # set largest weighted residual to zero
            largest = mp.nanmax(ll_fit_rms)
            badpoints = ll_fit_rms == largest
            weight[badpoints] = 0.0
            # only keep the lines that have postive weight
            goodmask = weight > 0.0
            # check that we have points
            if mp.nansum(goodmask) == 0:
                eargs = [order_num, max_ll_fit_rms]
                WLOG(params, 'error', textentry('00-017-00007', args=eargs))
            else:
                lines = lines[goodmask]
                x_fit = x_fit[goodmask]
                weight = weight[goodmask]
        # ---------------------------------------------------------------------
        # log the fitted wave solution
        wargs = [torder[order_num], t_order_start - torder[order_num],
                 wavell[order_num][0], wavell[order_num][-1],
                 wmean * 1000, np.sqrt(var) * 1000, len(iter0),
                 len(details[0][1]), len(details[-1][1])]
        WLOG(params, '', textentry('40-017-00023', args=wargs))
        # ---------------------------------------------------------------------
        # append to all storage
        # ---------------------------------------------------------------------
        # append the last wmean, var and number of lines
        num_lines = len(details[-1][1])
        final_iter.append([iter0[-1][0], iter0[-1][1], num_lines])
        # append the last coefficients
        final_param.append(iter0[-1][2])
        # append the last details [lines, x_fit, cfit, weight]
        final_details.append(np.array(details[-1]))
        # append the derivative of the coefficients
        poly = np.poly1d(iter0[-1][2][::-1])
        dxdl = np.polyder(poly)(details[-1][0])
        final_dxdl.append(dxdl)
        # ---------------------------------------------------------------------
        # global statistics
        # ---------------------------------------------------------------------
        # work out conversion factor
        convert = speed_of_light / (dxdl * details[-1][0])
        # get res1
        res1 = details[-1][1] - details[-1][2]
        # sum the weights (recursively)
        sweight += mp.nansum(details[-1][3])
        # sum the weighted residuals in km/s
        wsumres += mp.nansum(res1 * convert * details[-1][3])
        # sum the weighted squared residuals in km/s
        wsumres2 += mp.nansum(details[-1][3] * (res1 * convert) ** 2)
        # store the conversion to km/s
        scale.append(convert)
    # convert to arrays
    final_iter = np.array(final_iter)
    final_param = np.array(final_param)
    # calculate the final var and mean
    final_mean = (wsumres / sweight)
    final_var = (wsumres2 / sweight) - (final_mean ** 2)
    # log the global stats
    total_lines = mp.nansum(final_iter[:, 2])
    wargs = [fiber, final_mean * 1000.0, np.sqrt(final_var) * 1000.0,
             total_lines, 1000.0 * np.sqrt(final_var / total_lines)]
    WLOG(params, 'info', textentry('40-017-00024', args=wargs))
    # save outputs to loc
    llprops['X_MEAN_{0}'.format(iteration)] = final_mean
    llprops['X_VAR_{0}'.format(iteration)] = final_var
    llprops['X_ITER_{0}'.format(iteration)] = final_iter
    llprops['X_PARAM_{0}'.format(iteration)] = final_param
    llprops['X_DETAILS_{0}'.format(iteration)] = final_details
    llprops['SCALE_{0}'.format(iteration)] = scale
    # set sources
    keys = ['X_MEAN_{0}'.format(iteration), 'X_VAR_{0}'.format(iteration),
            'X_ITER_{0}'.format(iteration), 'X_PARAM_{0}'.format(iteration),
            'X_DETAILS_{0}'.format(iteration), 'SCALE_{0}'.format(iteration)]
    llprops.set_sources(keys, func_name)

    # ------------------------------------------------------------------
    # invert 1d wavelength solution
    # ------------------------------------------------------------------
    # get data from loc
    details = llprops['X_DETAILS_{0}'.format(iteration)]
    iter0 = llprops['X_ITER_{0}'.format(iteration)]
    # Get the number of orders
    num_orders = wavell.shape[0]
    # loop around orders
    inv_details = []
    inv_params = []
    sweight = 0.0
    wsumres = 0.0
    wsumres2 = 0.0
    # loop around orders
    for order_num in np.arange(num_orders):
        # get the lines and wavelength fit for this order
        lines = details[order_num][0]
        cfit = details[order_num][2]
        wei = details[order_num][3]
        # get the number of lines
        num_lines = len(lines)
        # set weights
        weight = np.ones(num_lines, dtype=float)
        # get fit coefficients
        coeffs = mp.nanpolyfit(cfit, lines, fit_degree, w=weight)[::-1]
        # get the y values for the coefficients
        icfit = np.polyval(coeffs[::-1], cfit)
        # work out the residuals
        res = icfit - lines
        # work out the normalised res in km/s
        nres = speed_of_light * (res / lines)
        # append values to storage
        inv_details.append([nres, wei])
        inv_params.append(coeffs)
        # ------------------------------------------------------------------
        # invert parameters
        # ------------------------------------------------------------------
        # sum the weights (recursively)
        sweight += mp.nansum(wei)
        # sum the weighted residuals in km/s
        wsumres += mp.nansum(nres * wei)
        # sum the weighted squared residuals in km/s
        wsumres2 += mp.nansum(wei * nres ** 2)
    # calculate the final var and mean
    final_mean = (wsumres / sweight)
    final_var = (wsumres2 / sweight) - (final_mean ** 2)
    # ------------------------------------------------------------------
    # log the inversion process
    total_lines = mp.nansum(iter0[:, 2])
    wargs = [final_mean * 1000.0, np.sqrt(final_var) * 1000.0,
             1000.0 * np.sqrt(final_var / total_lines)]
    WLOG(params, '', textentry('40-017-00025', args=wargs))
    # ------------------------------------------------------------------
    # save outputs to loc
    llprops['LL_MEAN_{0}'.format(iteration)] = final_mean
    llprops['LL_VAR_{0}'.format(iteration)] = final_var
    llprops['LL_PARAM_{0}'.format(iteration)] = np.array(inv_params)
    llprops['LL_DETAILS_{0}'.format(iteration)] = inv_details
    # set the sources
    keys = ['LL_MEAN_{0}'.format(iteration), 'LL_VAR_{0}'.format(iteration),
            'LL_PARAM_{0}'.format(iteration),
            'LL_DETAILS_{0}'.format(iteration)]
    llprops.set_sources(keys, func_name)
    # ------------------------------------------------------------------
    # get the total number of orders to fit
    num_orders = len(llprops['ALL_LINES_{0}'.format(iteration)])
    # get the dimensions of the data
    ydim, xdim = llprops['NBO'], llprops['NBPIX']
    # get inv_params
    inv_params = llprops['LL_PARAM_{0}'.format(iteration)]
    # set pixel shift to zero, as doesn't apply here
    pixel_shift_inter = 0
    pixel_shift_slope = 0
    # get new line list
    ll_out = mp.get_ll_from_coefficients(pixel_shift_inter, pixel_shift_slope,
                                         inv_params, xdim, num_orders)
    # get the first derivative of the line list
    dll_out = mp.get_dll_from_coefficients(inv_params, xdim, num_orders)
    # find the central pixel value
    centpix = ll_out.shape[1] // 2
    # get the mean pixel scale (in km/s/pixel) of the central pixel
    norm = dll_out[:, centpix] / ll_out[:, centpix]
    meanpixscale = speed_of_light * mp.nansum(norm) / len(ll_out[:, centpix])
    # get the total number of lines used
    total_lines = int(mp.nansum(llprops['X_ITER_2'][:, 2]))
    # add to llprops
    llprops['LL_OUT_{0}'.format(iteration)] = ll_out
    llprops['DLL_OUT_{0}'.format(iteration)] = dll_out
    llprops['TOTAL_LINES_{0}'.format(iteration)] = total_lines
    # set sources
    keys = ['LL_OUT_{0}'.format(iteration), 'DLL_OUT_{0}'.format(iteration),
            'TOTAL_LINES_{0}'.format(iteration)]
    llprops.set_sources(keys, func_name)
    # log mean pixel scale at center
    wargs = [fiber, meanpixscale]
    WLOG(params, 'info', textentry('40-017-00026', args=wargs))
    # ------------------------------------------------------------------
    return llprops


# TODO: Not used any more?
def fit_1d_solution_sigclip(params, llprops, fiber, n_init, n_fin,
                            ll_fit_degree):
    """
    Fits the 1D solution between pixel position and wavelength
    Uses sigma-clipping and removes modulo 1 pixel errors

    :param params: parameter dictionary, ParamDict containing constants

    :param llprops: parameter dictionary, ParamDict containing data
        Must contain at least:
            FP_XX_NEW: FP pixel pisitions
            FP_LL_NEW: FP wavelengths
            FP_ORD_NEW: FP line orders
            FP_WEI: FP line weights

    :param fiber:
    :param n_init:
    :param n_fin:
    :param ll_fit_degree:

    :return loc: parameter dictionary, the updated parameter dictionary
            Adds/updates the following:
                FP_ORD_CL = np array, FP line orders (sigma-clipped)
                FP_LLIN_CL = np array, FP wavelengths (sigma-clipped)
                FP_XIN_CL = np array, FP initial pixel values (sigma-clipped)
                FP_XOUT_CL = np array, FP corrected pixel values (sigma-clipped)
                FP_WEI_CL = np array, weights (sigma-clipped)
                RES_CL = np array, normalised residuals in km/s
                LL_OUT_2 = np array, output wavelength map
                LL_PARAM_2 = np array, polynomial coefficients
                X_MEAN_2 = final mean
                X_VAR_2 = final var
                TOTAL_LINES_2 = total lines
                SCALE_2 = scale

    """

    # set up storage arrays
    xpix = np.arange(llprops['NBPIX'])
    wave_map_final = np.zeros((n_fin - n_init, llprops['NBPIX']))
    poly_wave_sol_final = np.zeros((n_fin - n_init, ll_fit_degree + 1))
    fp_x_in_clip, fp_x_final_clip = [], []
    fp_ll_in_clip, fp_ll_final_clip, fp_ord_clip = [], [], []
    wsumres, sweight, wsumres2 = [], [], []
    wei_clip, res_clip, scale = [], [], []
    # fit x v wavelength w/sigma-clipping
    # we remove modulo 1 pixel errors in line centers - 3 iterations
    n_ite_mod_x = 3
    for ite in range(n_ite_mod_x):
        # set up storage
        wsumres = 0.0
        wsumres2 = 0.0
        sweight = 0.0
        fp_x_final_clip = []
        fp_x_in_clip = []
        fp_ll_final_clip = []
        fp_ll_in_clip = []
        fp_ord_clip = []
        res_clip = []
        wei_clip = []
        scale = []
        res_modx = np.zeros_like(llprops['FP_XX_NEW'])
        # loop over the orders
        for onum in range(n_fin - n_init):
            # order mask
            ord_mask = np.where(llprops['FP_ORD_NEW'] == onum +
                                n_init)
            # get FP line pixel positions for the order
            fp_x_ord = llprops['FP_XX_NEW'][ord_mask]
            # get new FP line wavelengths for the order
            fp_ll_new_ord = np.asarray(llprops['FP_LL_NEW'])[ord_mask]
            # get weights for the order
            wei_ord = np.asarray(llprops['FP_WEI'])[ord_mask]
            # fit solution for the order w/sigma-clipping
            coeffs, mask = sigclip_polyfit(params, fp_x_ord, fp_ll_new_ord,
                                           ll_fit_degree, wei_ord)
            # store the coefficients
            poly_wave_sol_final[onum] = coeffs[::-1]
            # get the residuals modulo x
            tmpmodx = (fp_ll_new_ord / np.polyval(coeffs, fp_x_ord)) - 1
            res_modx[ord_mask] = speed_of_light * tmpmodx
            # mask input arrays for statistics
            fp_x_ord = fp_x_ord[mask]
            fp_ll_new_ord = fp_ll_new_ord[mask]
            wei_ord = wei_ord[mask]
            # get final wavelengths
            fp_ll_final_ord = np.polyval(coeffs, fp_x_ord)
            # save wave map
            wave_map_final[onum] = np.polyval(coeffs, xpix)
            # save masked arrays
            fp_x_final_clip.append(fp_x_ord)
            fp_x_in_clip.append(llprops['FP_XX_INIT'][ord_mask][mask])
            fp_ll_final_clip.append(fp_ll_final_ord)
            fp_ll_in_clip.append(fp_ll_new_ord)
            fp_ord_clip.append(llprops['FP_ORD_NEW'][ord_mask][mask])
            wei_clip.append(wei_ord)
            # residuals in km/s
            # calculate the residuals for the final masked arrays
            res = fp_ll_final_ord - fp_ll_new_ord
            res_clip.append(res * speed_of_light / fp_ll_new_ord)
            # save stats
            # get the derivative of the coefficients
            poly = np.poly1d(coeffs)
            dldx = np.polyder(poly)(fp_x_ord)
            # work out conversion factor
            convert = speed_of_light * dldx / fp_ll_final_ord
            scale.append(convert)
            # sum the weights (recursively)
            sweight += mp.nansum(wei_clip[onum])
            # sum the weighted residuals in km/s
            wsumres += mp.nansum(res_clip[onum] * wei_clip[onum])
            # sum the weighted squared residuals in km/s
            wsumres2 += mp.nansum(wei_clip[onum] * res_clip[onum] ** 2)
        # we construct a sin/cos model of the error in line center position
        # and fit it to the residuals
        cosval = np.cos(2 * np.pi * (llprops['FP_XX_NEW'] % 1))
        sinval = np.sin(2 * np.pi * (llprops['FP_XX_NEW'] % 1))

        # find points that are not residual outliers
        # We fit a zeroth order polynomial, so it returns
        # outliers to the mean value.
        outl_fit, mask_all = sigclip_polyfit(params, llprops['FP_XX_NEW'],
                                             res_modx, 0)
        # create model
        sumcos1 = mp.nansum(cosval[mask_all] * res_modx[mask_all])
        sumcos2 = mp.nansum(cosval[mask_all] ** 2)
        acos = sumcos1 / sumcos2
        sumsin1 = mp.nansum(sinval[mask_all] * res_modx[mask_all])
        sumsin2 = mp.nansum(sinval[mask_all] ** 2)

        asin = sumsin1 / sumsin2
        model_sin = ((cosval * acos) + (sinval * asin))
        # update the xpeak positions with model
        llprops['FP_XX_NEW'] += model_sin / 2.2
    # calculate the final var and mean
    total_lines = len(np.concatenate(fp_ll_in_clip))
    final_mean = wsumres / sweight
    final_var = (wsumres2 / sweight) - (final_mean ** 2)
    # log the global stats
    wargs = [fiber, final_mean * 1000.0, np.sqrt(final_var) * 1000.0,
             total_lines, 1000.0 * np.sqrt(final_var / total_lines)]
    WLOG(params, 'info', textentry('40-017-00024', args=wargs))
    # save final (sig-clipped) arrays to loc
    llprops['FP_ORD_CL'] = np.array(np.concatenate(fp_ord_clip).ravel())
    llprops['FP_LLIN_CL'] = np.array(np.concatenate(fp_ll_in_clip).ravel())
    llprops['FP_XIN_CL'] = np.array(np.concatenate(fp_x_in_clip).ravel())
    llprops['FP_XOUT_CL'] = np.array(np.concatenate(fp_x_final_clip).ravel())
    llprops['FP_WEI_CL'] = np.array(np.concatenate(wei_clip).ravel())
    llprops['RES_CL'] = np.array(np.concatenate(res_clip).ravel())
    llprops['LL_OUT_2'] = wave_map_final
    llprops['LL_PARAM_2'] = poly_wave_sol_final
    llprops['X_MEAN_2'] = final_mean
    llprops['X_VAR_2'] = final_var
    llprops['TOTAL_LINES_2'] = total_lines
    llprops['SCALE_2'] = scale
    # set up x_details and ll_details structures for line list table:
    # X_DETAILS_i: list, [lines, xfit, cfit, weight] where
    #   lines= original wavelength-centers used for the fit
    #   xfit= original pixel-centers used for the fit
    #   cfit= fitted pixel-centers using fit coefficients
    #   weight=the line weights used
    # LL_DETAILS_i: numpy array (1D), the [nres, wei] where
    #   nres = normalised residuals in km/s
    #   wei = the line weights
    x_details = []
    ll_details = []
    for ord_num in range(n_init, n_fin):
        omask = llprops['FP_ORD_CL'] == ord_num
        x_details.append([llprops['FP_LLIN_CL'][omask],
                          llprops['FP_XIN_CL'][omask],
                          llprops['FP_XOUT_CL'][omask],
                          llprops['FP_WEI_CL'][omask]])
        ll_details.append([llprops['RES_CL'][omask],
                           llprops['FP_WEI_CL'][omask]])
    llprops['X_DETAILS_2'] = x_details
    llprops['LL_DETAILS_2'] = ll_details
    # return llprops
    return llprops


def no_overlap_match_calc(params, ord_num, fp_ll_ord, fp_ll_ord_prev,
                          m_ord_prev, dif_n, **kwargs):
    """
    Calculate the absolute FP peak numbers when there is no overlap from one
    order to the next by estimating the number of peaks missed

    :param params: parameter dictionary, ParamDict containing constants
        Must contain at least:
            WAVE_FP_LLDIF_MIN: float, defines the minimum fraction of the median
                        wavelength difference we accept as no gap between lines
            WAVE_FP_LLDIF_MIN: float, defines the maximum fraction of the median
                        wavelength difference we accept as no gap between lines

    :param ord_num: the order number
    :param fp_ll_ord: the FP peak wavelengths for the current order
    :param fp_ll_ord_prev: the FP peak wavelengths for the previous order
    :param m_ord_prev: absolute peak numbers of previous order
    :param dif_n: differential peak numbering for all orders

    :return m_ord: absolute peak numbers for current order

    """
    func_name = __NAME__ + '.no_overlap_match_calc()'
    # get constants from params/kwargs
    lldif_min = pcheck(params, 'WAVE_FP_LLDIF_MIN', 'lldif_max', kwargs,
                       func_name)
    lldif_max = pcheck(params, 'WAVE_FP_LLDIF_MAX', 'lldif_min', kwargs,
                       func_name)

    ll_diff = fp_ll_ord[1:] - fp_ll_ord[:-1]
    ll_diff_prev = fp_ll_ord_prev[1:] - fp_ll_ord_prev[:-1]

    # print warning re no overlap
    WLOG(params, 'warning', textentry('10-017-00009', args=[ord_num]))
    # masks to keep only difference between no-gap lines for current order
    mask_ll_diff = ll_diff > (lldif_min * mp.nanmedian(ll_diff))
    mask_ll_diff &= ll_diff < (lldif_max * mp.nanmedian(ll_diff))
    # get previous min/max limits
    prevminlim = lldif_min * mp.nanmedian(ll_diff_prev)
    prevmaxlim = lldif_max * mp.nanmedian(ll_diff_prev)
    # masks to keep only difference between no-gap lines for previous order
    mask_ll_diff_prev = ll_diff_prev > prevminlim
    mask_ll_diff_prev &= ll_diff_prev < prevmaxlim
    # get last diff for current order, first for prev
    ll_diff_fin = ll_diff[mask_ll_diff][-1]
    ll_diff_init = ll_diff_prev[mask_ll_diff_prev][0]
    # calculate wavelength difference between end lines
    ll_miss = fp_ll_ord_prev[0] - fp_ll_ord[-1]
    # estimate lines missed using ll_diff from each order
    m_end_1 = int(np.round(ll_miss / ll_diff_fin))
    m_end_2 = int(np.round(ll_miss / ll_diff_init))
    # check they are the same, print warning if not
    if not m_end_1 == m_end_2:
        # log that we are missing line estimate miss-match
        wargs = [m_end_1, m_end_2, ll_diff_fin, ll_diff_init]
        WLOG(params, 'warning', textentry('10-017-00010', args=wargs))
    # calculate m_end, absolute peak number for last line of the order
    m_end = int(m_ord_prev[0]) + m_end_1
    # define array of absolute peak numbers for the order
    m_ord = m_end + dif_n[ord_num][-1] - dif_n[ord_num]
    # return m_ord
    return m_ord


def sigclip_polyfit(params, xx, yy, degree, weight=None, **kwargs):
    """
    Fit a polynomial with sigma-clipping of outliers

    :param params: parameter dictionary, ParamDict containing constants
    :param xx: numpy array, x values to fit
    :param yy: numpy array, y values to fit
    :param degree: int, the degree of fit
    :param weight: optional, numpy array, weights to the fit

    :return coeff: the fit coefficients
    :return mask: the sigma-clip mask

    """
    func_name = __NAME__ + '.sigclip_polyfit()'
    # read constants from p
    sigclip = pcheck(params, 'WAVE_FP_SIGCLIP', 'sigclip', kwargs, func_name)
    # initialise the while loop
    sigmax = sigclip + 1
    # initialise mask
    mask = np.ones_like(xx, dtype='Bool')
    # set up coeffs
    coeff = np.zeros(degree)
    # while we are above sigclip
    while sigmax > sigclip:
        # Need to mask weight here if not None
        if weight is not None:
            weight2 = weight[mask]
        else:
            weight2 = None
        # fit on masked values
        coeff = mp.nanpolyfit(xx[mask], yy[mask], deg=degree, w=weight2)
        # get residuals (not masked or dimension breaks)
        res = yy - np.polyval(coeff, xx)
        # normalise the residuals
        res = np.abs(res / mp.nanmedian(np.abs(res[mask])))
        # get the max residual in sigmas
        sigmax = mp.nanmax(res[mask])
        # mask all outliers
        if sigmax > sigclip:
            mask[res >= sigclip] = False
    # return the coefficients and mask
    return coeff, mask


def find_num_fppeak_diff(llprops, blaze, n_init, n_fin, wave_blaze_thres,
                         xdiff_min, xdiff_max):
    """

    :param llprops:
    :param blaze:
    :param n_init:
    :param n_fin:
    :param wave_blaze_thres:
    :param xdiff_min:
    :param xdiff_max:
    :return:
    """
    # set up storage
    # FP peak wavelengths
    fp_ll = []
    # FP peak orders
    fp_order = []
    # FP peak pixel centers
    fp_xx = []
    # FP peak differential numbering
    dif_n = []
    # FP peak amplitudes
    fp_amp = []
    # loop over orders
    # TODO: Question: Should this be n_fin + 1
    for order_num in range(n_init, n_fin):
        # ------------------------------------------------------------------
        # Number FP peaks differentially and identify gaps
        # ------------------------------------------------------------------
        # get mask of FP lines for order
        mask_fp = llprops['ORDPEAK'] == order_num
        # get x values of FP lines
        x_fp = llprops['XPEAK'][mask_fp]
        # get amplitudes of FP lines (to save)
        amp_fp = llprops['AMPPEAK'][mask_fp]
        # get the coeff for this order
        poly_wave_coeffs = llprops['POLY_WAVE_SOL'][order_num]
        # get 30% blaze mask
        with warnings.catch_warnings(record=True) as _:
            maxblaze = mp.nanmax(blaze[order_num])
            maskblaze = np.where(blaze[order_num] > wave_blaze_thres * maxblaze)
        # keep only x values at above 30% blaze
        bmask = (mp.nanmax(maskblaze) > x_fp) & (mp.nanmin(maskblaze) < x_fp)
        amp_fp = amp_fp[bmask]
        x_fp = x_fp[bmask]
        # initial differential numbering (assuming no gaps)
        peak_num_init = np.arange(len(x_fp))
        # find gaps in x
        # get array of x differences
        x_diff = x_fp[1:] - x_fp[:-1]
        # get median of x difference
        med_x_diff = mp.nanmedian(x_diff)
        # get indices where x_diff differs too much from median
        cond1 = x_diff < xdiff_min * med_x_diff
        cond2 = x_diff > xdiff_max * med_x_diff
        x_gap_ind = np.where(cond1 | cond2)[0]
        # get the opposite mask (no-gap points)
        cond3 = x_diff > xdiff_min * med_x_diff
        cond4 = x_diff < xdiff_max * med_x_diff
        x_good_ind = np.where(cond3 & cond4)[0]
        # fit x_fp v x_diff for good points
        good_xfp = x_fp[1:][x_good_ind]
        good_xdiff = x_diff[x_good_ind]
        cfit_xdiff = mp.nanpolyfit(good_xfp, good_xdiff, 2)
        # loop over gap points
        for it in range(len(x_gap_ind)):
            # get estimated xdiff value from the fit
            x_diff_aux = np.polyval(cfit_xdiff, x_fp[1:][x_gap_ind[it]])
            # estimate missed peaks
            x_jump = np.round((x_diff[x_gap_ind[it]] / x_diff_aux)) - 1
            # add the jump
            peak_num_init[x_gap_ind[it] + 1:] += int(x_jump)
        # Calculate original (HC sol) FP wavelengths
        fp_ll.append(np.polyval(poly_wave_coeffs[::-1], x_fp))
        # save differential numbering
        dif_n.append(peak_num_init)
        # save order number
        fp_order.append(np.ones(len(x_fp)) * order_num)
        # save x positions
        fp_xx.append(x_fp)
        # save amplitudes
        fp_amp.append(amp_fp)
    # return to main
    return fp_ll, dif_n, fp_order, fp_xx, fp_amp


def assign_abs_fp_numbers(params, fp_ll, dif_n, m_vec, m_ord_prev, n_init,
                          n_fin, ll_offset):
    """

    :param params:
    :param fp_ll:
    :param dif_n:
    :param m_vec:
    :param m_ord_prev:
    :param n_init:
    :param n_fin:
    :param ll_offset:
    :return:
    """
    # set up m_ord
    # m_ord = np.nan
    # loop over orders from reddest-1 to bluest
    for ord_num in range(n_fin - n_init - 2, -1, -1):
        # define auxiliary arrays with ll for order and previous order
        fp_ll_ord = fp_ll[ord_num]
        fp_ll_ord_prev = fp_ll[ord_num + 1]
        # define median ll diff for both orders
        fp_ll_diff_med = mp.nanmedian(fp_ll_ord[1:] - fp_ll_ord[:-1])
        fp_ll_diff_prev_med = mp.nanmedian(fp_ll_ord_prev[1:] -
                                           fp_ll_ord_prev[:-1])
        # check if overlap
        if fp_ll_ord[-1] >= fp_ll_ord_prev[0]:
            # get overlapping peaks for both
            # allow WAVE_FP_LL_OFFSET*lldiff offsets
            ord_over_lim = fp_ll_ord_prev[0] - (ll_offset * fp_ll_diff_prev_med)
            prev_ord_lim = fp_ll_ord[-1] + (ll_offset * fp_ll_diff_med)
            mask_ord_over = fp_ll_ord >= ord_over_lim
            fp_ll_ord_over = fp_ll_ord[mask_ord_over]
            mask_prev_over = fp_ll_ord_prev <= prev_ord_lim
            fp_ll_prev_over = fp_ll_ord_prev[mask_prev_over]
            # loop over peaks to find closest match
            mindiff_peak = []
            mindiff_peak_ind = []
            for j in range(len(fp_ll_ord_over)):
                # get differences for peak j
                diff = np.abs(fp_ll_prev_over - fp_ll_ord_over[j])
                # save the minimum and its index
                mindiff_peak.append(mp.nanmin(diff))
                mindiff_peak_ind.append(np.argmin(diff))
            # get the smallest difference and its index
            mindiff_all = mp.nanmin(np.array(mindiff_peak))
            mindiff_all_ind = int(np.argmin(np.array(mindiff_peak)))

            # check that smallest difference is in fact a true line match
            if mindiff_all < (ll_offset * fp_ll_diff_med):
                # set the match m index as the one for the smallest diff
                m_match_ind = mindiff_peak_ind[mindiff_all_ind]
                # get line number for peak with smallest difference
                m_end = m_ord_prev[mask_prev_over][m_match_ind]
                # get differential peak number for peak with smallest diff
                dif_n_match = dif_n[ord_num][mask_ord_over][mindiff_all_ind]
                # define array of absolute peak numbers for the order
                m_ord = m_end + dif_n_match - dif_n[ord_num]
            # if not treat as no overlap
            else:
                m_ord = no_overlap_match_calc(params, ord_num, fp_ll_ord,
                                              fp_ll_ord_prev, m_ord_prev, dif_n)
        # if no overlap
        else:
            m_ord = no_overlap_match_calc(params, ord_num, fp_ll_ord,
                                          fp_ll_ord_prev, m_ord_prev, dif_n)
        # insert absolute order numbers at the start of m
        m_vec = np.concatenate((m_ord, m_vec))
        # redefine order number vector for previous order
        m_ord_prev = m_ord

    return m_vec


def get_d_for_each_hcline(params, recipe, llprops, fp_order, fp_xx, m_vec,
                          blaze, n_init, n_fin, wave_blaze_thres, dv_max,
                          ll_fit_degree):
    # set function name
    _ = display_func(params, 'get_d_for_each_hcline', __NAME__)
    # set up storage
    # m(x) fit coefficients
    coeff_xm_all = []
    # m(x) fit dispersion
    xm_disp = []
    # effective cavity width for the HC lines
    d_arr = []
    # 1/line number of the closest FP line to each HC line
    one_m_d = []
    # line number of the closest FP line to each HC line
    m_d = []
    # wavelength of HC lines
    hc_ll_test = []
    # pixel value of kept HC lines
    hc_xx_test = []
    # order of kept hc lines
    hc_ord_test = []
    # save mask for m(x) fits
    xm_mask = []
    # loop over orders
    for order_num in range(n_fin - n_init):
        # create order mask
        fp_order_rav = np.concatenate(fp_order).ravel()
        ind_ord = np.where(fp_order_rav == order_num + n_init)
        # get FP line pixel positions for the order
        fp_x_ord = fp_xx[order_num]
        # get FP line numbers for the order
        m_ord = m_vec[ind_ord]
        # HC mask for the order - keep best lines (small dv) only
        cond1 = abs(llprops['DV_T']) < dv_max
        cond2 = llprops['ORD_T'] == order_num + n_init
        hc_mask = np.where(cond1 & cond2)
        # get HC line pixel positions for the order
        hc_x_ord = llprops['XGAU_T'][hc_mask]
        # get 30% blaze mask
        with warnings.catch_warnings(record=True) as _:
            maxblaze = mp.nanmax(blaze[order_num])
            mb = np.where(blaze[order_num] > (wave_blaze_thres * maxblaze))
        # keep only x values at above 30% blaze
        blaze_mask = np.logical_and(mp.nanmax(mb) > hc_x_ord,
                                    mp.nanmin(mb) < hc_x_ord)
        hc_x_ord = hc_x_ord[blaze_mask]
        # get corresponding catalogue lines from loc
        hc_ll_ord_cat = llprops['WAVE_CATALOG'][hc_mask][blaze_mask]

        # fit x vs m for FP lines w/sigma-clipping
        coeff_xm, mask = sigclip_polyfit(params, fp_x_ord, m_ord, ll_fit_degree)
        # save coefficients
        coeff_xm_all.append(coeff_xm)
        # save dispersion
        polyval_xm = np.polyval(coeff_xm, fp_x_ord[mask])
        xm_disp.append(mp.nanstd(m_ord[mask] - polyval_xm))
        # save mask
        xm_mask.append(mask)
        # get fractional m for HC lines from fit
        m_hc = np.polyval(coeff_xm, hc_x_ord)
        # get cavity width for HC lines from FP equation
        d_hc = m_hc * hc_ll_ord_cat / 2.
        # save in arrays:
        # cavity width for hc lines
        d_arr.append(d_hc)
        # 1/m for HC lines
        one_m_d.append(1 / m_hc)
        # m for HC lines
        m_d.append(m_hc)
        # catalogue wavelengths
        hc_ll_test.append(hc_ll_ord_cat)
        # HC line centers (pixel position)
        hc_xx_test.append(hc_x_ord)
        # HC line orders
        hc_ord_test.append((order_num + n_init) * np.ones_like(hc_x_ord))

    # residuals plot
    recipe.plot('WAVE_FP_M_X_RES', fp_order=fp_order, fp_xx=fp_xx, m_vec=m_vec,
                xm_mask=xm_mask, coeff_xm_all=coeff_xm_all, n_init=n_init,
                n_fin=n_fin)

    # flatten arrays
    one_m_d = np.concatenate(one_m_d).ravel()
    d_arr = np.concatenate(d_arr).ravel()
    m_d = np.concatenate(m_d).ravel()
    hc_ll_test = np.concatenate(hc_ll_test).ravel()
    hc_ord_test = np.concatenate(hc_ord_test).ravel()

    # log absolute peak number span
    wargs = [round(m_d[0]), round(m_d[-1])]
    WLOG(params, '', textentry('40-017-00027', args=wargs))

    return one_m_d, d_arr, hc_ll_test, hc_ord_test


def fit_1m_vs_d(params, recipe, one_m_d, d_arr, hc_ll_test, update_cavity,
                m_init, fp_ll, fiber, **kwargs):
    # set function name
    func_name = __NAME__ + '.fit_1m_vs_d()'
    # get params from params
    dopd0 = pcheck(params, 'WAVE_FP_DOPD0', 'dopd0', kwargs, func_name)

    # load current cavity files
    fit_1m_d, fit_ll_d = drs_data.load_cavity_files(params, required=False)
    # check for exists (will be None if either file doesn't exist)
    if fit_1m_d is None:
        # log that we are going to update cavity files as files do not exist
        WLOG(params, 'warning', textentry('10-017-00011'))
        # set update_cavity to True
        update_cavity = True

    # if we need to update_cavity file then work it out
    if update_cavity:
        # define sorted arrays
        one_m_sort = np.argsort(one_m_d)
        one_m_d = np.array(one_m_d)[one_m_sort]
        d_arr = np.array(d_arr)[one_m_sort]
        # polynomial fit for d vs 1/m
        fit_1m_d = mp.nanpolyfit(one_m_d, d_arr, 9)
        fit_1m_d_func = np.poly1d(fit_1m_d)
        res_d_final = d_arr - np.polyval(fit_1m_d, one_m_d)
        # fit d v wavelength w/sigma-clipping
        fit_ll_d, mask = sigclip_polyfit(params, hc_ll_test, d_arr, degree=9)
        # plot d vs 1/m fit and residuals
        recipe.plot('WAVE_FP_IPT_CWID_1MHC', one_m_d=one_m_d, d_arr=d_arr,
                    m_init=m_init, fit_1m_d_func=fit_1m_d_func,
                    res_d_final=res_d_final, dopd0=dopd0)

        # save the parameters
        drs_data.save_cavity_files(params, fit_1m_d, fit_ll_d)
    # else we need to shift values
    else:
        # get achromatic cavity change - ie shift
        residual = d_arr - np.polyval(fit_ll_d, hc_ll_test)
        # achromatic cavity length change.
        achromatic_cc = mp.nanmedian(residual)
        # log achromatic cavity length change
        WLOG(params, '', textentry('40-017-00042', args=[achromatic_cc]))
        # update the coeffs with mean shift
        fit_ll_d[-1] += achromatic_cc

    # calculate the fit value
    fitval = np.polyval(fit_ll_d, hc_ll_test)
    # plot the interp cavity width ll hc and fp plot
    # TODO: original d needs fixing I think
    recipe.plot('WAVE_FP_IPT_CWID_LLHC', hc_ll=hc_ll_test, fp_ll=fp_ll,
                d_arr=d_arr, fitval=fitval, dopd0=dopd0, fiber=fiber)
    # summary plot interp cavity width ll hc and fp plot
    recipe.plot('SUM_WAVE_FP_IPT_CWID_LLHC', hc_ll=hc_ll_test, fp_ll=fp_ll,
                d_arr=d_arr, fitval=fitval, dopd0=dopd0, fiber=fiber)
    # return variables
    return fit_1m_d, fit_ll_d, one_m_d, d_arr


# TODO: remove? not used in master
def update_fp_peak_wavelengths(params, recipe, llprops, fit_ll_d, m_vec,
                               fp_order, fp_xx, fp_amp, fp_cavfit_mode,
                               n_init, n_fin):
    # set function name
    func_name = display_func(params, 'update_fp_peak_wavelengths', __NAME__)
    # define storage
    fp_ll_new = []
    # deal with different ways to calculate cavity fit
    if fp_cavfit_mode == 0:
        # derive using 1/m vs d fit
        # loop over peak numbers
        for i in range(len(m_vec)):
            # calculate wavelength from fit to 1/m vs d
            fp_ll_new.append(2 * np.polyval(fit_ll_d, 1. / m_vec[i]) / m_vec[i])
    elif fp_cavfit_mode == 1:
        # get the midpoint wavelength as a starting point
        midpoint = np.median(llprops['LL_OUT_1'])
        # from the d v wavelength fit - iterative fit
        fp_ll_new = np.ones_like(m_vec) * midpoint
        for ite in range(6):
            recon_d = np.polyval(fit_ll_d, fp_ll_new)
            fp_ll_new = recon_d / m_vec * 2

    # save to loc (flattened)
    llprops['FP_LL_NEW'] = np.array(fp_ll_new)
    llprops['FP_XX_NEW'] = np.array(np.concatenate(fp_xx).ravel())
    llprops['FP_ORD_NEW'] = np.array(np.concatenate(fp_order).ravel())
    llprops['FP_AMP_NEW'] = np.array(np.concatenate(fp_amp).ravel())
    # duplicate for saving
    llprops['FP_XX_INIT'] = np.array(np.concatenate(fp_xx).ravel())
    # set sources
    keys = ['FP_LL_NEW', 'FP_XX_NEW', 'FP_ORD_NEW', 'FP_AMP_NEW',
            'FP_XX_INIT']
    llprops.set_sources(keys, func_name)
    # plot old-new wavelength difference
    recipe.plot('WAVE_FP_LL_DIFF', llprops=llprops, n_init=n_init, n_fin=n_fin)
    # return ll props
    return llprops


# TODO: remove? not used in master
def fit_wavesol_from_fppeaks(params, llprops, fp_ll, fiber, n_init, n_fin,
                             fp_llfit_mode, ll_fit_degree, errx_min,
                             max_ll_fit_rms, t_order_start, weight_thres):
    func_name = __NAME__ + '.fit_wavesol_from_fppeaks()'

    fp_ll_new = llprops['FP_LL_NEW']
    # deal with ll fit mode 0
    if fp_llfit_mode == 0:
        # call fit_1d_solution
        # set up ALL_LINES_2 with FP lines
        fp_ll_ini = np.concatenate(fp_ll).ravel()

        iargs = [llprops['FP_LL_NEW'], fp_ll_ini, llprops['ALL_LINES_2'],
                 llprops['FP_ORD_NEW'], llprops['FP_XX_NEW'],
                 llprops['FP_AMP_NEW']]

        llprops['ALL_LINES_2'] = insert_fp_lines(params, *iargs)
        # select the orders to fit
        wavells = llprops['LITTROW_EXTRAP_SOL_1'][n_init:n_fin]
        # fit the solution
        llprops = fit_1d_solution(params, llprops, wavells, n_init, n_fin,
                                  fiber, errx_min, ll_fit_degree,
                                  max_ll_fit_rms, t_order_start, weight_thres,
                                  iteration=2)

    # else deal with ll fit mode 1
    elif fp_llfit_mode == 1:
        # call fit_1d_solution_sigclip
        # weights - dummy array
        llprops['FP_WEI'] = np.ones_like(fp_ll_new)
        # fit the solution
        llprops = fit_1d_solution_sigclip(params, llprops, fiber, n_init, n_fin,
                                          ll_fit_degree)
    # else break
    else:
        eargs = [fp_llfit_mode, func_name]
        WLOG(params, 'error', textentry('09-017-00004', args=eargs))

    return llprops


# TODO: remove? not used in master
def join_orders(llprops, start, end):
    """
    Merge the littrow extrapolated solutions with the fitted line solutions

    :param llprops: parameter dictionary, ParamDict containing data
        Must contain at least:
            LL_OUT_2: numpy array (2D), the output wavelengths for each
                      pixel and each order (in the shape of original image)
            DLL_OUT_2: numpy array (2D), the output delta wavelengths for
                       each pixel and each order (in the shape of original
                       image)
            LITTROW_EXTRAP_SOL_2: numpy array (2D),
                              size=([no. orders] by [no. cut points])
                              the wavelength solution at each cut point for
                              each order
            LITTROW_EXTRAP_PARAM_2: numy array (2D),
                              size=([no. orders] by [the fit degree +1])
                              the coefficients of the fits for each cut
                              point for each order

    :param start:
    :param end:

    :return loc: parameter dictionary, the updated parameter dictionary
        Adds/updates the following:
            LL_FINAL: numpy array, the joined littrow extrapolated and fitted
                      solution wavelengths
            LL_PARAM_FINAL: numpy array, the joined littrow extrapolated and
                            fitted fit coefficients

    """

    func_name = __NAME__ + '.join_orders()'
    # get data from loc
    # the second iteration outputs
    ll_out_2 = llprops['LL_OUT_2']
    param_out_2 = llprops['LL_PARAM_2']

    # the littrow extrapolation (for orders < n_ord_start_2)
    litt_extrap_sol_blue = llprops['LITTROW_EXTRAP_SOL_2'][:start]
    litt_extrap_sol_param_blue = llprops['LITTROW_EXTRAP_PARAM_2'][:start]

    # the littrow extrapolation (for orders > n_ord_final_2)
    litt_extrap_sol_red = llprops['LITTROW_EXTRAP_SOL_2'][end:]
    litt_extrap_sol_param_red = llprops['LITTROW_EXTRAP_PARAM_2'][end:]

    # create stack
    ll_stack, param_stack = [], []
    # add extrapolation from littrow to orders < n_ord_start_2
    if len(litt_extrap_sol_blue) > 0:
        ll_stack.append(litt_extrap_sol_blue)
        param_stack.append(litt_extrap_sol_param_blue)
    # add second iteration outputs
    if len(ll_out_2) > 0:
        ll_stack.append(ll_out_2)
        param_stack.append(param_out_2)
    # add extrapolation from littrow to orders > n_ord_final_2
    if len(litt_extrap_sol_red) > 0:
        ll_stack.append(litt_extrap_sol_red)
        param_stack.append(litt_extrap_sol_param_red)

    # convert stacks to arrays and add to storage
    llprops['LL_FINAL'] = np.vstack(ll_stack)
    llprops['LL_PARAM_FINAL'] = np.vstack(param_stack)
    llprops.set_sources(['LL_FINAL', 'LL_PARAM_FINAL'], func_name)

    # return loc
    return llprops


# =============================================================================
# Define fp aux functions
# =============================================================================
def fp_quality_control(params, fpprops, qc_params, rvprops, **kwargs):
    func_name = __NAME__ + '.fp_quality_control()'
    # get parameters from params/kwargs
    rms_littrow_max = pcheck(params, 'WAVE_LITTROW_QC_RMS_MAX',
                             'rms_littrow_max', kwargs, func_name)
    dev_littrow_max = pcheck(params, 'WAVE_LITTROW_QC_DEV_MAX',
                             'dev_littrow_max', kwargs, func_name)
    master_fiber = pcheck(params, 'WAVE_MASTER_FIBER', 'master_fiber', kwargs,
                          func_name)
    rv_thres = pcheck(params, 'WAVE_CCF_RV_THRES_QC', 'rv_thres', kwargs,
                      func_name)
    # --------------------------------------------------------------
    # set passed variable and fail message list
    fail_msg = []
    qc_names, qc_values, qc_logic, qc_pass = qc_params
    # --------------------------------------------------------------
    # check the difference between consecutive orders is always positive
    # get the differences
    wave_diff = fpprops['LL_FINAL'][1:] - fpprops['LL_FINAL'][:-1]
    if mp.nanmin(wave_diff) < 0:
        fail_msg.append(textentry('40-017-00030'))
        qc_pass.append(0)
    else:
        qc_pass.append(1)
    # add to qc header lists
    qc_values.append(mp.nanmin(wave_diff))
    qc_names.append('MIN WAVE DIFF FP-HC')
    qc_logic.append('MIN WAVE DIFF < 0')
    # ----------------------------------------------------------------------
    # check for infinites and NaNs in mean residuals from fit
    if ~np.isfinite(fpprops['X_MEAN_2']):
        # add failed message to the fail message list
        fail_msg.append(textentry('40-017-00031'))
        qc_pass.append(0)
    else:
        qc_pass.append(1)
    # add to qc header lists
    qc_values.append(fpprops['X_MEAN_2'])
    qc_names.append('X_MEAN_2')
    qc_logic.append('X_MEAN_2 not finite')

    # ----------------------------------------------------------------------
    # # iterate through Littrow test cut values
    # TODO: Figure out how to get littrow working
    lit_it = 2
    # checks every other value
    for x_it in range(1, len(fpprops['X_CUT_POINTS_' + str(lit_it)]), 2):
        # get x cut point
        x_cut_point = fpprops['X_CUT_POINTS_' + str(lit_it)][x_it]
        # get the sigma for this cut point
        sig_littrow = fpprops['LITTROW_SIG_' + str(lit_it)][x_it]
        # get the abs min and max dev littrow values
        min_littrow = abs(fpprops['LITTROW_MINDEV_' + str(lit_it)][x_it])
        max_littrow = abs(fpprops['LITTROW_MAXDEV_' + str(lit_it)][x_it])
        # get the corresponding order
        min_littrow_ord = fpprops['LITTROW_MINDEVORD_' + str(lit_it)][x_it]
        max_littrow_ord = fpprops['LITTROW_MAXDEVORD_' + str(lit_it)][x_it]
        # check if sig littrow is above maximum
        if sig_littrow > rms_littrow_max:
            fargs = [x_cut_point, sig_littrow, rms_littrow_max]
            fail_msg.append(textentry('40-017-00032', args=fargs))
            qc_pass.append(0)
        else:
            qc_pass.append(1)
        # add to qc header lists
        qc_values.append(sig_littrow)
        qc_names.append('sig_littrow')
        qc_logic.append('sig_littrow > {0:.2f}'.format(rms_littrow_max))
        # ----------------------------------------------------------------------
        # check if min/max littrow is out of bounds
        bounds_littrow = np.array([max_littrow, min_littrow])
        max_bounds = mp.nanmax(bounds_littrow)
        if max_bounds > dev_littrow_max:
            fargs = [x_cut_point, min_littrow, max_littrow, dev_littrow_max,
                     min_littrow_ord, max_littrow_ord]
            fail_msg.append(textentry('40-017-00033', args=fargs))
            qc_pass.append(0)
        else:
            qc_pass.append(1)
        # add to qc header lists
        qc_values.append(max_bounds)
        qc_names.append('max or min littrow')
        qc_logic.append('max or min littrow > {0:.2f}'
                        ''.format(dev_littrow_max))
    # --------------------------------------------------------------
    # rv quality controls between fibers
    # --------------------------------------------------------------
    # get master RV [km/s] --> [m/s]
    master_rv = rvprops[master_fiber]['MEAN_RV'] * 1000
    # get the fiber types from a list parameter (or from inputs)
    fiber_types = drs_image.get_fiber_types(params)
    # loop around fibers
    for fiber in fiber_types:
        # do not compare master to master
        if fiber == master_fiber:
            continue
        # get rv for this fiber [km/s] --> [m/s]
        rvfiber = rvprops[fiber]['MEAN_RV'] * 1000
        # deal with rv threshold
        if np.abs(master_rv - rvfiber) > rv_thres:
            qc_pass.append(0)
        else:
            qc_pass.append(1)
        # add to qc header lists
        qc_values.append(master_rv - rvfiber)
        qc_names.append('RV[{0} - {1}]'.format(master_fiber, fiber))
        qargs = [master_fiber, fiber, rv_thres]
        qc_logic.append('abs(RV[{0} - {1}]) > {2} m/s'.format(*qargs))

    # --------------------------------------------------------------
    # finally log the failed messages and set QC = 1 if we pass the
    #     quality control QC = 0 if we fail quality control
    if np.sum(qc_pass) == len(qc_pass):
        WLOG(params, 'info', textentry('40-005-10001'))
    else:
        for farg in fail_msg:
            WLOG(params, 'warning', textentry('40-005-10002') + farg)
    # store in qc_params
    qc_params = [qc_names, qc_values, qc_logic, qc_pass]
    # return qc_params
    return qc_params


# TODO: remove if we are using master/night recipes
def fp_write_wavesolution(params, recipe, llprops, hcfile, fpfile,
                          fiber, combine, rawhcfiles, rawfpfiles, qc_params,
                          wprops, hcwavefile):
    # ------------------------------------------------------------------
    # get copy of instance of wave file (WAVE_HCMAP)
    wavefile = recipe.outputs['WAVE_FPMAP'].newcopy(params=params,
                                                    fiber=fiber)
    # construct the filename from file instance
    wavefile.construct_filename(infile=hcfile)
    # ------------------------------------------------------------------
    # copy keys from hcwavefile
    wavefile.copy_hdict(hcwavefile)
    # set output key
    wavefile.add_hkey('KW_OUTPUT', value=wavefile.name)
    wavefile.add_hkey('KW_FIBER', value=fiber)
    # add input hc files (and deal with combining or not combining)
    if combine:
        hfiles = rawhcfiles
    else:
        hfiles = [hcfile.basename]
    wavefile.add_hkey_1d('KW_INFILE1', values=hfiles, dim1name='file')

    # add input fp files (and deal with combining or not combining)
    if combine:
        hfiles = rawfpfiles
    else:
        hfiles = [fpfile.basename]
    wavefile.add_hkey_1d('KW_INFILE2', values=hfiles, dim1name='file')

    # ------------------------------------------------------------------
    # add the order num, fit degree and fit coefficients
    wavefile = add_wave_keys(params, wavefile, wprops)
    # ------------------------------------------------------------------
    # add constants used (for reproduction)
    wavefile.add_hkey('KW_WAVE_FITDEG', value=llprops['WAVE_FIT_DEGREE'])
    wavefile.add_hkey('KW_WAVE_MODE_HC', value=params['WAVE_MODE_HC'])
    wavefile.add_hkey('KW_WAVE_MODE_FP', value=params['WAVE_MODE_FP'])
    # from fp_wavesol
    wavefile.add_hkey('KW_WFP_ORD_START', value=llprops['USED_N_INIT'])
    wavefile.add_hkey('KW_WFP_ORD_FINAL', value=llprops['USED_N_FIN'])
    wavefile.add_hkey('KW_WFP_BLZ_THRES', value=llprops['USED_BLAZE_THRES'])
    wavefile.add_hkey('KW_WFP_XDIFF_MIN', value=llprops['USED_XDIFF_MIN'])
    wavefile.add_hkey('KW_WFP_XDIFF_MAX', value=llprops['USED_XDIFF_MAX'])
    wavefile.add_hkey('KW_WFP_DOPD0', value=llprops['USED_DOPD0'])
    wavefile.add_hkey('KW_WFP_LL_OFFSET', value=llprops['USED_LL_OFFSET'])
    wavefile.add_hkey('KW_WFP_DVMAX', value=llprops['USED_DV_MAX'])
    wavefile.add_hkey('KW_WFP_LLFITDEG', value=llprops['USED_LL_FIT_DEG'])
    wavefile.add_hkey('KW_WFP_UPDATECAV', value=llprops['USED_UPDATE_CAV'])
    wavefile.add_hkey('KW_WFP_FPCAV_MODE', value=llprops['USED_FP_CAV_MODE'])
    wavefile.add_hkey('KW_WFP_LLFIT_MODE', value=llprops['USED_LL_FIT_MODE'])
    wavefile.add_hkey('KW_WFP_ERRX_MIN', value=llprops['USED_ERRX_MIN'])
    wavefile.add_hkey('KW_WFP_MAXLL_FIT_RMS',
                      value=llprops['USED_MAX_LL_FIT_RMS'])
    wavefile.add_hkey('KW_WFP_T_ORD_START', value=llprops['USED_T_ORD_START'])
    wavefile.add_hkey('KW_WFP_WEI_THRES', value=llprops['USED_WEIGHT_THRES'])
    wavefile.add_hkey('KW_WFP_CAVFIT_DEG', value=llprops['USED_CAVFIT_DEG'])
    wavefile.add_hkey('KW_WFP_LARGE_JUMP', value=llprops['USED_LARGE_JUMP'])
    wavefile.add_hkey('KW_WFP_CM_INDX', value=llprops['USED_CM_INDEX'])
    # from find_fp_lines_new
    wavefile.add_hkey_1d('KW_WFP_WIDUSED', values=llprops['PEAKSIZE'],
                         dim1name='order')
    wavefile.add_hkey('KW_WFP_NPERCENT', value=llprops['USED_NORMPERCENT'])
    wavefile.add_hkey('KW_WFP_LIMIT', value=llprops['USED_LIMIT'])
    wavefile.add_hkey('KW_WFP_CUTWIDTH', value=llprops['USED_CUTWIDTH'])
    # from fp ccf calculation (compute_fp_ccf)
    wavefile.add_hkey('KW_WFP_SIGDET', value=llprops['CCF_SIGDET'])
    wavefile.add_hkey('KW_WFP_BOXSIZE', value=llprops['CCF_BOXSIZE'])
    wavefile.add_hkey('KW_WFP_MAXFLUX', value=llprops['CCF_MAXFLUX'])
    wavefile.add_hkey('KW_WFP_NMAX', value=llprops['CCF_NMAX'])
    wavefile.add_hkey('KW_WFP_MASKMIN', value=llprops['MASK_MIN'])
    wavefile.add_hkey('KW_WFP_MASKWID', value=llprops['MASK_WIDTH'])
    wavefile.add_hkey('KW_WFP_MASKUNITS', value=llprops['MASK_UNITS'])
    # ------------------------------------------------------------------
    # add qc parameters
    wavefile.add_qckeys(qc_params)
    # copy data
    wavefile.data = llprops['LL_FINAL']
    # ------------------------------------------------------------------
    # log that we are saving rotated image
    wargs = [fiber, wavefile.filename]
    WLOG(params, '', textentry('40-017-00037', args=wargs))
    # write image to file
    wavefile.write_file(kind=recipe.outputtype, runstring=recipe.runstring)
    # add to output files (for indexing)
    recipe.add_output_file(wavefile)
    # ------------------------------------------------------------------
    # return hc wavefile
    return wavefile


# TODO: remove if we are using master/night recipes
def fp_write_results_table(params, recipe, llprops, hcfile, fiber):
    # iterate through Littrow test cut values
    lit_it = 2
    # get from params
    nightname = params['NIGHTNAME']
    # calculate stats for table
    final_mean = 1000 * llprops['X_MEAN_2']
    final_var = 1000 * llprops['X_VAR_2']
    num_lines = llprops['TOTAL_LINES_2']
    err = 1000 * np.sqrt(llprops['X_VAR_2'] / num_lines)
    sig_littrow = 1000 * np.array(llprops['LITTROW_SIG_' + str(lit_it)])
    # ------------------------------------------------------------------
    # get copy of instance of wave file (WAVE_HCMAP)
    wavefile = recipe.outputs['WAVE_FPRESTAB'].newcopy(params=params,
                                                       fiber=fiber)
    # construct the filename from file instance
    wavefile.construct_filename(infile=hcfile)
    # ------------------------------------------------------------------
    # construct and write table
    columnnames = ['night_name', 'file_name', 'fiber', 'mean', 'rms',
                   'N_lines', 'err', 'rms_L500', 'rms_L1000', 'rms_L1500',
                   'rms_L2000', 'rms_L2500', 'rms_L3000', 'rms_L3500']
    columnformats = ['{:20s}', '{:30s}', '{:3s}', '{:7.4f}', '{:6.2f}',
                     '{:3d}', '{:6.3f}', '{:6.2f}', '{:6.2f}', '{:6.2f}',
                     '{:6.2f}', '{:6.2f}', '{:6.2f}', '{:6.2f}']
    columnvalues = [[nightname], [hcfile.basename],
                    [fiber], [final_mean], [final_var],
                    [num_lines], [err], [sig_littrow[0]],
                    [sig_littrow[1]], [sig_littrow[2]], [sig_littrow[3]],
                    [sig_littrow[4]], [sig_littrow[5]], [sig_littrow[6]]]
    # ------------------------------------------------------------------
    # make the table
    table = drs_table.make_table(params, columnnames, columnvalues,
                                 columnformats)
    # ------------------------------------------------------------------
    # log saving of file
    WLOG(params, '', textentry('40-017-00034', args=[wavefile.filename]))
    # merge table
    drs_table.merge_table(params, table, wavefile.filename, fmt='ascii.rst')


# TODO: remove if we are using master/night recipes
def fp_write_linelist_table(params, recipe, llprops, hcfile, fiber):
    # ------------------------------------------------------------------
    # get copy of instance of wave file (WAVE_HCMAP)
    wavefile = recipe.outputs['WAVE_FPLLTAB'].newcopy(params=params,
                                                      fiber=fiber)
    # construct the filename from file instance
    wavefile.construct_filename(infile=hcfile)
    # ------------------------------------------------------------------
    # construct and write table
    columnnames = ['order', 'll', 'dv', 'w', 'xi', 'xo', 'dvdx']
    columnformats = ['{:.0f}', '{:12.4f}', '{:13.5f}', '{:12.4f}',
                     '{:12.4f}', '{:12.4f}', '{:8.4f}']
    columnvalues = []
    # construct column values (flatten over orders)
    for it in range(len(llprops['X_DETAILS_2'])):
        for jt in range(len(llprops['X_DETAILS_2'][it][0])):
            row = [float(it), llprops['X_DETAILS_2'][it][0][jt],
                   llprops['LL_DETAILS_2'][it][0][jt],
                   llprops['X_DETAILS_2'][it][3][jt],
                   llprops['X_DETAILS_2'][it][1][jt],
                   llprops['X_DETAILS_2'][it][2][jt],
                   llprops['SCALE_2'][it][jt]]
            columnvalues.append(row)
    # need to flip values
    columnvalues = np.array(columnvalues).T
    # ------------------------------------------------------------------
    # make the table
    table = drs_table.make_table(params, columnnames, columnvalues,
                                 columnformats)
    # ------------------------------------------------------------------
    # log saving of file
    WLOG(params, '', textentry('40-017-00035', args=[wavefile.filename]))
    # merge table
    drs_table.write_table(params, table, wavefile.filename, fmt='ascii.rst')


def wave_summary(recipe, params, llprops, fiber, qc_params):
    # add qc params (fiber specific)
    recipe.plot.add_qc_params(qc_params, fiber=fiber)
    # add stats
    recipe.plot.add_stat('KW_VERSION', value=params['DRS_VERSION'],
                         fiber=fiber)
    recipe.plot.add_stat('KW_DRS_DATE', value=params['DRS_DATE'],
                         fiber=fiber)
    # add constants used (for reproduction)
    recipe.plot.add_stat('KW_WAVE_FITDEG', value=llprops['WAVE_FIT_DEGREE'],
                         fiber=fiber)
    recipe.plot.add_stat('KW_WAVE_MODE_HC', value=params['WAVE_MODE_HC'],
                         fiber=fiber)
    recipe.plot.add_stat('KW_WAVE_MODE_FP', value=params['WAVE_MODE_FP'],
                         fiber=fiber)
    # from fp_wavesol
    recipe.plot.add_stat('KW_WFP_ORD_START', value=llprops['USED_N_INIT'],
                         fiber=fiber)
    recipe.plot.add_stat('KW_WFP_ORD_FINAL', value=llprops['USED_N_FIN'],
                         fiber=fiber)
    recipe.plot.add_stat('KW_WFP_BLZ_THRES', value=llprops['USED_BLAZE_THRES'],
                         fiber=fiber)
    recipe.plot.add_stat('KW_WFP_XDIFF_MIN', value=llprops['USED_XDIFF_MIN'],
                         fiber=fiber)
    recipe.plot.add_stat('KW_WFP_XDIFF_MAX', value=llprops['USED_XDIFF_MAX'],
                         fiber=fiber)
    recipe.plot.add_stat('KW_WFP_DOPD0', value=llprops['USED_DOPD0'],
                         fiber=fiber)
    recipe.plot.add_stat('KW_WFP_LL_OFFSET', value=llprops['USED_LL_OFFSET'],
                         fiber=fiber)
    recipe.plot.add_stat('KW_WFP_DVMAX', value=llprops['USED_DV_MAX'],
                         fiber=fiber)
    recipe.plot.add_stat('KW_WFP_LLFITDEG', value=llprops['USED_LL_FIT_DEG'],
                         fiber=fiber)
    recipe.plot.add_stat('KW_WFP_UPDATECAV', value=llprops['USED_UPDATE_CAV'],
                         fiber=fiber)
    recipe.plot.add_stat('KW_WFP_FPCAV_MODE', value=llprops['USED_FP_CAV_MODE'],
                         fiber=fiber)
    recipe.plot.add_stat('KW_WFP_LLFIT_MODE', value=llprops['USED_LL_FIT_MODE'],
                         fiber=fiber)
    recipe.plot.add_stat('KW_WFP_ERRX_MIN', value=llprops['USED_ERRX_MIN'],
                         fiber=fiber)
    recipe.plot.add_stat('KW_WFP_MAXLL_FIT_RMS', fiber=fiber,
                         value=llprops['USED_MAX_LL_FIT_RMS'])
    recipe.plot.add_stat('KW_WFP_T_ORD_START', fiber=fiber,
                         value=llprops['USED_T_ORD_START'])
    recipe.plot.add_stat('KW_WFP_WEI_THRES', value=llprops['USED_WEIGHT_THRES'],
                         fiber=fiber)
    recipe.plot.add_stat('KW_WFP_CAVFIT_DEG', value=llprops['USED_CAVFIT_DEG'],
                         fiber=fiber)
    recipe.plot.add_stat('KW_WFP_LARGE_JUMP', value=llprops['USED_LARGE_JUMP'],
                         fiber=fiber)
    recipe.plot.add_stat('KW_WFP_CM_INDX', value=llprops['USED_CM_INDEX'],
                         fiber=fiber)
    # from find_fp_lines_new
    recipe.plot.add_stat('KW_WFP_NPERCENT', value=llprops['USED_NORMPERCENT'],
                         fiber=fiber)
    recipe.plot.add_stat('KW_WFP_LIMIT', value=llprops['USED_LIMIT'],
                         fiber=fiber)
    recipe.plot.add_stat('KW_WFP_CUTWIDTH', value=llprops['USED_CUTWIDTH'],
                         fiber=fiber)
    # from fp ccf calculation (compute_fp_ccf)
    recipe.plot.add_stat('KW_WFP_SIGDET', value=llprops['CCF_SIGDET'],
                         fiber=fiber)
    recipe.plot.add_stat('KW_WFP_BOXSIZE', value=llprops['CCF_BOXSIZE'],
                         fiber=fiber)
    recipe.plot.add_stat('KW_WFP_MAXFLUX', value=llprops['CCF_MAXFLUX'],
                         fiber=fiber)
    recipe.plot.add_stat('KW_WFP_NMAX', value=llprops['CCF_NMAX'], fiber=fiber)
    recipe.plot.add_stat('KW_WFP_MASKMIN', value=llprops['MASK_MIN'],
                         fiber=fiber)
    recipe.plot.add_stat('KW_WFP_MASKWID', value=llprops['MASK_WIDTH'],
                         fiber=fiber)
    recipe.plot.add_stat('KW_WFP_MASKUNITS', value=llprops['MASK_UNITS'],
                         fiber=fiber)


def fp_write_wavesol_master(params, recipe, llprops, hcfile, fpfile, fiber,
                            combine, rawhcfiles, rawfpfiles, qc_params,
                            wprops, hcwavefile):
    # ------------------------------------------------------------------
    # get copy of instance of wave file (WAVE_HCMAP)
    wavefile = recipe.outputs['WAVEM_FPMAP'].newcopy(params=params,
                                                     fiber=fiber)
    # construct the filename from file instance
    wavefile.construct_filename(infile=hcfile)
    # set some wave keys as "SELF" (i.e. from this wave solution)
    wprops['WAVEFILE'] = wavefile.basename
    wprops['WAVETIME'] = hcfile.get_hkey('KW_MID_OBS_TIME', dtype=float)
    sargs = [recipe.name, params['DRS_VERSION']]
    wprops['WAVESOURCE'] = '{0} [{1}]'.format(*sargs)
    wprops['WFP_FILE'] = wavefile.basename
    # ------------------------------------------------------------------
    # Make wave coefficient table
    # ------------------------------------------------------------------
    # get number of orders
    nbo = wprops['COEFFS'].shape[0]
    # add order column
    wave_cols = ['ORDER']
    wave_vals = [np.arange(nbo)]
    # add coefficients columns
    for w_it in range(wprops['COEFFS'].shape[1]):
        wave_cols.append('COEFFS_{0}'.format(w_it))
        wave_vals.append(wprops['COEFFS'][:, w_it])
    wave_table = drs_table.make_table(params, columns=wave_cols,
                                      values=wave_vals)
    # ------------------------------------------------------------------
    # copy keys from hcwavefile
    wavefile.copy_hdict(hcwavefile)
    # set output key
    wavefile.add_hkey('KW_OUTPUT', value=wavefile.name)
    wavefile.add_hkey('KW_FIBER', value=fiber)
    # add input hc files (and deal with combining or not combining)
    if combine:
        hfiles = rawhcfiles
    else:
        hfiles = [hcfile.basename]
    wavefile.add_hkey_1d('KW_INFILE1', values=hfiles, dim1name='file')

    # add input fp files (and deal with combining or not combining)
    if combine:
        hfiles = rawfpfiles
    else:
        hfiles = [fpfile.basename]
    wavefile.add_hkey_1d('KW_INFILE2', values=hfiles, dim1name='file')

    # ------------------------------------------------------------------
    # add the order num, fit degree and fit coefficients
    wavefile = add_wave_keys(params, wavefile, wprops)
    # ------------------------------------------------------------------
    # add constants used (for reproduction)
    wavefile.add_hkey('KW_WAVE_FITDEG', value=llprops['WAVE_FIT_DEGREE'])
    wavefile.add_hkey('KW_WAVE_MODE_HC', value=params['WAVE_MODE_HC'])
    wavefile.add_hkey('KW_WAVE_MODE_FP', value=params['WAVE_MODE_FP'])
    # from fp_wavesol
    wavefile.add_hkey('KW_WFP_ORD_START', value=llprops['USED_N_INIT'])
    wavefile.add_hkey('KW_WFP_ORD_FINAL', value=llprops['USED_N_FIN'])
    wavefile.add_hkey('KW_WFP_BLZ_THRES', value=llprops['USED_BLAZE_THRES'])
    wavefile.add_hkey('KW_WFP_XDIFF_MIN', value=llprops['USED_XDIFF_MIN'])
    wavefile.add_hkey('KW_WFP_XDIFF_MAX', value=llprops['USED_XDIFF_MAX'])
    wavefile.add_hkey('KW_WFP_DOPD0', value=llprops['USED_DOPD0'])
    wavefile.add_hkey('KW_WFP_LL_OFFSET', value=llprops['USED_LL_OFFSET'])
    wavefile.add_hkey('KW_WFP_DVMAX', value=llprops['USED_DV_MAX'])
    wavefile.add_hkey('KW_WFP_LLFITDEG', value=llprops['USED_LL_FIT_DEG'])
    wavefile.add_hkey('KW_WFP_UPDATECAV', value=llprops['USED_UPDATE_CAV'])
    wavefile.add_hkey('KW_WFP_FPCAV_MODE', value=llprops['USED_FP_CAV_MODE'])
    wavefile.add_hkey('KW_WFP_LLFIT_MODE', value=llprops['USED_LL_FIT_MODE'])
    wavefile.add_hkey('KW_WFP_ERRX_MIN', value=llprops['USED_ERRX_MIN'])
    wavefile.add_hkey('KW_WFP_MAXLL_FIT_RMS',
                      value=llprops['USED_MAX_LL_FIT_RMS'])
    wavefile.add_hkey('KW_WFP_T_ORD_START', value=llprops['USED_T_ORD_START'])
    wavefile.add_hkey('KW_WFP_WEI_THRES', value=llprops['USED_WEIGHT_THRES'])
    wavefile.add_hkey('KW_WFP_CAVFIT_DEG', value=llprops['USED_CAVFIT_DEG'])
    wavefile.add_hkey('KW_WFP_LARGE_JUMP', value=llprops['USED_LARGE_JUMP'])
    wavefile.add_hkey('KW_WFP_CM_INDX', value=llprops['USED_CM_INDEX'])
    # from find_fp_lines_new
    wavefile.add_hkey_1d('KW_WFP_WIDUSED', values=llprops['PEAKSIZE'],
                         dim1name='order')
    wavefile.add_hkey('KW_WFP_NPERCENT', value=llprops['USED_NORMPERCENT'])
    wavefile.add_hkey('KW_WFP_LIMIT', value=llprops['USED_LIMIT'])
    wavefile.add_hkey('KW_WFP_CUTWIDTH', value=llprops['USED_CUTWIDTH'])
    # from fp ccf calculation (compute_fp_ccf)
    wavefile.add_hkey('KW_WFP_SIGDET', value=llprops['CCF_SIGDET'])
    wavefile.add_hkey('KW_WFP_BOXSIZE', value=llprops['CCF_BOXSIZE'])
    wavefile.add_hkey('KW_WFP_MAXFLUX', value=llprops['CCF_MAXFLUX'])
    wavefile.add_hkey('KW_WFP_NMAX', value=llprops['CCF_NMAX'])
    wavefile.add_hkey('KW_WFP_MASKMIN', value=llprops['MASK_MIN'])
    wavefile.add_hkey('KW_WFP_MASKWID', value=llprops['MASK_WIDTH'])
    wavefile.add_hkey('KW_WFP_MASKUNITS', value=llprops['MASK_UNITS'])
    # ------------------------------------------------------------------
    # add qc parameters
    wavefile.add_qckeys(qc_params)
    # copy data
    wavefile.data = wprops['WAVEMAP']
    # ------------------------------------------------------------------
    # log that we are saving rotated image
    wargs = [fiber, wavefile.filename]
    WLOG(params, '', textentry('40-017-00037', args=wargs))
    # write image to file
    wavefile.write_multi(data_list=[wave_table], datatype_list=['table'],
                         kind=recipe.outputtype, runstring=recipe.runstring)
    # add to output files (for indexing)
    recipe.add_output_file(wavefile)
    # ------------------------------------------------------------------
    # return hc wavefile
    return wavefile


def fpm_write_results_table(params, recipe, llprops, hcfile, fiber):
    # iterate through Littrow test cut values
    lit_it = 2
    # get from params
    nightname = params['NIGHTNAME']
    # calculate stats for table
    final_mean = 1000 * llprops['X_MEAN_2']
    final_var = 1000 * llprops['X_VAR_2']
    num_lines = llprops['TOTAL_LINES_2']
    err = 1000 * np.sqrt(llprops['X_VAR_2'] / num_lines)
    sig_littrow = 1000 * np.array(llprops['LITTROW_SIG_' + str(lit_it)])
    # ------------------------------------------------------------------
    # get copy of instance of wave file (WAVE_HCMAP)
    wavefile = recipe.outputs['WAVEM_FPRESTAB'].newcopy(params=params,
                                                        fiber=fiber)
    # construct the filename from file instance
    wavefile.construct_filename(infile=hcfile)
    # ------------------------------------------------------------------
    # construct and write table
    columnnames = ['night_name', 'file_name', 'fiber', 'mean', 'rms',
                   'N_lines', 'err', 'rms_L500', 'rms_L1000', 'rms_L1500',
                   'rms_L2000', 'rms_L2500', 'rms_L3000', 'rms_L3500']
    columnformats = ['{:20s}', '{:30s}', '{:3s}', '{:7.4f}', '{:6.2f}',
                     '{:3d}', '{:6.3f}', '{:6.2f}', '{:6.2f}', '{:6.2f}',
                     '{:6.2f}', '{:6.2f}', '{:6.2f}', '{:6.2f}']
    columnvalues = [[nightname], [hcfile.basename],
                    [fiber], [final_mean], [final_var],
                    [num_lines], [err], [sig_littrow[0]],
                    [sig_littrow[1]], [sig_littrow[2]], [sig_littrow[3]],
                    [sig_littrow[4]], [sig_littrow[5]], [sig_littrow[6]]]
    # ------------------------------------------------------------------
    # make the table
    table = drs_table.make_table(params, columnnames, columnvalues,
                                 columnformats)
    # ------------------------------------------------------------------
    # log saving of file
    WLOG(params, '', textentry('40-017-00034', args=[wavefile.filename]))
    # merge table
    drs_table.merge_table(params, table, wavefile.filename, fmt='ascii.rst')


def fpm_write_linelist_table(params, recipe, llprops, hcfile, fiber):
    # ------------------------------------------------------------------
    # get copy of instance of wave file (WAVE_HCMAP)
    wavefile = recipe.outputs['WAVEM_FPLLTAB'].newcopy(params=params,
                                                       fiber=fiber)
    # construct the filename from file instance
    wavefile.construct_filename(infile=hcfile)
    # ------------------------------------------------------------------
    # construct and write table
    columnnames = ['order', 'll', 'dv', 'w', 'xi', 'xo', 'dvdx']
    columnformats = ['{:.0f}', '{:12.4f}', '{:13.5f}', '{:12.4f}',
                     '{:12.4f}', '{:12.4f}', '{:8.4f}']
    columnvalues = []
    # construct column values (flatten over orders)
    for it in range(len(llprops['X_DETAILS_2'])):
        for jt in range(len(llprops['X_DETAILS_2'][it][0])):
            row = [float(it), llprops['X_DETAILS_2'][it][0][jt],
                   llprops['LL_DETAILS_2'][it][0][jt],
                   llprops['X_DETAILS_2'][it][3][jt],
                   llprops['X_DETAILS_2'][it][1][jt],
                   llprops['X_DETAILS_2'][it][2][jt],
                   llprops['SCALE_2'][it][jt]]
            columnvalues.append(row)
    # need to flip values
    columnvalues = np.array(columnvalues).T
    # ------------------------------------------------------------------
    # make the table
    table = drs_table.make_table(params, columnnames, columnvalues,
                                 columnformats)
    # ------------------------------------------------------------------
    # log saving of file
    WLOG(params, '', textentry('40-017-00035', args=[wavefile.filename]))
    # merge table
    drs_table.write_table(params, table, wavefile.filename, fmt='ascii.rst')


# =============================================================================
# Define non-master fiber functions
# =============================================================================
def process_fibers(params, recipe, mprops, mfpl, mhcl, fp_outputs, hc_outputs):
    # set function name
    _ = display_func(params, 'process_fibers', __NAME__)
    # get wave master file (controller fiber)
    master_fiber = params['WAVE_MASTER_FIBER']
    plot_order = params['WAVE_FIBER_COMP_PLOT_ORD']
    # get the fiber types from a list parameter (or from inputs)
    fiber_types = drs_image.get_fiber_types(params)
    # set dcavity to None initially
    dcavity = None
    # storage for coeffients
    solutions = dict()
    # loop around fibers
    for fiber in fiber_types:
        wavemap = mprops['WAVEMAP']
        wavefile = mprops['WAVEFILE']
        # get the e2ds_files for this fiber
        hc_e2ds_file = hc_outputs[fiber]
        fp_e2ds_file = fp_outputs[fiber]
        # ==================================================================
        # RUN THE NIGHTLY WAVE SOLUTION ON FIBER
        # ==================================================================
        # Note we do this to force consistency between night wave solutions
        #   the wave solution is basically regenerated based on the hc
        #   and fp lines (and dcavity is recomputed using both HC and FP)
        wargs = [hc_e2ds_file, fp_e2ds_file, mhcl, mfpl, wavemap, wavefile,
                 master_fiber, dcavity]

        nprops = night_wavesolution(params, recipe, *wargs)

        # if this is the master fiber - update hclines, fplines and dcavity
        if fiber == master_fiber:
            # get the hc and fp lines
            mhcl, mfpl = nprops['HCLINES'], nprops['FPLINES']
            # update dcavity
            dcavity = nprops['DCAVITY']
            # update mprops
            mprops = nprops
        # storage
        solutions[fiber] = nprops
    # ----------------------------------------------------------------------
    # plot comparison between master fiber and fibers
    # ----------------------------------------------------------------------
    recipe.plot('WAVE_FIBER_COMPARISON', solutions=solutions, master=mprops,
                order=None, masterfiber=master_fiber)
    recipe.plot('WAVE_FIBER_COMP', solutions=solutions, master=mprops,
                order=plot_order, masterfiber=master_fiber)
    recipe.plot('SUM_WAVE_FIBER_COMP', solutions=solutions, master=mprops,
                order=plot_order, masterfiber=master_fiber)
    # ----------------------------------------------------------------------
    # return all the solutions for all fibers
    return solutions


def process_other_fibers(params, recipe, mprops, mfpl, fp_outputs):
    # set function name
    func_name = display_func(params, 'process_other_fibers', __NAME__)
    # get the fiber types from a list parameter (or from inputs)
    fiber_types = drs_image.get_fiber_types(params)
    # get psuedo constants
    pconst = constants.pload(params['INSTRUMENT'])
    # get wave master file (controller fiber)
    master_fiber = params['WAVE_MASTER_FIBER']
    plot_order = params['WAVE_FIBER_COMP_PLOT_ORD']
    # get the master wavemap
    mwavemap = mprops['WAVEMAP']
    nbpix = mwavemap.shape[1]
    nbo = mprops['NBO']
    mdeg = mprops['DEG']
    # storage for coeffients
    solutions = dict()
    # loop around fibers
    for fiber in fiber_types:
        # log that we are processing fiber
        wargs = [fiber, master_fiber]
        WLOG(params, 'info', textentry('40-017-00043', args=wargs))
        # skip the master file
        if fiber == master_fiber:
            continue
        # get the fp_e2ds_file for this fiber
        fpe2dsfile = fp_outputs[fiber]
        # get the master lines for this fiber
        fpargs = dict(e2dsfile=fpe2dsfile, wavemap=mwavemap, fplines=mfpl,
                      iteration='before')
        rfpl = get_master_lines(params, recipe, **fpargs)
        # ----------------------------------------------------------------------
        # get the order, pixel measured and wave ref from rfpl
        rorders = rfpl['ORDER']
        rpixels = rfpl['PIXEL_MEAS']
        rwaveref = rfpl['WAVE_REF']
        # storage of the wave coefficients
        rwavecoeffs = np.zeros((nbo, mdeg + 1))
        # loop around orders
        for order_num in range(nbo):
            # define an order mask
            good = (rorders == order_num) & np.isfinite(rpixels)
            # fit the fibers fplines to fit the measured pixel positions
            #  to the wavelength
            # TODO --> use a robust fit here
            cfit = np.polyfit(rpixels[good], rwaveref[good], mdeg)[::-1]
            # inverse fit
            icfit = np.polyfit(rwaveref[good], rpixels[good], mdeg)
            # append cfit to wave coefficients
            rwavecoeffs[order_num] = cfit
            # update pixel reference
            rfpl['PIXEL_REF'][good] = np.polyval(icfit, rwaveref[good])
        # ----------------------------------------------------------------------
        # create wave map
        rwavemap = get_wavemap_from_coeffs(rwavecoeffs, nbo, nbpix)
        # ----------------------------------------------------------------------
        # get dprtype
        dprtype = fpe2dsfile.get_hkey('KW_DPRTYPE', dtype=str)
        # get fiber type
        fibtype = pconst.FIBER_DPR_POS(dprtype, fiber)
        # get the difference between measured and reference pixels
        diffpix = rpixels - rfpl['PIXEL_REF']
        # debug plot expected lines vs measured positions
        recipe.plot('WAVEREF_EXPECTED', orders=rorders, wavemap=rwaveref,
                    diff=diffpix, fiber=fiber, nbo=nbo, fibtype=fibtype,
                    iteration='after')
        # ----------------------------------------------------------------------
        # get copy of instance of wave file (WAVE_HCMAP)
        # TODO: remove if once we only use cal_wave or cal_wave_master/night
        if 'WAVEM_FPMAP' in recipe.outputs:
            wavefile = recipe.outputs['WAVEM_FPMAP'].newcopy(params=params,
                                                             fiber=fiber)
        else:
            wavefile = recipe.outputs['WAVE_FPMAP'].newcopy(params=params,
                                                            fiber=fiber)
        # construct the filename from file instance
        wavefile.construct_filename(infile=fp_outputs[master_fiber])
        # ----------------------------------------------------------------------
        # create wprops
        # ----------------------------------------------------------------------
        rwprops = ParamDict()
        rwprops['WAVEFILE'] = wavefile.filename
        rwprops['WAVESOURCE'] = recipe.name
        rwprops['WAVETIME'] = fpe2dsfile.get_hkey('KW_MID_OBS_TIME',
                                                  dtype=float)
        rwprops['COEFFS'] = rwavecoeffs
        rwprops['WAVEMAP'] = rwavemap
        rwprops['NBO'] = nbo
        rwprops['DEG'] = mdeg
        rwprops['NBPIX'] = nbpix
        rwprops['FPLINES'] = rfpl
        # set source
        keys = ['WAVEMAP', 'WAVEFILE', 'WAVESOURCE', 'NBO', 'DEG', 'COEFFS',
                'NBPIX', 'WAVETIME', 'FPLINES']
        rwprops.set_sources(keys, func_name)
        # add rwprops to solutions
        solutions[fiber] = rwprops

    # ----------------------------------------------------------------------
    # plot comparison between master fiber and fibers
    # ----------------------------------------------------------------------
    recipe.plot('WAVE_FIBER_COMPARISON', solutions=solutions, master=mprops,
                order=None, masterfiber=master_fiber)
    recipe.plot('WAVE_FIBER_COMP', solutions=solutions, master=mprops,
                order=plot_order, masterfiber=master_fiber)
    recipe.plot('SUM_WAVE_FIBER_COMP', solutions=solutions, master=mprops,
                order=plot_order, masterfiber=master_fiber)

    # ----------------------------------------------------------------------
    # add master to solutions
    # ----------------------------------------------------------------------
    # add rwprops to solutions
    solutions[master_fiber] = ParamDict(mprops)
    # ----------------------------------------------------------------------
    # return all the solutions for all fibers
    return solutions


def update_smart_fp_mask(params, **kwargs):
    # set function name
    func_name = display_func(params, 'update_smart_fp_mask', __NAME__)
    # get constants from params
    update_mask = pcheck(params, 'WAVE_CCF_UPDATE_MASK', 'update_mask', kwargs,
                         func_name)
    assetdir = pcheck(params, 'DRS_DATA_ASSETS', 'assetsdir', kwargs, func_name)
    ccfpath = pcheck(params, 'WAVE_CCF_MASK_PATH', 'ccfpath', kwargs, func_name)
    ccfmask = pcheck(params, 'WAVE_CCF_MASK', 'ccfmask', kwargs, func_name)
    dvwidth = pcheck(params, 'WAVE_CCF_SMART_MASK_WIDTH', 'dvwidth',
                        kwargs, func_name)
    mask_units = pcheck(params, 'WAVE_CCF_MASK_UNITS', 'mask_units', kwargs,
                        func_name)
    minlambda = pcheck(params, 'WAVE_CCF_SMART_MASK_MINLAM', 'minlambda',
                       kwargs, func_name)
    maxlambda = pcheck(params, 'WAVE_CCF_SMART_MASK_MAXLAM', 'maxlambda',
                       kwargs, func_name)
    nmin = pcheck(params, 'WAVE_CCF_SMART_MASK_TRIAL_NMIN', 'nmin', kwargs,
                  func_name)
    nmax = pcheck(params, 'WAVE_CCF_SMART_MASK_TRIAL_NMAX', 'nmax', kwargs,
                  func_name)
    threshold = pcheck(params, 'WAVE_CCF_SMART_MASK_DWAVE_THRES', 'threshold',
                       kwargs, func_name)
    # if we don't want to update the mask then don't
    if not update_mask:
        return
    # ----------------------------------------------------------------------
    # construct output filename
    outfile = os.path.join(assetdir, ccfpath, ccfmask)
    # load current cavity files
    fit_1m_d, fit_ll_d = drs_data.load_cavity_files(params, required=False)
    # ----------------------------------------------------------------------
    # start with a broader range of FP N values and clip later on
    n_fp_fpeak = np.arange(nmin, nmax)

    # placeholder for wavelength, needs to be iterated-on with
    #    the cavity length polynomial
    # the starting wavelength is the midpoint between the extremities of
    #    the domain
    wave_fp_peak = np.repeat(np.mean([minlambda, maxlambda]), len(n_fp_fpeak))
    # ----------------------------------------------------------------------
    # we perform the following loop
    #
    # Take the wavelength and derive a cavity length
    # Take the Nth peak and derive a line wavelength from the
    # cavity length
    # Take the new wavelength and dereive a new cavity length
    # Find an update wavelength for the Nth peak
    #  .... converge down to a 'threshold' error in wavelength

    dwave = np.inf
    while abs(dwave) > threshold:
        # keep track of the central line to check convergence
        prev = wave_fp_peak[len(wave_fp_peak) // 2]
        # derive a new wavelength for each fp peak
        wave_fp_peak = np.polyval(fit_ll_d, wave_fp_peak) * 2 / n_fp_fpeak
        # check convergnce
        dwave = prev - wave_fp_peak[len(wave_fp_peak) // 2]
    # ----------------------------------------------------------------------
    # keep lines within the domain
    keep = (wave_fp_peak > minlambda) & (wave_fp_peak < maxlambda)
    # ----------------------------------------------------------------------
    # apply keep mask to wavelength solution and n peak
    wave_fp_peak = wave_fp_peak[keep]
    # ----------------------------------------------------------------------
    # get unit object from mask units string
    try:
        unit = getattr(uu, mask_units)
    except Exception as e:
        # log error
        eargs = [mask_units, type(e), e, func_name]
        WLOG(params, 'error', textentry('09-020-00002', args=eargs))
        return
    # add units
    wave_fp_peak = wave_fp_peak * unit
    # convert to nanometers
    wave_fp_peak = wave_fp_peak.to(uu.nm).value
    # ----------------------------------------------------------------------
    # calculate wavelength bounds of line
    wavelower = wave_fp_peak * (1 - 0.5 * dvwidth / speed_of_light)
    waveupper = wave_fp_peak * (1 + 0.5 * dvwidth / speed_of_light)
    weights = np.repeat(1.0, len(wavelower))
    # ----------------------------------------------------------------------
    # Create table to store them in
    # ----------------------------------------------------------------------
    columnnames = ['WLOW', 'WHIGH', 'WEIGHT']
    columnvalues = [wavelower, waveupper, weights]
    # make table
    table = drs_table.make_table(params, columnnames, columnvalues)
    # print that we are saving smart fp header
    WLOG(params, '', textentry('40-017-00053', args=outfile))
    # write smart mask table to file
    drs_table.write_table(params, table, outfile, fmt='ascii.fast_no_header')


# =============================================================================
# Define night functions
# =============================================================================
def night_wavesolution(params, recipe, hce2ds, fpe2ds, mhcl, mfpl, mwave,
                       wavefile, fiber, indcavity=None, **kwargs):
    # set function name
    func_name = display_func(params, 'night_wavesolution', __NAME__)
    # ----------------------------------------------------------------------
    # get parameters from params/kwargs
    niterations1 = pcheck(params, 'WAVE_NIGHT_NITERATIONS1', 'niterations1',
                          kwargs, func_name)
    niterations2 = pcheck(params, 'WAVE_NIGHT_NITERATIONS2', 'niterations2',
                          kwargs, func_name)
    d_cavity = pcheck(params, 'WAVE_NIGHT_DCAVITY', 'd_cavity', kwargs,
                      func_name)
    hcsigclip = pcheck(params, 'WAVE_NIGHT_HC_SIGCLIP', 'hcsigclip', kwargs,
                       func_name)
    nsig_fit_cut = pcheck(params, 'WAVE_NIGHT_NSIG_FIT_CUT', 'nsig_fit_cut',
                          kwargs, func_name)
    wave_fit_deg = pcheck(params, 'WAVE_FIT_DEGREE', 'wave_fit_deg', kwargs,
                          func_name)
    madvalue = pcheck(params, 'WAVE_NIGHT_MED_ABS_DEV', 'madvalue', kwargs,
                      func_name)
    pltnbins = pcheck(params, 'WAVENIGHT_PLT_NBINS', 'pltnbins', kwargs,
                      func_name)
    pltbinl = pcheck(params, 'WAVENIGHT_PLT_BINL', 'pltbinl', kwargs, func_name)
    pltbinu = pcheck(params, 'WAVENIGHT_PLT_BINU', 'pltbinl', kwargs, func_name)
    # get pconst
    pconst = constants.pload(params['INSTRUMENT'])
    # deal with havint a input dcavity width
    if indcavity is not None:
        d_cavity = float(indcavity)
        # no need to iterate on d_cavity
        niterations2 = 1
    # ----------------------------------------------------------------------
    # get image shape
    nbo, nbpix = mwave.shape
    # ----------------------------------------------------------------------
    # Update the wavelength of lines with the master solution
    # ----------------------------------------------------------------------
    # log progress: Updating measured wavelength (master)
    WLOG(params, 'info', textentry('40-017-00044'))
    # update wavelength measured in line list table
    mhcl = update_wavelength_measured(params, mhcl, mwave, kind='HC')
    mfpl = update_wavelength_measured(params, mfpl, mwave, kind='FP')

    # ----------------------------------------------------------------------
    # Construct night line list
    # ----------------------------------------------------------------------
    # log progress Constructing night list list (night)'
    WLOG(params, 'info', textentry('40-017-00045'))
    # generate the hc reference lines
    hcargs = dict(e2dsfile=hce2ds, wavemap=mwave, hclines=mhcl)
    rhcl = get_master_lines(params, recipe, **hcargs)
    # generate the fp reference lines
    fpargs = dict(e2dsfile=fpe2ds, wavemap=mwave, fplines=mfpl)
    rfpl = get_master_lines(params, recipe, **fpargs)
    # ----------------------------------------------------------------------
    # set nightly wave solution to master wave solution
    rwave = np.array(mwave)

    # ----------------------------------------------------------------------
    # Iterative loop to update wavelength
    # ----------------------------------------------------------------------
    # log progress Updating measured wavelength (night)
    WLOG(params, '', textentry('40-017-00046'))
    # update wavelength measured in line list table
    rhcl = update_wavelength_measured(params, rhcl, rwave, kind='HC')
    rfpl = update_wavelength_measured(params, rfpl, rwave, kind='FP')
    # storage for iteration plot
    pixdiffs, waverefs = [], []
    # we iteratively remove lines that are >10 median absolute differences
    for iteration in range(niterations1):
        # log progress Night wave fit iteration i of j
        wargs = [iteration + 1, 1, 'HC']
        WLOG(params, '', textentry('40-017-00047', args=wargs))
        # ------------------------------------------------------------------
        # get the pixel difference between ref and measured
        pixdiff = rhcl['PIXEL_REF'] - rhcl['PIXEL_MEAS']
        # append for plot
        pixdiffs.append(np.array(pixdiff))
        waverefs.append(np.array(rhcl['WAVE_REF']))
        # subtract of the median absolute difference
        pixdiff = pixdiff - np.nanmedian(pixdiff)
        # normalize by the pixel difference
        pixdiff = pixdiff / np.nanmedian(np.abs(pixdiff))
        # create a mask to remove values
        with warnings.catch_warnings(record=True) as _:
            madmask = np.abs(pixdiff) < madvalue
        # apply mask to rhcl
        rhcl = rhcl[madmask]
        # log how many lines we kept
        wargs = [np.sum(madmask), len(madmask)]
        WLOG(params, '', textentry('40-017-00048', args=wargs))
    # ----------------------------------------------------------------------
    # plot mad plot
    recipe.plot('WAVENIGHT_ITERPLOT', waverefs=waverefs, pixdiffs=pixdiffs,
                fiber=fiber)
    # plot mad plot
    recipe.plot('SUM_WAVENIGHT_ITERPLOT', waverefs=waverefs, pixdiffs=pixdiffs,
                fiber=fiber)
    # ----------------------------------------------------------------------
    # rhcl = rhcl[sigclipmask]
    # copy the rhcl table (before modification)
    rhcl_prev = Table(rhcl)
    # get xpix array
    xpix = np.arange(nbpix)
    # iterate around niterations1
    for iteration in range(niterations2):
        # log progress Night wave fit iteration i of j
        wargs = [iteration + 1, 1, 'FP']
        WLOG(params, '', textentry('40-017-00047', args=wargs))
        # loop around order num
        for order_num in range(nbo):
            # get this orders mask
            good = (rfpl['ORDER'] == order_num)
            good &= np.isfinite(rfpl['PIXEL_MEAS'])
            # do a robust polyfit
            xx = rfpl['PIXEL_MEAS'][good]
            yy = rfpl['WAVE_REF'][good] * (1 + d_cavity)
            fit, mask = mp.robust_polyfit(xx, yy, wave_fit_deg, nsig_fit_cut)
            # update the wave solution with these values
            rwave[order_num] = np.polyval(fit, xpix)
        # log progress Updating measured wavelength (night)
        WLOG(params, '', textentry('40-017-00046'))
        # update wavelength measured in line list table
        rhcl = update_wavelength_measured(params, rhcl, rwave, kind='HC')
        rfpl = update_wavelength_measured(params, rfpl, rwave, kind='FP')
        # only update the d_cavity if we are measuring it for the first time
        if indcavity is None:
            # calculate the change in d_cavity
            hc_wave_ratio = rhcl['WAVE_MEAS'] / rhcl['WAVE_REF']
            dd_cavity = (1 - np.nanmedian(hc_wave_ratio))
            # update d_cavity with the change in d_cavity
            d_cavity = d_cavity + dd_cavity
            # log the change in d_cavity
            wargs = [d_cavity * speed_of_light_ms,
                     dd_cavity * speed_of_light_ms]
            WLOG(params, '', textentry('40-017-00052', args=wargs))

    # ----------------------------------------------------------------------
    # plot for wave night hist plot
    # ----------------------------------------------------------------------
    # calculate rms
    pwave1 = rfpl['WAVE_REF'] * (1 + d_cavity)
    pwave2 = rfpl['WAVE_MEAS']
    rms = np.nanmedian(np.abs(1 - (pwave1 / pwave2)) * speed_of_light_ms)
    # plot wave night hist plot
    recipe.plot('WAVENIGHT_HISTPLOT', rhcl=rhcl, rhcl_prev=rhcl_prev,
                rfpl=rfpl, dcavity=d_cavity, rms=rms, binl=pltbinl,
                binu=pltbinu, nbins=pltnbins)
    # plot wave night hist plot
    recipe.plot('SUM_WAVENIGHT_HISTPLOT', rhcl=rhcl, rhcl_prev=rhcl_prev,
                rfpl=rfpl, dcavity=d_cavity, rms=rms, binl=pltbinl,
                binu=pltbinu, nbins=pltnbins, fiber=fiber)
    # ----------------------------------------------------------------------
    # calculate final coefficients and re-calculate wave map
    # ----------------------------------------------------------------------
    # get index array
    indices = np.arange(nbpix)
    # storage of coefficients
    night_coeffs = np.zeros((nbo, wave_fit_deg + 1))
    night_wave = np.zeros_like(mwave)
    # loop around orders
    for order_num in range(nbo):
        # calculate coefficients with a fit
        ocoeffs = mp.nanpolyfit(indices, rwave[order_num], wave_fit_deg)
        # push into nightly coefficients
        night_coeffs[order_num] = ocoeffs[::-1]
        # re-calculate wave map
        night_wave[order_num] = np.polyval(ocoeffs, indices)
    # ----------------------------------------------------------------------
    # update wavelength measured in line list table
    rhcl = update_wavelength_measured(params, rhcl, night_wave, kind='HC')
    rfpl = update_wavelength_measured(params, rfpl, night_wave, kind='FP')
    # ----------------------------------------------------------------------
    # after results for fp
    # ----------------------------------------------------------------------
    rorders = rfpl['ORDER']
    rpixels = rfpl['PIXEL_MEAS']
    rwaveref = rfpl['WAVE_REF']
    # get dprtype
    dprtype = fpe2ds.get_hkey('KW_DPRTYPE', dtype=str)
    # get fiber type
    fibtype = pconst.FIBER_DPR_POS(dprtype, fiber)
    # get the difference between measured and reference pixels
    diffpix = rpixels - rfpl['PIXEL_REF']
    # debug plot expected lines vs measured positions
    recipe.plot('WAVEREF_EXPECTED', orders=rorders, wavemap=rwaveref,
                diff=diffpix, fiber=fiber, nbo=nbo, fibtype=fibtype,
                iteration='after')
    # ----------------------------------------------------------------------
    # after results for fp
    # ----------------------------------------------------------------------
    rorders = rhcl['ORDER']
    rpixels = rhcl['PIXEL_MEAS']
    rwaveref = rhcl['WAVE_REF']
    # get dprtype
    dprtype = hce2ds.get_hkey('KW_DPRTYPE', dtype=str)
    # get fiber type
    fibtype = pconst.FIBER_DPR_POS(dprtype, fiber)
    # get the difference between measured and reference pixels
    diffpix = rpixels - rhcl['PIXEL_REF']
    # debug plot expected lines vs measured positions
    recipe.plot('WAVEREF_EXPECTED', orders=rorders, wavemap=rwaveref,
                diff=diffpix, fiber=fiber, nbo=nbo, fibtype=fibtype,
                iteration='after')
    # ----------------------------------------------------------------------
    # add to storage
    # ----------------------------------------------------------------------
    nprops = ParamDict()
    # add data
    nprops['COEFFS'] = night_coeffs
    nprops['WAVEMAP'] = night_wave
    nprops['WAVEFILE'] = wavefile
    nprops['WAVETIME'] = hce2ds.get_hkey('KW_MID_OBS_TIME', dtype=float)
    nprops['WAVESOURCE'] = recipe.name
    nprops['WAVEINIT'] = wavefile
    nprops['NBO'] = night_coeffs.shape[0]
    nprops['DEG'] = night_coeffs.shape[1] - 1
    nprops['NBPIX'] = night_wave.shape[1]
    nprops['HCLINES'] = rhcl
    nprops['FPLINES'] = rfpl

    # set sources
    keys = ['COEFFS', 'WAVEMAP', 'WAVEFILE', 'WAVESOURCE', 'NBO', 'DEG',
            'HCLINES', 'FPLINES', 'WAVETIME', 'WAVEINIT', 'NBPIX']
    nprops.set_sources(keys, func_name)
    # ----------------------------------------------------------------------
    # add constants
    nprops['NITERATIONS1'] = niterations1
    nprops['NITERATIONS2'] = niterations2
    nprops['HCSIGCLIP'] = hcsigclip
    nprops['MADLIMIT'] = madvalue
    nprops['DCAVITY'] = d_cavity
    nprops['NSIG_FIT_CUT'] = nsig_fit_cut
    # set sources
    keys = ['NITERATIONS1', 'NITERATIONS2', 'HCSIGCLIP', 'MADLIMIT',
            'DCAVITY', 'NSIG_FIT_CUT']
    nprops.set_sources(keys, func_name)
    # ----------------------------------------------------------------------
    # return props storage
    return nprops


def night_quality_control(params, nprops):
    _ = display_func(params, 'night_quality_control', __NAME__)
    # set passed variable and fail message list
    fail_msg = []
    qc_values, qc_names, qc_logic, qc_pass = [], [], [], []
    # --------------------------------------------------------------
    # get parameters from nprops
    wavemap = nprops['WAVEMAP']
    nbo, nbpix = wavemap.shape
    # --------------------------------------------------------------
    # check the difference between consecutive orders is always positive
    # get the differences
    wave_diff = wavemap[1:] - wavemap[:-1]
    if mp.nanmin(wave_diff) < 0:
        fail_msg.append(textentry('40-017-00030'))
        qc_pass.append(0)
    else:
        qc_pass.append(1)
    # add to qc header lists
    qc_values.append(mp.nanmin(wave_diff))
    qc_names.append('MIN WAVE DIFF')
    qc_logic.append('MIN WAVE DIFF < 0')
    # --------------------------------------------------------------
    # check the difference between consecutive pixels along an
    #     order is always positive
    # loop through the orders
    ord_check = np.zeros(nbo, dtype=bool)
    for order in range(nbo):
        wave0 = wavemap[order, :-1]
        wave1 = wavemap[order, 1:]
        ord_check[order] = np.all(wave1 > wave0)
    if np.all(ord_check):
        qc_pass.append(1)
        qc_values.append('None')
    else:
        fail_msg.append(textentry('40-017-00017'))
        qc_pass.append(0)
        badvalues = np.where(~ord_check)[0].astype(str)
        qc_values.append(','.join(list(badvalues)))
    # add to qc header lists
    qc_names.append('WAVE DIFF ALONG ORDER')
    qc_logic.append('WAVE DIFF ALONG ORDER < 0')
    # --------------------------------------------------------------
    # get passed criteria
    passed = np.all(qc_pass)
    # --------------------------------------------------------------
    # finally log the failed messages and set QC = 1 if we pass the
    #     quality control QC = 0 if we fail quality control
    if np.sum(qc_pass) == len(qc_pass):
        WLOG(params, 'info', textentry('40-005-10001'))
    else:
        for farg in fail_msg:
            WLOG(params, 'warning', textentry('40-005-10002') + farg)
    # store in qc_params
    qc_params = [qc_names, qc_values, qc_logic, qc_pass]
    return qc_params, passed


def night_write_wavesolution(params, recipe, nprops, hcfile, fpfile, fiber,
                             combine, rawhcfiles, rawfpfiles, qc_params,
                             inwavefile):
    # ----------------------------------------------------------------------
    # get copy of instance of wave file (WAVE_HCMAP)
    wavefile = recipe.outputs['WAVEMAP_NIGHT'].newcopy(params=params,
                                                       fiber=fiber)
    # construct the filename from file instance
    wavefile.construct_filename(infile=hcfile)
    # set some wave keys as "SELF" (i.e. from this wave solution)
    nprops['WAVEFILE'] = wavefile.basename
    nprops['WAVETIME'] = hcfile.get_hkey('KW_MID_OBS_TIME', dtype=float)
    sargs = [recipe.name, params['DRS_VERSION']]
    nprops['WAVESOURCE'] = '{0} [{1}]'.format(*sargs)
    nprops['WFP_FILE'] = wavefile.basename
    # ------------------------------------------------------------------
    # Make wave coefficient table
    # ------------------------------------------------------------------
    # get number of orders
    nbo = nprops['COEFFS'].shape[0]
    # add order column
    wave_cols = ['ORDER']
    wave_vals = [np.arange(nbo)]
    # add coefficients columns
    for w_it in range(nprops['COEFFS'].shape[1]):
        wave_cols.append('COEFFS_{0}'.format(w_it))
        wave_vals.append(nprops['COEFFS'][:, w_it])
    wave_table = drs_table.make_table(params, columns=wave_cols,
                                      values=wave_vals)
    # ----------------------------------------------------------------------
    # define header keys for output file
    # copy keys from input file
    wavefile.copy_original_keys(hcfile, exclude_groups='wave')
    # ----------------------------------------------------------------------
    # copy in wave file keys
    wavefile.copy_original_keys(inwavefile, group='wave')
    # ----------------------------------------------------------------------
    # add version
    wavefile.add_hkey('KW_VERSION', value=params['DRS_VERSION'])
    # add dates
    wavefile.add_hkey('KW_DRS_DATE', value=params['DRS_DATE'])
    wavefile.add_hkey('KW_DRS_DATE_NOW', value=params['DATE_NOW'])
    # add process id
    wavefile.add_hkey('KW_PID', value=params['PID'])
    # add output tag
    wavefile.add_hkey('KW_OUTPUT', value=wavefile.name)
    wavefile.add_hkey('KW_FIBER', value=fiber)
    # add input hc files (and deal with combining or not combining)
    if combine:
        hfiles = rawhcfiles
    else:
        hfiles = [hcfile.basename]
    wavefile.add_hkey_1d('KW_INFILE1', values=hfiles, dim1name='file')
    # add input fp files (and deal with combining or not combining)
    if combine:
        hfiles = rawfpfiles
    else:
        hfiles = [fpfile.basename]
    wavefile.add_hkey_1d('KW_INFILE2', values=hfiles, dim1name='file')
    # add constants used (for reproduction)
    wavefile.add_hkey('KW_WNT_NITER1', value=nprops['NITERATIONS1'])
    wavefile.add_hkey('KW_WNT_NITER2', value=nprops['NITERATIONS2'])
    wavefile.add_hkey('KW_WNT_HCSIGCLIP', value=nprops['HCSIGCLIP'])
    wavefile.add_hkey('KW_WNT_MADLIMIT', value=nprops['MADLIMIT'])
    wavefile.add_hkey('KW_WNT_DCAVITY', value=nprops['DCAVITY'])
    wavefile.add_hkey('KW_WNT_DCAVSRCE', value=nprops['DCAVITYSRCE'])
    wavefile.add_hkey('KW_WNT_NSIG_FIT', value=nprops['NSIG_FIT_CUT'])
    # ----------------------------------------------------------------------
    # add the order num, fit degree and fit coefficients
    wavefile = add_wave_keys(params, wavefile, nprops)
    # add wave init
    wavefile.add_hkey('KW_INIT_WAVE', value=nprops['WAVEINIT'])
    # ----------------------------------------------------------------------
    # add qc parameters
    wavefile.add_qckeys(qc_params)
    # copy data
    wavefile.data = nprops['WAVEMAP']
    # ----------------------------------------------------------------------
    # log that we are saving rotated image
    wargs = [fiber, wavefile.filename]
    WLOG(params, '', textentry('40-017-00037', args=wargs))
    # write image to file
    wavefile.write_multi(data_list=[wave_table], dtype_list=['table'],
                         kind=recipe.outputtype, runstring=recipe.runstring)
    # add to output files (for indexing)
    recipe.add_output_file(wavefile)
    # ------------------------------------------------------------------
    # write hc lines
    # ------------------------------------------------------------------
    # get copy of instance of wave file (WAVE_HCMAP)
    hclfile = recipe.outputs['WAVE_HCLIST'].newcopy(params=params, fiber=fiber)
    # construct the filename from file instance
    hclfile.construct_filename(infile=hcfile)
    # ------------------------------------------------------------------
    # copy keys from hcwavefile
    hclfile.copy_hdict(wavefile)
    # set output key
    hclfile.add_hkey('KW_OUTPUT', value=hclfile.name)
    # set data
    hclfile.data = nprops['HCLINES']
    hclfile.datatype = 'table'
    # ------------------------------------------------------------------
    # log that we are saving rotated image
    wargs = [fiber, hclfile.filename]
    WLOG(params, '', textentry('40-017-00039', args=wargs))
    # write image to file
    hclfile.write_file(kind=recipe.outputtype, runstring=recipe.runstring)
    # add to output files (for indexing)
    recipe.add_output_file(hclfile)
    # ------------------------------------------------------------------
    # write fp lines
    # ------------------------------------------------------------------
    write_fplines(params, recipe, nprops['FPLINES'], fpfile, wavefile, fiber)
    # ----------------------------------------------------------------------
    # return hc wavefile
    return wavefile, nprops


def write_fplines(params, recipe, rfpl, infile, hfile, fiber, kind=None):
    # deal with no kind set
    if kind is None:
        kind = 'WAVE_FPLIST'
    # get copy of instance of wave file (WAVE_HCMAP)
    fplfile = recipe.outputs[kind].newcopy(params=params, fiber=fiber)
    # construct the filename from file instance
    fplfile.construct_filename(infile=infile)
    # ------------------------------------------------------------------
    # copy keys from hfile
    fplfile.copy_hdict(hfile)
    # set output key
    fplfile.add_hkey('KW_OUTPUT', value=infile.name)
    # set data
    fplfile.data = rfpl
    fplfile.datatype = 'table'
    # ------------------------------------------------------------------
    # log that we are saving rotated image
    wargs = [fiber, fplfile.filename]
    WLOG(params, '', textentry('40-017-00039', args=wargs))
    # write image to file
    fplfile.write_file(kind=recipe.outputtype, runstring=recipe.runstring)
    # add to output files (for indexing)
    recipe.add_output_file(fplfile)


# =============================================================================
# Define wave update functions
# =============================================================================
def update_extract_files(params, recipe, extract_file, wprops, extname,
                         fiber, calibdbm):
    # ----------------------------------------------------------------------
    # find the extraction recipe
    extrecipe, _ = drs_startup.find_recipe(extname, params['INSTRUMENT'],
                                           mod=recipe.recipemod)
    extrecipe.params = params
    # ----------------------------------------------------------------------
    # get input to extract file
    input_filename = extract_file.get_hkey('INF1000')
    input_file = extract_file.intype
    # ----------------------------------------------------------------------
    # make a new copy of infileexclude_group
    infile = input_file.newcopy(params=params)
    infile.set_filename(input_filename)
    # ----------------------------------------------------------------------
    # get extraction files
    e2ds_file = extrecipe.outputs['E2DS_FILE'].newcopy(params=params,
                                                       fiber=fiber)
    e2dsff_file = extrecipe.outputs['E2DSFF_FILE'].newcopy(params=params,
                                                           fiber=fiber)
    e2dsll_file = extrecipe.outputs['E2DSLL_FILE'].newcopy(params=params,
                                                           fiber=fiber)
    s1dw_file = extrecipe.outputs['S1D_W_FILE'].newcopy(params=params,
                                                        fiber=fiber)
    s1dv_file = extrecipe.outputs['S1D_V_FILE'].newcopy(params=params,
                                                        fiber=fiber)
    # ----------------------------------------------------------------------
    # construct filename
    e2ds_file.construct_filename(infile=infile)
    e2dsff_file.construct_filename(infile=infile)
    e2dsll_file.construct_filename(infile=infile)
    s1dw_file.construct_filename(infile=infile)
    s1dv_file.construct_filename(infile=infile)
    # ----------------------------------------------------------------------
    # log that we are updating the file with wave params
    wargs = [e2ds_file.name, e2ds_file.filename]
    WLOG(params, '', textentry('40-017-00038', args=wargs))
    # update the e2ds file
    e2ds_file.read_file()
    e2ds_file.read_header()
    e2ds_file = add_wave_keys(params, e2ds_file, wprops)
    e2ds_file.write_file(kind=recipe.outputtype, runstring=recipe.runstring)
    # add to output files (for indexing)
    recipe.add_output_file(e2ds_file)
    # ----------------------------------------------------------------------
    # log that we are updating the file with wave params
    wargs = [e2dsff_file.name, e2dsff_file.filename]
    WLOG(params, '', textentry('40-017-00038', args=wargs))
    # update the e2ds file
    e2dsff_file.read_file()
    e2dsff_file = add_wave_keys(params, e2dsff_file, wprops)
    e2dsff_file.write_file(kind=recipe.outputtype, runstring=recipe.runstring)
    # add to output files (for indexing)
    recipe.add_output_file(e2dsff_file)
    # ----------------------------------------------------------------------
    # log that we are updating the file with wave params
    wargs = [e2dsll_file.name, e2dsll_file.filename]
    WLOG(params, '', textentry('40-017-00038', args=wargs))
    # update the e2ds file
    e2dsll_file.read_file()
    e2dsll_file = add_wave_keys(params, e2dsll_file, wprops)
    e2dsll_file.write_file(kind=recipe.outputtype, runstring=recipe.runstring)
    # add to output files (for indexing)
    recipe.add_output_file(e2dsll_file)
    # ----------------------------------------------------------------------
    # Need to re-calculate the s1d files
    # ----------------------------------------------------------------------
    # load the blaze file for this fiber
    blaze_file, blaze = flat_blaze.get_blaze(params, e2dsff_file.get_header(),
                                             fiber, database=calibdbm)
    # calculate s1d file
    sargs = [wprops['WAVEMAP'], e2dsff_file.get_data(), blaze]
    swprops = extract.e2ds_to_s1d(params, recipe, *sargs, wgrid='wave',
                                  fiber=fiber, kind='E2DSFF')
    svprops = extract.e2ds_to_s1d(params, recipe, *sargs,
                                  wgrid='velocity', fiber=fiber,
                                  kind='E2DSFF')
    # ----------------------------------------------------------------------
    # plot the s1d plot
    recipe.plot('EXTRACT_S1D', params=params, props=svprops,
                fiber=fiber, kind='E2DSFF')
    # ----------------------------------------------------------------------
    # Store S1D_W in file
    # ----------------------------------------------------------------------
    # copy header from e2dsll file
    s1dw_file.copy_hdict(e2ds_file)
    s1dw_file.copy_header(e2ds_file)
    # set output key
    s1dw_file.add_hkey('KW_OUTPUT', value=s1dw_file.name)
    # add new header keys
    s1dw_file = extract.add_s1d_keys(s1dw_file, swprops)
    # copy data
    s1dw_file.data = swprops['S1DTABLE']
    # must change the datatype to 'table'
    s1dw_file.datatype = 'table'
    # ----------------------------------------------------------------------
    # log that we are updating the file with wave params
    wargs = [s1dw_file.name, s1dw_file.filename]
    WLOG(params, '', textentry('40-017-00038', args=wargs))
    # write image to file
    s1dw_file.write_file(kind=recipe.outputtype, runstring=recipe.runstring)
    # add to output files (for indexing)
    recipe.add_output_file(s1dw_file)
    # ----------------------------------------------------------------------
    # Store S1D_W in file
    # ----------------------------------------------------------------------
    # copy header from e2dsll file
    s1dv_file.copy_hdict(e2ds_file)
    s1dv_file.copy_header(e2ds_file)
    # add new header keys
    s1dv_file = extract.add_s1d_keys(s1dv_file, svprops)
    # set output key
    s1dv_file.add_hkey('KW_OUTPUT', value=s1dv_file.name)
    # copy data
    s1dv_file.data = svprops['S1DTABLE']
    # must change the datatype to 'table'
    s1dv_file.datatype = 'table'
    # ----------------------------------------------------------------------
    # log that we are updating the file with wave params
    wargs = [s1dv_file.name, s1dv_file.filename]
    WLOG(params, '', textentry('40-017-00038', args=wargs))
    # write image to file
    s1dv_file.write_file(kind=recipe.outputtype, runstring=recipe.runstring)
    # add to output files (for indexing)
    recipe.add_output_file(s1dv_file)

    # return e2dsff file
    return e2dsff_file


# =============================================================================
# Start of code
# =============================================================================
# Main code here
if __name__ == "__main__":
    # ----------------------------------------------------------------------
    # print 'Hello World!'
    print("Hello World!")

# =============================================================================
# End of code
# =============================================================================
