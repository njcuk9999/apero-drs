#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
# CODE NAME HERE

# CODE DESCRIPTION HERE

Created on 

@author: 
"""
from astropy.table import Table
from astropy import constants as cc
from astropy import units as uu
import numpy as np
import os
from scipy.optimize import curve_fit
from typing import Any, Dict, List, Tuple, Union
import warnings

from apero.core import constants
from apero.core import math as mp
from apero import lang
from apero.core.core import drs_log
from apero.core.core import drs_file
from apero.core.core import drs_database
from apero.core.core import drs_text
from apero.core.utils import drs_startup
from apero.core.utils import drs_recipe
from apero.core.utils import drs_data
from apero.io import drs_image
from apero.io import drs_fits
from apero.io import drs_table
from apero.science.calib import gen_calib
from apero.science.calib import flat_blaze
from apero.science import extract
from apero.science import velocity


# =============================================================================
# Define variables
# =============================================================================
__NAME__ = 'science.calib.wave.py'
__INSTRUMENT__ = 'None'
# Get constants
Constants = constants.load(__INSTRUMENT__)
# Get version and author
__version__ = Constants['DRS_VERSION']
__author__ = Constants['AUTHORS']
__date__ = Constants['DRS_DATE']
__release__ = Constants['DRS_RELEASE']
# get param dict
ParamDict = constants.ParamDict
DrsFitsFile = drs_file.DrsFitsFile
DrsRecipe = drs_recipe.DrsRecipe
# get calibration database
CalibDB = drs_database.CalibrationDatabase
# Get Logging function
WLOG = drs_log.wlog
# alias pcheck
pcheck = constants.PCheck(wlog=WLOG)
# Get the text types
textentry = lang.textentry
# Speed of light
# noinspection PyUnresolvedReferences
speed_of_light_ms = cc.c.to(uu.m / uu.s).value
# noinspection PyUnresolvedReferences
speed_of_light = cc.c.to(uu.km / uu.s).value
# Get function string
display_func = drs_log.display_func
# define the header types
HeaderType = Union[drs_fits.Header, drs_fits.fits.Header, None]


# =============================================================================
# Define getting file functions
# =============================================================================
def get_masterwave_filename(params: ParamDict, fiber: str,
                            database: Union[CalibDB, None] = None
                            ) -> Tuple[str, Union[DrsFitsFile, None]]:
    """
    Load the master wave solution

    Order of preference: WAVESOL_MASTER >> WAVESOL_DEFAULT

    :param params:
    :param fiber:
    :param database:
    :return:
    """
    # set function name
    func_name = display_func('get_masterwave_filename', __NAME__)
    # get pseudo constants
    pconst = constants.pload()
    # deal with fibers that we don't have
    usefiber = pconst.FIBER_WAVE_TYPES(fiber)
    # ------------------------------------------------------------------------
    # load database
    if database is None:
        calibdbm = CalibDB(params)
        calibdbm.load_db()
    else:
        calibdbm = database
    # ------------------------------------------------------------------------
    # get file definition (order of preference)
    keys = ['WAVESOL_MASTER', 'WAVESOL_DEFAULT']
    filename, out_wave = None, None
    # loop around possible wave master keys
    for k_it in range(len(keys)):
        # first check for wave masters generated by the drs
        gkwargs = dict(block_kind='red', required=False)
        out_wave = drs_file.get_file_definition(params, keys[k_it], **gkwargs)
        # if out_wave is None we need to check other keys
        if out_wave is None:
            continue
        # get calibration key
        key = out_wave.get_dbkey()
        # ---------------------------------------------------------------------
        # load master key
        fout = calibdbm.get_calib_file(key, no_times=True, nentries=1,
                                       required=False, fiber=usefiber)
        filename, _, _ = fout
        # stop loop if we have found our master file
        if filename is not None:
            break
    # if we still have None we have a problem
    if filename is None:
        eargs = [', '.join(keys), func_name]
        WLOG(params, 'error', textentry('09-017-00007', args=eargs))
        return '', None
    else:
        # return the last valid wave entry
        return str(filename), out_wave


WaveReturn = Tuple[DrsFitsFile, Union[np.ndarray, None], str, float]


def get_wave_solution_from_wavefile(params: ParamDict, usefiber: str,
                                    inwavefile: str, header: HeaderType,
                                    database: Union[CalibDB, None] = None,
                                    master: bool = False) -> WaveReturn:
    """
    Get wave solution from a given wave filename

    :param params: ParamDict, parameter dictionary of constants
    :param usefiber: str, the fiber for this wave file
    :param inwavefile: str, the wave filename
    :param header: fits.Header, the header for this wave file
    :param database: calibration database instance or None - just so we don't
                     have to load it if already loaded
    :param master: bool, if True we require the master file (overrides the
                   wave filename

    :return: wave file instance, wave map, wave file name and mid exp time
    """
    # ------------------------------------------------------------------------
    # get file definitions (wave solution FP and wave solution HC)
    out_wave = drs_file.get_file_definition(params, 'WAVE_NIGHT',
                                            block_kind='red')
    # ------------------------------------------------------------------------
    # deal with master = True
    if master is True:
        # get master path
        inwavefile, out_wave = get_masterwave_filename(params, fiber=usefiber,
                                                       database=database)
        # deal with out_wave from master
        out_wave = out_wave
        source = 'master'
    else:
        # ---------------------------------------------------------------------
        # setup calib db keys
        # ---------------------------------------------------------------------
        # get calibration key
        key = out_wave.get_dbkey()
        # ---------------------------------------------------------------------
        if database is None:
            # load the calibration database
            calibdbm = CalibDB(params)
            calibdbm.load_db()
        else:
            calibdbm = database
        # ---------------------------------------------------------------------
        # load filename from inputs/calibDB
        # ---------------------------------------------------------------------
        lkwargs = dict(userinputkey='WAVEFILE', database=calibdbm, key=key,
                       inheader=header, filename=inwavefile, fiber=usefiber,
                       return_filename=True, required=False)
        # load wave fp file
        cfile = gen_calib.CalibFile()
        cfile.load_calib_file(params, **lkwargs)
        # get filename and source from outputs
        inwavefile = cfile.filename
        source = cfile.source
        if not drs_text.null_text(source, ['None']):
            source += '[night]'
        # ---------------------------------------------------------------------
        # if inwavefile is still None
        if not cfile.found:
            # get master path
            inwavefile, out_wave = get_masterwave_filename(params,
                                                           fiber=usefiber,
                                                           database=database)
            # deal with out_wave from master
            source = 'master'
    # -------------------------------------------------------------------------
    # construct new infile instance (first fp solution then hc solutions)
    wavefile = out_wave.newcopy(filename=inwavefile, params=params,
                                fiber=usefiber)
    # read data/header
    wavefile.read_file()
    # get wave map
    wavemap = wavefile.get_data(copy=True)
    # set wave source of wave file
    wavesource = source
    # get wave time
    wavetime = wavefile.get_hkey('KW_MID_OBS_TIME', dtype=float,
                                 has_default=True, default=0.0)
    # return to main get_wave function
    return wavefile, wavemap, wavesource, wavetime


def get_wave_solution_from_inheader(params: ParamDict, recipe: DrsRecipe,
                                    infile: DrsFitsFile, header: HeaderType,
                                    usefiber: str) -> WaveReturn:
    # set function
    func_name = display_func('get_wave_solution_from_inheader',
                             __NAME__)
    # ------------------------------------------------------------------------
    # type 1: just from header
    if infile is None:
        # get keywords from params
        outputkey = params['KW_OUTPUT'][0]
        dprtypekey = params['KW_DPRTYPE'][0]
        # first see if we are dealing with a reduced file
        if outputkey in header:
            # get filetype from header (KW_OUTPUT)
            filetype = header[outputkey]
            # set kind
            kind = 'red'
        # else we can't have a wavelength solution
        else:
            # get filetype from header (dprtype)
            filetype = header[dprtypekey]
            # log error
            eargs = [outputkey, dprtypekey, filetype, func_name]
            WLOG(params, 'error', textentry('00-017-00008', args=eargs))
            kind = None
        # get wave file instance
        wavefile = drs_file.get_file_definition(params, filetype,
                                                block_kind=kind, fiber=usefiber)
        # set wave file properties (using header)
        wavefile.recipe = recipe
        wavefile.header = header
        wavefile.filename = header[params['KW_WAVEFILE'][0]]
        # if we have a wave time use it
        if params['KW_WAVETIME'][0] in header:
            wavetime = header[params['KW_WAVETIME'][0]]
        else:
            wavetime = header[params['KW_MID_OBS_TIME'][0]]
        # set the wave file data
        wavefile.data = np.zeros((header['NAXIS2'], header['NAXIS1']))
        # set the source as header
        wavesource = 'header'
        # get wave map
        wavemap = None
    # ------------------------------------------------------------------------
    # type 2: from infile DrsFitsFile
    else:
        wavefile = infile.completecopy(infile)
        # set the file name to the wave file
        wavefile.filename = wavefile.get_hkey('KW_WAVEFILE')
        # if we have a wave time use it
        if params['KW_WAVETIME'][0] in header:
            wavetime = wavefile.get_hkey('KW_WAVETIME')
        else:
            wavetime = wavefile.get_hkey('KW_MID_OBS_TIME', dtype=float,
                                         has_default=True, default=0.0)
        # wave source is the infile
        wavesource = 'infile'
        # get wave map
        wavemap = None

    assert isinstance(wavefile, DrsFitsFile)
    # ------------------------------------------------------------------------
    return wavefile, wavemap, wavesource, wavetime


def get_wavesolution(params: ParamDict, recipe: DrsRecipe,
                     header: HeaderType = None,
                     infile: Union[DrsFitsFile, None] = None,
                     fiber: Union[str, None] = None,
                     master: bool = False,
                     database: Union[CalibDB, None] = None,
                     nbpix: Union[int, None] = None,
                     **kwargs) -> ParamDict:
    """
    Get the wavelength solution

    1. From file (if "filename" set in call)
    2. From file (if --wavefile set in sys.argv from params['INPUTS'])
    3. From calibDB if force=True or master=True or keys missing from
       infile/header
    4. From header if not None and keys present
    5. From infile if not None and keys present

    :param params: parameter dictionary, ParamDict containing constants
    :param recipe: DrsRecipe instance, the recipe instance used
    :param header: FitsHeader or None, the header to use
    :param infile: DrsFitsFile or None, the infile associated with the header
                   can be used instead of header - this MUST be of E2DS
                   file format to get the proper wave solution
    :param fiber: str, the fiber to get the wave solution for
    :param master: bool, if True forces use of the master wavelength solution
    :param database: calib database or None, if set avoids reloading the
                     calibration database
    :param nbpix: int or None, if in file is not set we require the size of each
                  order in pixels
    :param kwargs: keyword arguments passed to function

    :keyword force: bool, if True forces wave solution to come from calibDB
    :keyword filename: str or None, the filename to get wave solution from
                       this will overwrite all other options
    :return:
    """
    # set function name
    func_name = display_func('get_wavesolution', __NAME__)
    # get parameters from params/kwargs
    inwavefile = kwargs.get('filename', None)
    # deal with wave file in the inputs
    if inwavefile is None and 'WAVEFILE' in params['INPUTS']:
        inwavefile = params['INPUTS']['WAVEFILE']
    # if we have an in wave file we are forcing the solution
    if not drs_text.null_text(inwavefile, ['Null', 'None', '']):
        force = True
    else:
        force = pcheck(params, 'CALIB_DB_FORCE_WAVESOL', 'force', kwargs,
                       func_name)
    # ------------------------------------------------------------------------
    # get pseudo constants
    pconst = constants.pload()
    # deal with which fiber to use
    if kwargs.get('forcefiber', False):
        usefiber = str(fiber)
    elif master:
        usefiber = pconst.FIBER_WAVE_TYPES(fiber)
    else:
        usefiber = str(fiber)
    # ------------------------------------------------------------------------
    # deal with infile vs header (need one for either forced or unforced)
    #    exception is when we are getting a master
    # ------------------------------------------------------------------------
    # check infile is instance of DrsFitsFile
    if infile is not None:
        if not isinstance(infile, drs_file.DrsFitsFile):
            eargs = [type(infile), func_name]
            WLOG(params, 'error', textentry('00-017-00001', args=eargs))
    # ------------------------------------------------------------------------
    # deal with no header but an infile
    if header is None and infile is not None:
        header = infile.get_header()
    # we need a header unless master is True
    if not master and header is None:
        WLOG(params, 'error', textentry('00-017-00009', args=[func_name]))
    # ------------------------------------------------------------------------
    # Get in wave file
    # ------------------------------------------------------------------------
    # check whether we need to force from database
    force = force or master
    if master is False:
        force = force or (params['KW_WAVE_NBO'][0] not in header)
        force = force or (params['KW_WAVE_DEG'][0] not in header)
        force = force or (params['KW_CDBWAVE'][0] not in header)
        # deal with header having different fiber value that usefiber
        if not force and (params['KW_FIBER'][0] in header):
            if header[params['KW_FIBER'][0]] != usefiber:
                force = True
    # ------------------------------------------------------------------------
    # Mode 1: forced from input filename or calibDB i.e. from a wave file
    # ------------------------------------------------------------------------
    if force:
        wargs = [usefiber, inwavefile, header, database, master]
        wout = get_wave_solution_from_wavefile(params, *wargs)
        wavefile, wavemap, wavesource, wavetime = wout
    # ------------------------------------------------------------------------
    # Mode 2: using header or infile only i.e. from the input files header
    # ------------------------------------------------------------------------
    else:
        wargs = [infile, header, usefiber]
        wout = get_wave_solution_from_inheader(params, recipe, *wargs)
        wavefile, wavemap, wavesource, wavetime = wout
    # ------------------------------------------------------------------------
    # Log progress
    # -------------------------------------------------------------------------
    wargs = [wavesource, wavefile.filename]
    WLOG(params, '', textentry('40-017-00036', args=wargs))
    # ------------------------------------------------------------------------
    # Now deal with using wavefile
    # -------------------------------------------------------------------------
    # wavefile must have params set
    wavefile.params = params
    # extract keys from header
    nbo = wavefile.get_hkey('KW_WAVE_NBO', dtype=int)
    deg = wavefile.get_hkey('KW_WAVE_DEG', dtype=int)
    # get the wfp keys
    wfp_file = wavefile.get_hkey('KW_WFP_FILE', dtype=str,
                                 required=False)
    wfp_drift = wavefile.get_hkey('KW_WFP_DRIFT', dtype=float,
                                  required=False)
    wfp_fwhm = wavefile.get_hkey('KW_WFP_FWHM', dtype=float,
                                 required=False)
    wfp_contrast = wavefile.get_hkey('KW_WFP_CONTRAST', dtype=float,
                                     required=False)
    wfp_mask = wavefile.get_hkey('KW_WFP_MASK', dtype=float,
                                 required=False)
    wfp_lines = wavefile.get_hkey('KW_WFP_LINES', dtype=float,
                                  required=False)
    wfp_target_rv = wavefile.get_hkey('KW_TARG_RV', dtype=float,
                                      required=False)
    wfp_width = wavefile.get_hkey('KW_WFP_WIDTH', dtype=float,
                                  required=False)
    wfp_step = wavefile.get_hkey('KW_WFP_STEP', dtype=float,
                                 required=False)
    # extract cofficients from header
    wave_coeffs = wavefile.get_hkey_2d('KW_WAVECOEFFS',
                                       dim1=nbo, dim2=deg + 1)
    # -------------------------------------------------------------------------
    # if wavemap is unset create it from wave coefficients
    if wavemap is None:
        # get image dimensions
        if infile is not None:
            _, nbx = infile.get_data().shape
        # if not we must have nbpix specified (cannot come from primary header)
        elif nbpix is not None:
            nbx = int(nbpix)
        # otherwise we cannot make wavemap so log error
        else:
            WLOG(params, 'error', textentry('09-017-00008', args=[func_name]))
            nbx = 0
        # get the wave map
        wavemap = get_wavemap_from_coeffs(wave_coeffs, nbo, nbx)
    # -------------------------------------------------------------------------
    # deal with no target rv
    if wfp_target_rv is None:
        wfp_target_rv = 0.0
    # -------------------------------------------------------------------------
    # store wave properties in parameter dictionary
    wprops = ParamDict()
    wprops['WAVEFILE'] = wavefile.filename
    wprops['WAVEINIT'] = wavefile.filename
    wprops['WAVESOURCE'] = wavesource
    wprops['NBO'] = nbo
    if wavemap is not None:
        wprops['NBPIX'] = wavemap.shape[1]
    else:
        wprops['NBPIX'] = None
    wprops['DEG'] = deg
    wprops['COEFFS'] = wave_coeffs
    wprops['WAVEMAP'] = wavemap
    wprops['WAVEINST'] = wavefile.completecopy(wavefile)
    wprops['WAVETIME'] = wavetime
    # add the cavity polynomial degree (if present)
    cavdeg = wavefile.get_hkey('KW_CAVITY_DEG', required=False)
    # deal with no cavity key (i.e. the default master file)
    if cavdeg is None:
        cavdeg = params['WAVE_CAVITY_FIT_DEGREE']
        cav_coeffs = np.full(cavdeg + 1, np.nan)
    else:
        cavdeg = int(cavdeg)
        cav_coeffs = wavefile.get_hkey_1d('KW_CAVITY_WIDTH', cavdeg + 1)
    # add cavity keys to wprops
    wprops['CAVITY'] = cav_coeffs
    wprops['CAVITY_DEG'] = cavdeg
    wprops['MEAN_HC_VEL'] = wavefile.get_hkey('KW_WAVE_MEANHC', required=False)
    wprops['ERR_HC_VEL'] = wavefile.get_hkey('KW_WAVE_EMEANHC', required=False)
    # add the wfp keys
    wfp_keys = ['WFP_FILE', 'WFP_DRIFT', 'WFP_FWHM', 'WFP_CONTRAST', 'WFP_MASK',
                'WFP_LINES', 'WFP_TARG_RV', 'WFP_WIDTH', 'WFP_STEP']
    wfp_values = [wfp_file, wfp_drift, wfp_fwhm, wfp_contrast, wfp_mask,
                  wfp_lines, wfp_target_rv, wfp_width, wfp_step]
    # add keys accounting for 'None' and blanks
    for wfpi in range(len(wfp_keys)):
        if wfp_values[wfpi] == '' or wfp_values[wfpi] == 'None':
            wprops[wfp_keys[wfpi]] = None
        else:
            wprops[wfp_keys[wfpi]] = wfp_values[wfpi]
    # set the source
    keys = ['WAVEMAP', 'WAVEFILE', 'WAVEINIT', 'WAVESOURCE', 'NBO', 'DEG',
            'COEFFS', 'WAVETIME', 'WAVEINST', 'NBPIX', 'CAVITY',
            'CAVITY_DEG', 'MEAN_HC_VEL', 'ERR_HC_VEL'] + wfp_keys
    wprops.set_sources(keys, func_name)
    # -------------------------------------------------------------------------
    # get the echelle order numbers
    wprops = get_echelle_orders(params, wprops)
    # -------------------------------------------------------------------------
    # return the map and properties
    return wprops


def get_wavemap_from_coeffs(wave_coeffs: np.ndarray, nbo: int,
                            nbx: int) -> np.ndarray:
    """
    Get the wave map from a wave matrix (set of coefficients per order)

    :param wave_coeffs: np.ndarray (2D), the wave coefficients
                        shape = (nbo x (fit degree + 1))
    :param nbo: int, the number of orders
    :param nbx: int, the number of pixels along the order direction (x)

    :return: np.ndarray, 2D wave map, shape = (nbo x nbx)
    """
    # set up storage
    wavemap = np.zeros((nbo, nbx))
    xpixels = np.arange(nbx)
    # loop aroun each order
    for order_num in range(nbo):
        # get this order coefficients
        ocoeffs = wave_coeffs[order_num][::-1]
        # calculate polynomial values and push into wavemap
        wavemap[order_num] = np.polyval(ocoeffs, xpixels)
    return wavemap


def get_cavity_file(params: ParamDict, header: HeaderType = None,
                    infile: Union[DrsFitsFile, None] = None,
                    database: Union[CalibDB, None] = None
                    ) -> Union[np.array, None]:
    """
    Get the cavity file

    :param params: ParamDict, parameter dictionary of constants
    :param header: the header from an input file (required because we may have
                   multiple cavity files in the calibration database)
    :param infile: DrsFitsFile, instead of header + filename you can give a
                   DrsFitsFile instance (which has header and filename
                   internally)
    :param database: calibration database instance or None, stops us reloading
                     the calibration database when already loaded

    :return: the cavity polynomial coefficients (as a numpy array)
    """
    # get cavity file
    cavity_file = drs_file.get_file_definition(params, 'WAVEM_CAV',
                                               block_kind='red')
    # deal with infile (instead of header/filename)
    if infile is not None:
        header = infile.header
        # filename = infile.filename
    # ---------------------------------------------------------------------
    # setup calib db keys
    # ---------------------------------------------------------------------
    # get calibration key
    cavity_key = cavity_file.get_dbkey()
    # ---------------------------------------------------------------------
    if database is None:
        # load the calibration database
        calibdbm = CalibDB(params)
        calibdbm.load_db()
    else:
        calibdbm = database
    # ---------------------------------------------------------------------
    # load filename from inputs/calibDB
    # ---------------------------------------------------------------------
    lkwargs = dict(userinputkey='CAVITYFILE', database=calibdbm, key=cavity_key,
                   inheader=header, required=True)
    # load wave fp file
    cfile = gen_calib.CalibFile()
    cfile.load_calib_file(params, **lkwargs)
    # deal with no cavity file
    if not cfile.found:
        return None
    else:
        cimage = cfile.data
    # ---------------------------------------------------------------------
    # return cavity image
    return np.array(cimage)


def get_wavelines(params: ParamDict, fiber: str,
                  header: HeaderType = None,
                  infile: Union[DrsFitsFile, None] = None,
                  database: Union[CalibDB, None] = None,
                  hclinefile: Union[str, None] = None,
                  fplinefile: Union[str, None] = None,
                  ) -> Tuple[Table, str, Table, str]:
    """
    Get the HC and FP line tables from the calibration database

    :param params: ParamDict, the parameter dictionary of constants
    :param fiber: str, the fiber we need the lines for
    :param header: Header, the fits header (for matching calibDB to date)
                   can be None if infile is defined
    :param infile: DrsFitsFile, the drs fits file instance containing a header,
                   can be None if header is defined
    :param database: CalibDB, the calibration database instance, can be None
                     and is loaded during running (slower)
    :param hclinefile: str or None, if sets overrides the HC line table from
                       the calibration database
    :param fplinefile: str or None, if set overrides the FP line table from
                       the calibration database

    :return: Tuple, 1. astropy.table.Table, the HC line table,
             2. str, the source of the HC line table,
             3. astropy.table.Table, the FP line table,
             4. str, the source of the FP line table
    """
    # set up function name
    func_name = display_func('get_wavelines', __NAME__)
    # get psuedo constants
    pconst = constants.pload()
    # deal with fibers that we don't have
    usefiber = pconst.FIBER_WAVE_TYPES(fiber)
    # ------------------------------------------------------------------------
    # load database
    if database is None:
        calibdbm = CalibDB(params)
        calibdbm.load_db()
    else:
        calibdbm = database
    # ------------------------------------------------------------------------
    # log progress
    WLOG(params, '', textentry('40-017-00040'))
    # ------------------------------------------------------------------------
    # check infile is instance of DrsFitsFile
    if infile is not None:
        if not isinstance(infile, drs_file.DrsFitsFile):
            eargs = [type(infile), func_name]
            WLOG(params, 'error', textentry('00-017-00001', args=eargs))
    # ------------------------------------------------------------------------
    # deal with no header but an infile
    if header is None and infile is not None:
        header = infile.get_header()
    # deal with still having no header
    if header is None:
        # log error: header not defined.
        eargs = [func_name]
        WLOG(params, 'error', textentry('00-017-00009', args=eargs))
    # ------------------------------------------------------------------------
    # get file definitions (wave solution FP and wave solution HC)
    out_wave_fp = drs_file.get_file_definition(params, 'WAVE_FPLIST_MASTER',
                                               block_kind='red')
    out_wave_hc = drs_file.get_file_definition(params, 'WAVE_HCLIST_MASTER',
                                               block_kind='red')
    # get calibration key
    key_fp = out_wave_fp.get_dbkey()
    key_hc = out_wave_hc.get_dbkey()
    # ------------------------------------------------------------------------
    # get hc lines
    # ------------------------------------------------------------------------
    lkwargs = dict(database=calibdbm, fiber=usefiber, return_filename=True,
                   inheader=header)
    # load the hc lines calib file
    cfile = gen_calib.CalibFile()
    cfile.load_calib_file(params, key_hc, filename=hclinefile,
                          userinputkey='HCLINEFILE', **lkwargs)
    # get properties from calibration file
    hclinefile = cfile.filename
    # construct new infile instance
    hclfile = out_wave_fp.newcopy(filename=hclinefile, params=params,
                                  fiber=usefiber)
    # read data/header
    hclfile.read_file()
    # get wave map
    hclines = hclfile.get_data(copy=True)
    # set wave source of wave file
    hcsource = hclfile.filename
    # ------------------------------------------------------------------------
    # get fp lines
    # ------------------------------------------------------------------------
    # load the fp lines calib file
    cfile = gen_calib.CalibFile()
    cfile.load_calib_file(params, key_fp, filename=fplinefile,
                          userinputkey='FPLINEFILE', **lkwargs)
    # get properties from calibration file
    fplinefile = cfile.filename
    # construct new infile instance
    fplfile = out_wave_fp.newcopy(filename=fplinefile, params=params,
                                  fiber=usefiber)
    # read data/header
    fplfile.read_file()
    # get wave map
    fplines = fplfile.get_data(copy=True)
    # set wave source of wave file
    fpsource = fplfile.filename
    # ------------------------------------------------------------------------
    # return the lines and sources
    return hclines, hcsource, fplines, fpsource


def check_wave_consistency(params: ParamDict, props: ParamDict,
                           num_coeffs: Union[int, None] = None) -> ParamDict:
    """
    Check the consistency of the wave solution (fit degree) and if incorrect
    convert wave solution coefficients to this degree for use after this point

    :param params: ParamDict, the parameter dictionary of constants
    :param props: ParamDict, the parameter dictionary of wave data
    :param num_coeffs: int or None, if set overrides params['WAVE_FIT_DEGREE']

    :return: ParamDict, the updated parameter dictionary of wave data
    """
    func_name = display_func('check_wave_consistency', __NAME__)
    # get constants from params/kwargs
    required_deg = pcheck(params, 'WAVE_FIT_DEGREE', func=func_name,
                          override=num_coeffs)
    # get dimension from data
    nbo, ncoeffs = props['COEFFS'].shape
    # get the fit degree from dimensions
    deg = ncoeffs - 1
    # check dimensions
    if required_deg == deg:
        # log that fit degrees match
        WLOG(params, '', textentry('40-017-00002', args=[deg]))
    # if not correct remap coefficients
    else:
        # log that fit degrees don't match
        wargs = [deg, required_deg]
        WLOG(params, 'warning', textentry('10-017-00003', args=wargs),
             sublevel=2)
        # setup output storage
        output_coeffs = np.zeros([nbo, required_deg + 1])
        output_map = np.zeros_like(props['WAVEMAP'])
        # define pixel array
        xfit = np.arange(output_map.shape[1])
        # loop around each order
        for order_num in range(nbo):
            # get the wave map for this order
            yfit = np.polyval(props['COEFFS'][order_num][::-1], xfit)
            # get the new coefficients based on a fit to this wavemap
            coeffs = mp.nanpolyfit(xfit, yfit, required_deg)[::-1]
            # push into storage
            output_coeffs[order_num] = coeffs
            output_map[order_num] = yfit
        # update props
        props['WAVEMAP'] = output_map
        props['COEFFS'] = output_coeffs
        props['DEG'] = required_deg
        props.set_sources(['WAVEMAP', 'COEFFS', 'DEG'], func_name)
    # return props
    return props


# =============================================================================
# Define line functions
# =============================================================================
def calc_wave_lines(params: ParamDict, recipe: DrsRecipe,
                    e2dsfile: DrsFitsFile, wavemap: np.array,
                    cavity_poly: Union[np.ndarray, None] = None,
                    hclines: Union[Table, None] = None,
                    fplines: Union[Table, None] = None,
                    iteration: Union[str, int, None] = None):
    # set the function name
    func_name = display_func('get_master_lines', __NAME__)
    # -------------------------------------------------------------------------
    # get parameters from params and kwargs
    # -------------------------------------------------------------------------
    # # Define the initial value of FP effective cavity width 2xd in nm
    # guess_cavity_width = pcheck(params, 'WAVE_GUESS_CAVITY_WIDTH',
    #                             func=func_name)
    # # Define the cavity fit polynomial fit degree for wave solution
    # cavity_fit_degree = pcheck(params, 'WAVE_CAVITY_FIT_DEGREE',
    #                            func=func_name)
    # min SNR to consider the line
    nsig_min_hc = pcheck(params, 'WAVEREF_NSIG_MIN_HC', func=func_name)
    nsig_min_fp = pcheck(params, 'WAVEREF_NSIG_MIN_FP', func=func_name)
    # minimum distance to the edge of the array to consider a line
    wmax = pcheck(params, 'WAVEREF_EDGE_WMAX', func=func_name)
    # value in pixel (+/-) for the box size around each HC line to perform fit
    hcboxsize = pcheck(params, 'WAVEREF_HC_BOXSIZE', func=func_name)
    # get valid hc dprtypes (string list separated by commas)
    hcfibtypes = pcheck(params, 'WAVEREF_HC_FIBTYPES', 'hcfibtypes',
                        func=func_name, mapf='list', dtype=str)
    # get valid fp dprtypes (string list separated by commas)
    fpfibtypes = pcheck(params, 'WAVEREF_FP_FIBTYPES', 'fpfibtypes',
                        func=func_name, mapf='list', dtype=str)
    # get the degree to fix master wavelength to in hc mode
    fitdeg = pcheck(params, 'WAVEREF_FITDEG', 'fitdeg', func=func_name)
    # define the lowest N for fp peaks
    fp_nlow = pcheck(params, 'WAVEREF_FP_NLOW', 'fp_nlow', func=func_name)
    # define the highest N for fp peaks
    fp_nhigh = pcheck(params, 'WAVEREF_FP_NHIGH', 'fp_nhigh', func=func_name)
    # define the number of iterations required to do the FP polynomial inversion
    fp_inv_itr = pcheck(params, 'WAVEREF_FP_POLYINV', 'fp_inv_itr',
                        func=func_name)
    # define the guess HC exponetial width [pixels]
    guess_hc_ewid = pcheck(params, 'WAVEREF_HC_GUESS_EWID', func=func_name)
    # define orders not to fit
    remove_orders = pcheck(params, 'WAVE_REMOVE_ORDERS', func=func_name,
                           mapf='list', dtype=int)
    # ------------------------------------------------------------------
    # get psuedo constants
    pconst = constants.pload(params['INSTRUMENT'])
    # get the shape from the wavemap
    nbo, nbpix = wavemap.shape
    # get dprtype
    dprtype = e2dsfile.get_hkey('KW_DPRTYPE', dtype=str)
    # get fiber type
    fiber = e2dsfile.get_hkey('KW_FIBER', dtype=str)
    # get fiber type
    fibtype = pconst.FIBER_DPR_POS(dprtype, fiber)
    # set up the xpixels
    xpix = np.arange(nbpix)
    # deal with no iteration number
    if iteration is None:
        str_itr = 0
    else:
        str_itr = str(iteration)
    # ----------------------------------------------------------------------
    # get the lines for HC files from hclines input
    # ----------------------------------------------------------------------
    if hclines is not None:
        # print progress Running get ref lines for HC
        WLOG(params, 'info', textentry('40-017-00061', args=[str_itr]))
        # get lines
        list_waves = hclines['WAVE_REF']
        list_orders = hclines['ORDER']
        list_pixels = hclines['PIXEL_REF']
        list_wfit = hclines['WFIT']
        peak_number = hclines['PEAK_NUMBER']
    # ----------------------------------------------------------------------
    # get the lines for HC files from fplines input
    # ----------------------------------------------------------------------
    elif fplines is not None:
        # print progress Running get ref lines for HC
        WLOG(params, 'info', textentry('40-017-00062', args=[str_itr]))
        # get lines
        list_waves = fplines['WAVE_REF']
        list_orders = fplines['ORDER']
        list_pixels = fplines['PIXEL_REF']
        list_wfit = fplines['WFIT']
        peak_number = fplines['PEAK_NUMBER']
    # ----------------------------------------------------------------------
    # get the lines for HC files
    # ----------------------------------------------------------------------
    elif fibtype in hcfibtypes:
        # print progress Running get ref lines for HC
        WLOG(params, 'info', textentry('40-017-00049', args=[str_itr]))
        # load the line list
        wavell, ampll = drs_data.load_linelist(params)
        # storage for outputs
        list_waves, list_orders, list_pixels = [], [], []
        # loop around orders and get the lines that fall within each
        #    diffraction order
        for order_num in range(nbo):
            # do not add lines lines from remove lines
            if order_num in remove_orders:
                continue
            # we have a wavelength value, we get an approximate pixel
            # value by fitting wavelength to pixel
            owave = wavemap[order_num]
            # we find lines within the order
            good = (wavell > np.min(owave)) & (wavell < np.max(owave))
            # we check that there is at least 1 line and append our line list
            if np.sum(good) != 0:
                # fit wave --> pix
                with warnings.catch_warnings(record=True) as _:
                    fit_reverse = np.polyfit(owave, xpix, fitdeg)
                # get the pixels positions based on out owave fit
                pixfit = np.polyval(fit_reverse, wavell[good])
                # append lists
                list_waves += list(wavell[good])
                list_orders += list(np.repeat(order_num, np.sum(good)))
                list_pixels += list(pixfit)
        # make line lists np arrays
        list_waves = np.array(list_waves)
        list_orders = np.array(list_orders)
        list_pixels = np.array(list_pixels)
        # keep lines that are  not too close to image edge
        keep = (list_pixels > wmax) & (list_pixels < (nbpix - wmax))
        # apply to list arrays
        list_waves = list_waves[keep]
        list_orders = list_orders[keep]
        list_pixels = list_pixels[keep]
        # set wfit to a constant for HC
        list_wfit = np.repeat(hcboxsize, len(list_pixels))

        # just for the sake of consistency, we need to attribute a fractional
        # FP cavity number to HC peaks. This ensures that the table saved at
        # then end of this code has the same format as for FPs.
        peak_number = np.repeat(np.nan, len(list_pixels))
    # ----------------------------------------------------------------------
    # get the lines for FP files
    # ----------------------------------------------------------------------
    elif fibtype in fpfibtypes:
        # print progress Running get ref lines for FP
        WLOG(params, 'info', textentry('40-017-00050', args=[str_itr]))
        # ------------------------------------------------------------------
        # deal with getting cavity poly
        if cavity_poly is not None:
            cavity_length_poly = np.array(cavity_poly)
        else:
            # load the first guess cavity polynomial from file
            _, fit_ll = drs_data.load_cavity_files(params)
            cavity_length_poly = fit_ll * 2
        # ------------------------------------------------------------------
        # range of the N FP peaks
        nth_peak = np.arange(fp_nlow, fp_nhigh)
        # storage for the wavelength centers
        wave0 = np.ones_like(nth_peak, dtype=float)
        # start the wave inversion of the polynomial at a sensible value
        wave0 = wave0 * np.nanmean(wavemap)
        # need a few iterations to invert polynomial relations
        for _ in range(fp_inv_itr):
            wave0 = np.polyval(cavity_length_poly, wave0) / nth_peak
        # keep lines within the master_wavelength domain
        keep = (wave0 > np.min(wavemap)) & (wave0 < np.max(wavemap))
        wave0 = wave0[keep]
        # nth_peak = nth_peak[keep]
        # sort by wavelength
        sortmask = np.argsort(wave0)
        wave0 = wave0[sortmask]
        # nth_peak = nth_peak[sortmask]
        # storage for outputs
        list_waves, list_orders, list_pixels, list_wfit = [], [], [], []
        # loop around orders and get the lines that fall within each
        #    diffraction order
        for order_num in range(nbo):
            # do not add lines lines from remove lines
            if order_num in remove_orders:
                continue
            # we have a wavelength value, we get an approximate pixel
            # value by fitting wavelength to pixel
            owave = wavemap[order_num]
            # we find lines within the order
            good = (wave0 > np.min(owave)) & (wave0 < np.max(owave))
            # we check that there is at least 1 line and append our line list
            if np.sum(good) != 0:
                # spline fit wave --> pix
                with warnings.catch_warnings(record=True) as _:
                    # fit_reverse = np.polyfit(owave, xpix, fitdeg)

                    ord_owave = np.argsort(owave)
                    spline_fit_reverse = mp.iuv_spline(owave[ord_owave],
                                                       xpix[ord_owave])
                # get the pixels positions based on out owave fit
                # pixfit = np.polyval(fit_reverse, wave0[good])
                pixfit = spline_fit_reverse(wave0[good])
                # get the dpix coeffs
                dpixc = np.polyfit(pixfit[1:], pixfit[1:] - pixfit[:-1], 2)
                # use this to get the rounded width?
                wfit = np.ceil(np.polyval(dpixc, pixfit))
                # append to the lists
                list_waves += list(wave0[good])
                list_orders += list(np.repeat(order_num, np.sum(good)))
                list_pixels += list(pixfit)
                list_wfit += list(wfit)
        # make line lists np arrays
        list_waves = np.array(list_waves)
        list_orders = np.array(list_orders)
        list_pixels = np.array(list_pixels)
        list_wfit = np.array(list_wfit, dtype=int)
        # keep lines that are  not too close to image edge
        keep = (list_pixels > wmax) & (list_pixels < (nbpix - wmax))
        # apply to list arrays
        list_waves = list_waves[keep]
        list_orders = list_orders[keep]
        list_pixels = list_pixels[keep]
        list_wfit = list_wfit[keep]

        # Once we have a cavity length, we find the integer FP peak number.
        # This will be compiled in the table later and used for nightly
        # wavelength solutions by changing the achromatic part of the cavity
        # length relative to the master observation directory. By construction,
        # this is always an integer.
        cavfit = np.polyval(cavity_length_poly, list_waves)
        peak_number = np.round(cavfit / list_waves, 0).astype(int)
    # ----------------------------------------------------------------------
    # else we break
    # ----------------------------------------------------------------------
    else:
        # log error and break
        eargs = [e2dsfile.name, dprtype, fiber, func_name, hcfibtypes,
                 fpfibtypes]
        WLOG(params, 'error', textentry('00-017-00012', args=eargs))
        list_waves = []
        list_orders = []
        list_pixels = []
        list_wfit = []
        peak_number = []
    # ----------------------------------------------------------------------
    # Fit the peaks
    # ----------------------------------------------------------------------
    # set up storage
    pixel_m = np.array(list_pixels)
    wave_m = np.zeros_like(list_waves)
    ewidth = np.zeros_like(list_pixels)
    amp = np.zeros_like(list_pixels)
    nsig = np.repeat(np.nan, len(list_pixels))
    # ----------------------------------------------------------------------
    # TODO: this loop is super slow
    # loop around orders
    for order_num in range(nbo):
        # get the order spectrum
        sorder = e2dsfile.data[order_num]
        # find all lines in this order
        good = np.where(list_orders == order_num)[0]
        # get order lines
        order_waves = list_waves[good]
        order_pixels = list_pixels[good]
        order_wfit = list_wfit[good]
        # we have a wavelength value, we get an approximate pixel
        # value by fitting wavelength to pixel
        owave = wavemap[order_num]
        # ------------------------------------------------------------------
        # loop around lines
        valid_lines = 0
        for it in range(len(order_waves)):
            # get the x pixel position
            xpixi = int(np.round(order_pixels[it]))
            # get the width
            wfit = int(np.round(order_wfit[it]))
            # get the pixels within this peak
            index = np.arange(xpixi - wfit, xpixi + wfit + 1)
            # Need to check that index is in bounds
            if (np.min(index) < 0) or (np.max(index) >= nbpix):
                eargs = [order_num, it, index, xpixi, wfit, func_name]
                WLOG(params, 'debug', textentry('09-017-00005', args=eargs))
                continue
            # get the flux value in this peak
            ypix = sorder[index]
            # deal with less points than fit (shouldn't happen but worth
            #    catching before an exception happens in fit_gauss_with_slope)
            if len(ypix) < 5:
                eargs = [order_num, it, index, ypix, func_name]
                WLOG(params, 'warning', textentry('09-017-00006', args=eargs),
                     sublevel=4)
                continue
            # --------------------------------------------------------------
            # only continue if we have all finite values
            if np.all(np.isfinite(ypix)):
                # try fitting a gaussian with a slope
                try:
                    # get ypix max and min
                    posmax = mp.nanargmax(ypix)
                    posmin = mp.nanargmin(ypix)
                    ymax, ymin = ypix[posmax], ypix[posmin]
                    # xcen = index[posmax]
                    xcen = order_pixels[it]

                    # if HC fit a gaussian with a slope
                    if fibtype in hcfibtypes:
                        # get up a gauss fit guess
                        #   [amplitude, mean position, FWHM, DC, slope]
                        guess = [ymax - ymin, xcen, guess_hc_ewid, ymin, 0]
                        out = mp.fit_gauss_with_slope(index, ypix, guess, True)
                        # get parameters from fit
                        popt, pcov, model = out
                        # get width condition
                        cond2 = (popt[2] < 2 * guess_hc_ewid)
                        cond2 &= (popt[2] > 0.5 * guess_hc_ewid)
                    # else fit ea airy function to FP
                    else:
                        out = velocity.fit_fp_peaks(index, ypix, wfit,
                                                    return_model=True)
                        # get parameters from fit
                        p0, popt, pcov, warns, model = out
                        # force popt[0] to positive
                        popt[0] = abs(popt[0])
                        # get width condition
                        cond2 = np.abs(popt[2] / wfit - 1) < 0.5
                    # calculate the RMS of the fit
                    rms = mp.nanstd(ypix - model)
                    # if we find 'good' values add to storage
                    cond1 = np.abs(popt[1] - xpixi) < wfit
                    if cond1 and cond2:
                        amp[good[it]] = popt[0]
                        pixel_m[good[it]] = popt[1]
                        # fit to get the measured wavelength for the center
                        #   of our FP peak
                        midpoint = int(popt[1])
                        wcoeffs = np.polyfit([midpoint, midpoint+1],
                                             owave[[midpoint, midpoint+1]], 1)
                        wave_m[good[it]] = np.polyval(wcoeffs, popt[1])
                        ewidth[good[it]] = popt[2]
                        nsig[good[it]] = np.abs(popt[0]) / rms
                        # line is valid
                        valid_lines += 1
                # ignore any bad lines
                except RuntimeError:
                    pass
        # log that we skippec an order
        if order_num in remove_orders:
            # log we are skipping order: Skipped Order {0}
            WLOG(params, '', textentry('40-017-00063', args=[order_num]))
        else:
            # log progress: Order {0}/{1} Fiber {2} Valid lines: {3}/{4}
            eargs = [order_num, nbo - 1, fiber, valid_lines, len(order_waves),
                     fibtype]
            WLOG(params, '', textentry('40-017-00051', args=eargs))
    # get SNR minimum value depending on fiber type
    if fibtype in hcfibtypes:
        nsig_min = int(nsig_min_hc)
    else:
        nsig_min = int(nsig_min_fp)
    # lines that are not at a high enough SNR are flagged as NaN
    # we do NOT remove these lines as we want all tables to have
    # exactly the same length
    with warnings.catch_warnings(record=True) as _:
        bad = ~(nsig > nsig_min)
    # apply bad mask to arrays (set bad to NaN)
    nsig[bad] = np.nan
    ewidth[bad] = np.nan
    amp[bad] = np.nan
    pixel_m[bad] = np.nan
    wave_m[bad] = np.nan
    # calculate the difference
    diffpix = pixel_m - list_pixels
    # ----------------------------------------------------------------------
    # Plot the expected lines vs measured line positions
    # ----------------------------------------------------------------------
    # debug plot expected lines vs measured positions
    recipe.plot('WAVEREF_EXPECTED', orders=list_orders, wavemap=list_waves,
                diff=diffpix, fiber=fiber, nbo=nbo, fibtype=fibtype,
                iteration=iteration)

    # # TODO: move to plotting recipe or remove?
    # if fibtype in fpfibtypes:
    #     if recipe.plot.plotoption == 2:
    #         import matplotlib.pyplot as plt
    #         fig, frames = plt.subplots(ncols=1, nrows=2)
    #         frames[0].plot(list_waves, peak_number * (list_waves - wave_m), 'k.')
    #         frames[1].plot(list_waves, peak_number * list_waves)
    #         frames[1].plot(list_waves, peak_number * wave_m, 'g.')
    #         frames[1].set(title='Iteration = {0}'.format(iteration))
    #         plt.show()
    #         plt.close()
    # ----------------------------------------------------------------------
    # Create table to store them in
    # ----------------------------------------------------------------------
    columnnames = ['WAVE_REF', 'WAVE_MEAS', 'PIXEL_REF', 'PIXEL_MEAS',
                   'ORDER', 'WFIT', 'EWIDTH_MEAS', 'AMP_MEAS', 'NSIG',
                   'DIFF', 'PEAK_NUMBER']
    columnvalues = [list_waves, wave_m, list_pixels, pixel_m, list_orders,
                    list_wfit, ewidth, amp, nsig, diffpix, peak_number]
    # make table
    table = drs_table.make_table(params, columnnames, columnvalues)
    # return table
    return table


def hc_wave_sol_offset(params: ParamDict, inwavemap: np.ndarray,
                       hclines: Table) -> np.ndarray:
    """
    Use the HCLINES "DIFF" column to work out an offset in the input wavemap
    and shift the input wavemap to try to estimate the correction of this

    default wave map might be off by too many pixels therefore we
    calculate a global offset and re-calculate

    :param params: ParamDict, parameter dictionary of constants
    :param inwavemap: np.ndarray, the input wave map
    :param hclines: astropy.table.Table, the hclines table

    :return: np.ndarray, the updated wavemap
    """
    # We measure gradient of the wave map so we can get the scaling
    #   factor of the wave map
    fchange = np.gradient(inwavemap, axis=1) / inwavemap
    opart1 = np.nanmedian(fchange)
    # get the bulk offset in lines (in pixel space)
    opart2 = np.nanmedian(hclines['DIFF'])
    # fractional offset of wavelengths (re-expressed as a scaling)
    offset = opart1 * opart2
    # print offset added: Appling global fraction offset of wavemap
    margs = [1 - offset]
    WLOG(params, '', textentry('40-017-00064', args=margs))
    # update the initial wave map
    wavemap = inwavemap * (1 - offset)
    # return offset wavemap
    return wavemap


def calc_wave_sol(params: ParamDict, recipe: DrsRecipe,
                  hclines: Table, fplines: Table, nbo: int,
                  nbxpix: int, fit_cavity: bool = True,
                  fit_achromatic: bool = True,
                  cavity_update: Union[np.ndarray, None] = None,
                  wavesol_fit_degree: Union[int, None] = None,
                  cavity_fit_degree: Union[int, None] = None,
                  nsig_cut: Union[float, None] = None,
                  iteration: Union[str, int, None] = None):
    """
    Calculate the wave solution using a table of hclines and fplines

    each lines table (hclines and fplines) must contain the following columns:
        - WAVE_REF - the line catalogue reference wavelength
        - WAVE_MEAS - the measured line wavelength (can be empty)
        - PIXEL_MEAS - the measured pixel position
        - ORDER - the order each line belongs to
        - NSIG - the uncertainty on the line measurement
        - PEAK_NUMBER - the peak number (blank for HC)

    Original Author: Etienne Artigau

    Master + AB
        fit cavity = True
        fit achromatic = False

    Master A, B, C
        fit cavity = False
        fit achromatic = False

    Night AB
        fit cavity = True
        fit achromatic = True

    Night A, B, C
        fit cavity = False
        fit achromatic = True

    :param params: ParamDict, parameter dictionary of constants
    :param recipe: DrsRecipe instance, the recipe that called this function
    :param hclines: Table, HC line table (see above description)
    :param fplines: Table, FP line table (see above description)
    :param nbo: int, the number of orders (from the e2ds image)
    :param nbxpix: int, the number of pixels in the along-order direction
    :param fit_cavity: bool, if True fits cavity width
    :param fit_achromatic: bool, if True fits achromatic part of cavity
    :param cavity_update: np.array or None - if sets the cavity file
    :param wavesol_fit_degree: int, the polynomial degree fit order for the
                               wave solution fit
    :param cavity_fit_degree: int, the polynomial degree fit order for the
                              cavity fit
    :param nsig_cut: int, the number of sigmas to cut in the robust polyfits
    :param iteration: int or str, the iteration number

    :return: ParamDict, the wave properties
    """
    # set function name
    func_name = display_func('calc_wave_sol', __NAME__)
    # log progress
    msg = 'Calculating wave solution. Iteration {0}'
    margs = [iteration]
    WLOG(params, 'info', msg.format(*margs))
    # -------------------------------------------------------------------------
    # get parameters from params / inputs
    # -------------------------------------------------------------------------
    # Define the wave solution polynomial fit degree
    wavesol_fit_degree = pcheck(params, 'WAVE_WAVESOL_FIT_DEGREE',
                                func=func_name, override=wavesol_fit_degree)
    # Define the cavity fit polynomial fit degree for wave solution
    cavity_fit_degree = pcheck(params, 'WAVE_CAVITY_FIT_DEGREE',
                               func=func_name, override=cavity_fit_degree)
    # Define the number of sigmas to use in wave sol robust fits
    nsig_cut = pcheck(params, 'WAVE_NSIG_CUT', func=func_name,
                      override=nsig_cut)
    # Define the minimum number of HC lines in an order to try to find
    #   absolute numbering
    min_hc_lines = pcheck(params, 'WAVE_MIN_HC_LINES', func=func_name)
    # Define the minimum number of FP lines in an order to try to find
    #   absolute numbering
    min_fp_lines = pcheck(params, 'WAVE_MIN_FP_LINES', func=func_name)
    # Define the maximum offset in FP peaks to explore when FP peak counting
    max_fp_c_offset = pcheck(params, 'WAVE_MAX_FP_COUNT_OFFSET', func=func_name)
    # Define the number of iterations required to converge the FP peak counting
    #   offset loop
    fp_count_offset_iterations = pcheck(params, 'WAVE_FP_COUNT_OFFSET_ITRS',
                                        func=func_name)
    # Define the number of iterations required to converge on a cavity fit
    #  (first time this is done)
    cavity_fit_iterations1 = pcheck(params, 'WAVE_CAVITY_FIT_ITRS1',
                                    func=func_name)
    # Define the required precision that the cavity width change must converge
    #   to (will be a fraction of the error)
    cavity_change_err_thres = pcheck(params, 'WAVE_CAVITY_CHANGE_ERR_THRES',
                                     func=func_name)
    # Define the number of iterations required to converge on a cavity fit
    #  (second time this is done)
    cavity_fit_iterations2 = pcheck(params, 'WAVE_CAVITY_FIT_ITRS2',
                                    func=func_name)
    # Define the odd ratio that is used in generating the weighted mean
    odd_ratio = pcheck(params, 'WAVE_HC_VEL_ODD_RATIO', func=func_name)
    # define orders not to fit
    remove_orders = pcheck(params, 'WAVE_REMOVE_ORDERS', func=func_name,
                           mapf='list', dtype=int)
    # -------------------------------------------------------------------------
    # setup parameters
    # -------------------------------------------------------------------------
    # order list
    orders = np.arange(nbo)
    # -------------------------------------------------------------------------
    # only keep pixels that have finite positions
    # it is fine to have orders with no valid lines
    hclines = hclines[np.isfinite(hclines['PIXEL_MEAS'])]
    fplines = fplines[np.isfinite(fplines['PIXEL_MEAS'])]
    # -------------------------------------------------------------------------
    # to get started, we assume that we do not know the wavelength of FP lines
    fplines['WAVE_MEAS'] = np.repeat(np.nan, len(fplines))

    # copy out of table (for consistence) - only update the table at the end
    fpl_order = np.array(fplines['ORDER'])
    fpl_wave_meas = np.array(fplines['WAVE_MEAS'])
    fpl_pix_meas = np.array(fplines['PIXEL_MEAS'])
    fpl_peak_num = np.array(fplines['PEAK_NUMBER'])
    fpl_wave_ref = np.array(fplines['WAVE_REF'])

    hcl_order = np.array(hclines['ORDER'])
    hcl_wave_meas = np.array(hclines['WAVE_MEAS'])
    hcl_pix_meas = np.array(hclines['PIXEL_MEAS'])
    hcl_wave_ref = np.array(hclines['WAVE_REF'])
    hcl_nsig = np.array(hclines['NSIG'])

    # -------------------------------------------------------------------------
    # Part 1: We do not know the wavelength of FP lines --> measure it for
    #         all FP lines (using the HC lines if there are enough)
    # -------------------------------------------------------------------------
    # loop around orders
    for order_num in orders:
        # log that we are processing an order
        WLOG(params, '', textentry('40-017-00056', args=[order_num]))
        # find the hc and fp lines for the current oder
        good_fp = fpl_order == order_num
        good_hc = hcl_order == order_num
        # skip bad orders
        if np.sum(good_fp) < min_fp_lines:
            # log that we are skipping order: Skipped Order {0}
            #     (too few {1} lines {2} < {3})'
            margs = [order_num, 'FP', np.sum(good_fp), min_fp_lines]
            WLOG(params, '', textentry('40-017-00065', args=margs))
            continue
        # skip orders flagged for removal
        if order_num in remove_orders:
            # log skipping order: Skipped Order {0} (in removed orders)'
            margs = [order_num]
            WLOG(params, '', textentry('40-017-00066', args=margs))
            continue
        # get the fplines for this order
        ordfp_pix_meas = fpl_pix_meas[good_fp]
        ordfp_peak_num = fpl_peak_num[good_fp]
        # mask the hclines
        ordhc_pix_meas = hcl_pix_meas[good_hc]
        ordhc_wave_ref = hcl_wave_ref[good_hc]
        # ---------------------------------------------------------------------
        # express step in pixels as a polynomial fit. This is used to count
        # fp peaks afterward
        xfit1 = ordfp_pix_meas[1:]
        yfit1 = ordfp_pix_meas[1:] - ordfp_pix_meas[:-1]
        # fit the step between FP lines
        fit_step, _ = mp.robust_polyfit(xfit1, yfit1, wavesol_fit_degree,
                                        nsig_cut)
        # ---------------------------------------------------------------------
        # counting steps backward
        # maybe first step is wrong, we'll see later by x-matching with HC lines
        # after this step, we know that lines within the order have
        # *relative* numbers that are ok
        for step_fp in range(1, len(ordfp_pix_meas)):
            # find expected step between previous and current FP peak
            # We start numbering at 1 as the 0th serves as a relative
            # starting point
            diff = ordfp_pix_meas[step_fp] - ordfp_pix_meas[step_fp - 1]
            dfit = np.polyval(fit_step, ordfp_pix_meas[step_fp - 1])
            dnum = diff / dfit
            # dnum is always very close to an integer value, we round it
            # we subtract the steps, FP peaks go in decreasing number
            rdnum = np.round(dnum)
            ordfp_peak_num[step_fp] = ordfp_peak_num[step_fp - 1] - rdnum
        # ---------------------------------------------------------------------
        # if we don't have more than "min_hc_lines" hc lines, we store the
        #   new values and skip to next order
        # ---------------------------------------------------------------------
        if np.sum(good_hc) <= min_hc_lines:
            # put into the table
            fpl_pix_meas[good_fp] = ordfp_pix_meas
            fpl_peak_num[good_fp] = ordfp_peak_num
            # log skipping orders: Skipped Order {0} (too few {1} lines)
            margs = [order_num, 'HC', np.sum(good_hc), min_hc_lines]
            WLOG(params, '', textentry('40-017-00065', args=margs))
            # skip to next order
            continue
        # ---------------------------------------------------------------------
        # if we have more than "min_hc_lines" hc lines, we try to find
        #     the absolute numbering
        # ---------------------------------------------------------------------
        # we fit an approximate wavelength solution
        with warnings.catch_warnings(record=True) as _:
            hc_wave_fit, _ = mp.robust_polyfit(ordhc_pix_meas, ordhc_wave_ref,
                                               wavesol_fit_degree, nsig_cut)
        # we find the steps in FP lines at the position of all HC lines
        step_hc = np.polyval(fit_step, ordhc_pix_meas)
        # get the derivative of the wave fit
        d_hc_wave_fit = np.polyder(hc_wave_fit)
        # get the step in waves
        step_hc_wave = np.polyval(d_hc_wave_fit, ordhc_pix_meas) * step_hc
        # -----------------------------------------------------------------
        # convert step in cavity through the order. We assume a constant
        #    cavity through the order
        cavity_per_order = mp.nanmedian(ordhc_wave_ref ** 2 / step_hc_wave)
        # copy this
        cavity_per_order0 = float(cavity_per_order)
        # -----------------------------------------------------------------
        # we explore integer offset in FP peak counting and find the
        #     offset that defines the wavelength solution leading to the
        #     smallest RMS between predicted and catalog HC peak positions
        offset = np.arange(-max_fp_c_offset, max_fp_c_offset + 1)
        # set up storage of sigmas
        osigmas = np.zeros_like(offset, dtype=float)
        # loop around offsets
        for o_it in range(len(offset)):
            # reset the cavity per order
            cavity_per_order = np.array(cavity_per_order0)
            # get the peak number offset
            peak_num_offset = ordfp_peak_num + offset[o_it]
            # get a temporary wave sol
            wave_tmp = cavity_per_order / peak_num_offset
            # fit this wave solution for FP lines
            ofpwave_fit = np.polyfit(ordfp_pix_meas, wave_tmp,
                                     wavesol_fit_degree)
            # -----------------------------------------------------------------
            # loop iteratively to converge cavity per order
            for _ in range(fp_count_offset_iterations):
                # get a temporary wave sol
                wave_tmp = cavity_per_order / peak_num_offset
                # fit this wave solution for FP lines
                ofpwave_fit = np.polyfit(ordfp_pix_meas, wave_tmp,
                                         wavesol_fit_degree)
                # fit the inverse for the hc lines
                ohcwave_fit = np.polyval(ofpwave_fit, ordhc_pix_meas)
                # work out the median of the residuals to the fit for the
                #   hc lines
                med_hc_res = mp.nanmedian(1 - ordhc_wave_ref / ohcwave_fit)
                # update the cavity per order by 1 - the median of the res
                cavity_per_order = cavity_per_order * (1 - med_hc_res)
            # -----------------------------------------------------------------
            # if the inverse for the hc lines once more
            ohcwave_fit = np.polyval(ofpwave_fit, ordhc_pix_meas)
            # calculate the hc residuals
            hc_res = 1 - ordhc_wave_ref / ohcwave_fit
            # calculate the offset sigma for this offset (and express as
            #   velocity)
            osigma = mp.estimate_sigma(hc_res * speed_of_light_ms, 1.0)
            # store in osgimas
            osigmas[o_it] = osigma
        # ---------------------------------------------------------------------
        # we apply the offset that leads to the smallest HC (o-c) RMS
        ordfp_peak_num = ordfp_peak_num + offset[np.argmin(osigmas)]
        # get a temporary wave sol
        wave_tmp = cavity_per_order / ordfp_peak_num
        # ---------------------------------------------------------------------
        # we find the best cavity length estimate
        for _ in range(cavity_fit_iterations1):
            # we force the cavity length to lead to a median HC peak position
            # error of zero.
            # we could use a better sigma-clipping, but this is hard with a
            # small number of lines
            # -----------------------------------------------------------------
            # get a temporary wave sol
            wave_tmp = cavity_per_order / ordfp_peak_num
            # fit this wave solution
            wave_fit = np.polyfit(ordfp_pix_meas, wave_tmp, wavesol_fit_degree)
            # inverse this fit using the HC lines
            ohcwave_fit = np.polyval(wave_fit, ordhc_pix_meas)
            # work out the residuals
            med_hc_res = mp.nanmedian(1 - ordhc_wave_ref / ohcwave_fit)
            # update the cavity per order by 1 - the median of the res
            cavity_per_order = cavity_per_order * (1 - med_hc_res)
        # ---------------------------------------------------------------------
        # we now have a best-guess of the wavelength solution, we update
        #  the WAVE_MEAS in the FP line list. This will be used to constrain the
        # cavity length below
        wave_fit = np.polyfit(ordfp_pix_meas, wave_tmp, wavesol_fit_degree)
        # re-fit wave solution on all lines --> measured wave sol
        ordfp_wave_meas = np.polyval(wave_fit, ordfp_pix_meas)
        # ---------------------------------------------------------------------
        # put into the table. If we had enough HC lines, the WAVE_MEAS has
        #    been updated if not, at least the FP peak counting is valid.
        fpl_pix_meas[good_fp] = ordfp_pix_meas
        fpl_peak_num[good_fp] = ordfp_peak_num
        fpl_wave_meas[good_fp] = ordfp_wave_meas
    # -------------------------------------------------------------------------
    # save some information for plotting later
    fp_peak_num_1 = np.array(fpl_peak_num)
    fp_wave_meas_1 = np.array(fpl_wave_meas)
    fp_wave_ref_1 = np.array(fpl_wave_ref)

    # -------------------------------------------------------------------------
    # Loop 2: Find offsets
    # -------------------------------------------------------------------------
    # find all non-NaN files
    good = np.where(np.isfinite(fpl_wave_meas))[0]

    # loop around each line (apart from the last)
    for line_it in range(len(good) - 1):
        # find expected next PEAK_NUM considering next WAVE_MEAS
        # if it differs from actual next value, offset all value after this
        # point to have a discontinuity
        wavepeak_it = fpl_wave_meas[good][line_it] * fpl_peak_num[good][line_it]
        wavepeak_it = wavepeak_it / fpl_wave_meas[good][line_it + 1]
        # distance to next peak
        peakdist = np.round(wavepeak_it) - fpl_peak_num[good][line_it + 1]
        # deal with an undefined peak distances
        if not np.isfinite(peakdist):
            continue
        # make distance an integer (nearest pixel)
        peakdist = int(peakdist)
        # if there is no change in distances continue
        if peakdist == 0:
            continue
        # else add the distance to all future peaks
        fpl_peak_num[good[line_it + 1]:] += peakdist
    # -------------------------------------------------------------------------
    # find the bulk offset that leads to a minimisation of the STDDEV of the
    #    cavity length through domain
    bulk_offset = [0]
    rms = [np.nanstd(fpl_wave_meas * fpl_peak_num)]
    # keep track of which way we are going
    sign = 1
    # start a counter to make sure our while loop doesn't go on forever
    count = 0
    # loop around until the rms is zero
    while (np.argmin(rms) == 0) or (np.argmin(rms) == (len(rms) - 1)):
        if sign == 1:
            new_bulk = np.nanmax(np.abs(bulk_offset)) + 1
        else:
            new_bulk = -np.nanmax(np.abs(bulk_offset))
        bulk_offset = np.append(bulk_offset, new_bulk)
        # calculate the new rms
        new_rms = np.nanstd(fpl_wave_meas * (new_bulk + fpl_peak_num))
        rms = np.append(rms, new_rms)
        # flip the sign
        sign *= -1
        # sort the bulk offsets in order
        offsetsort = np.argsort(bulk_offset)
        # sort the bulk offsets from smallest to largest
        bulk_offset = bulk_offset[offsetsort]
        # also sort the rms
        rms = list(np.array(rms)[offsetsort])
        # deal with too many iterations
        if count > mp.nanmin(fpl_peak_num):
            emsg = 'Too many iterations for bulk offset N={0}'
            eargs = [count]
            WLOG(params, 'error', emsg.format(*eargs))
        # add to count
        count += 1
    # update all peaks with current best offset
    fpl_peak_num += bulk_offset[np.argmin(rms)]
    # -------------------------------------------------------------------------
    # Find cavity width now peak offsets have been found
    # -------------------------------------------------------------------------
    # There are 3 scenarios:
    #  1. This is a master night AB, we do not want an achromatic fit and all
    #      coefficients should be fitted
    #  2. This is a non-master night AB, we must have an input (the master
    #      night solution) cavity and only the DC component (the achromatic
    #      term) will be adjusted
    #  3. We want to fit only the achromatic but don't provide a cavity.
    #     This is bad, we cannot change the achromatic term only if we don't
    #     have the chromatic terms. This produces and error

    if not fit_achromatic and fit_cavity:
        #  Scenario 1. This is a master night AB, we do not want an achromatic
        #              fit and all  coefficients should be fitted
        # now we have valid numbering and best-guess WAVE_MEAS, we find the
        #    cavity length
        wavepeak = fpl_wave_meas * fpl_peak_num
        cavity, _ = mp.robust_polyfit(fpl_wave_meas, wavepeak,
                                      cavity_fit_degree, nsig_cut)
        cavity = np.array(cavity)
    else:
        # if we have a cavity polynomial supplied as input use it here
        if cavity_update is not None:
            #  Scenario 2. This is a non-master night AB, we must have an
            #              input (the master night solution) cavity and only
            #              the DC component (the achromatic term) will be
            #              adjusted update the cavity array
            cavity = np.array(cavity_update)
        # else we cannot continue (this should not happen)
        else:
            #  Scenario 3. We want to fit only the achromatic but don't
            #              provide a cavity.  This is bad, we cannot change
            #              the achromatic term only if we don't have the
            #              chromatic terms. This produces and error
            # TODO: move to language database
            emsg = 'Cannot have fit_achromatic=True without cavity_update input'
            WLOG(params, 'error', emsg)
            cavity = None
    # -------------------------------------------------------------------------
    # copy the cavity fit
    cavity0 = np.array(cavity)
    # store these values for use later
    mean_hc_vel, err_hc_vel = np.nan, np.nan
    # set the mean2error to infinite
    mean2error = np.inf
    # set up diff_hc and hc sigma
    diff_hc = np.zeros_like(hcl_wave_meas)
    hcsigma = np.zeros_like(hcl_wave_meas)
    # -------------------------------------------------------------------------
    # we change the achromatic cavity length term to force HC peaks to have a
    #    zero velocity error.
    count = 0
    while mean2error > cavity_change_err_thres and count < 20:
        # get the proper cavity length from the cavity polynomial
        for _ in range(cavity_fit_iterations2):
            # update wave ref based on the fit
            fpl_wave_ref = np.polyval(cavity, fpl_wave_ref) / fpl_peak_num
        # ---------------------------------------------------------------------
        # get the wavelength solution for the order and the HC line position
        #     that it implies. The diff between the HC position found here and
        #     the catalog one is used to change the cavity length
        # ---------------------------------------------------------------------
        # loop around order
        for order_num in orders:
            # skip orders flagged for removal
            if order_num in remove_orders:
                continue
            # find the hc and fp lines for the current oder
            good_fp = fpl_order == order_num
            good_hc = hcl_order == order_num
            # get the fplines for this order
            ordfp_pix_meas = fpl_pix_meas[good_fp]
            ordfp_wave_ref = fpl_wave_ref[good_fp]
            # mask the hclines
            ordhc_pix_meas = hcl_pix_meas[good_hc]
            # get wave fit
            wave_fit, _ = mp.robust_polyfit(ordfp_pix_meas, ordfp_wave_ref,
                                            wavesol_fit_degree, nsig_cut)
            # update wave measure from this fit
            fpl_wave_meas[good_fp] = np.polyval(wave_fit, ordfp_pix_meas)
            # if we have some HC lines update these too
            if np.sum(good_hc) > 0:
                hcl_wave_meas[good_hc] = np.polyval(wave_fit, ordhc_pix_meas)
        # ---------------------------------------------------------------------
        # in velocity, diff between measured and catalog HC line positions
        res = hcl_wave_meas / hcl_wave_ref
        diff_hc = (1 - res) * speed_of_light_ms
        # model of the errors in the HC line positions. We assume that
        # they decrease as 1/NSIG
        hcsigma = mp.estimate_sigma(diff_hc * hcl_nsig) / hcl_nsig
        # get smart mean of the velocity error
        mean_hc_vel, err_hc_vel = mp.odd_ratio_mean(diff_hc, hcsigma,
                                                    odd_ratio=odd_ratio)
        # ---------------------------------------------------------------------
        # if we are allowed to change the achromatic cavity length, then
        #    we do it, else we just keep track of how much we would have
        #    changed it.
        if not fit_cavity:
            pass
        elif fit_achromatic:
            # recalculate mean to error ratio
            mean2error = np.abs(mean_hc_vel / err_hc_vel)
            # update last coefficient of the cavity fit
            cavity[-1] = cavity[-1] * (1 + mean_hc_vel / speed_of_light_ms)
        # else update the cavity
        else:
            # set mean2error to zero
            mean2error = 0.0
            # create a temporary value of cavity length at each wave point
            tmp_cavity = np.polyval(cavity, fpl_wave_ref)
            # fit cavity length to find a correction
            dv_cav = (1 + diff_hc / speed_of_light_ms)
            cav_corr, _ = mp.robust_polyfit(hcl_wave_meas, dv_cav,
                                            cavity_fit_degree, nsig_cut)
            # update the cavity length at all points by the cavity correction
            tmp_cavity *= np.polyval(cav_corr, fpl_wave_ref)
            # fit cavity length again with this new correction
            cavity = np.polyfit(fpl_wave_ref, tmp_cavity, cavity_fit_degree)
        # ---------------------------------------------------------------------
        # log message: Iteration {0}: Mean HC position {1:6.2f}+-{2:.2f} m/s'
        margs = [count + 1, mean_hc_vel, err_hc_vel]
        WLOG(params, '', textentry('40-017-00057', margs))
        # increase the count
        count += 1
    # -------------------------------------------------------------------------
    # log message: Change in cavity length {0:6.2f} nm'
    cavlen1 = np.polyval(cavity, fpl_wave_ref)
    cavlen0 = np.polyval(cavity0, fpl_wave_ref)
    margs = [mp.nanmean(cavlen1) - mp.nanmean(cavlen0)]
    WLOG(params, '', textentry('40-017-00058', args=margs))
    # -------------------------------------------------------------------------
    # save some information for plotting later
    fp_peak_num_2 = np.array(fpl_peak_num)
    fp_wave_meas_2 = np.array(fpl_wave_meas)
    fp_wave_ref_2 = np.array(fpl_wave_ref)
    # -------------------------------------------------------------------------
    # plot the wavelength vs cavity width plot
    recipe.plot('WAVE_WL_CAV', cavity=cavity, orders=fpl_order,
                fp_wave_meas1=fp_wave_meas_1, fp_peak_num_1=fp_peak_num_1,
                fp_wave_meas2=fp_wave_meas_2, fp_peak_num_2=fp_peak_num_2,
                fp_wave_ref_1=fp_wave_ref_1, fp_wave_ref_2=fp_wave_ref_2,
                iteration=iteration)
    # -------------------------------------------------------------------------
    # plot the wavelength hc diff histograms
    recipe.plot('WAVE_HC_DIFF_HIST', diff_hc=diff_hc, error=hcsigma,
                iteration=iteration)
    # -------------------------------------------------------------------------
    # update wave solution for fplines
    fpl_wave_ref = np.polyval(cavity, fpl_wave_ref) / fpl_peak_num
    # -------------------------------------------------------------------------
    # Construct the wavelength coefficients / wave map
    # -------------------------------------------------------------------------
    wave_coeffs = np.zeros([len(orders), wavesol_fit_degree + 1])
    # get xpix
    xpix = np.arange(nbxpix)
    # worko out the initial wave coefficients
    # loop around orders
    for order_num in orders:
        # do not add removed orders
        if order_num in remove_orders:
            wave_coeffs[order_num] = np.nan
            continue
        # get the fp lines for this order
        good_fp = fpl_order == order_num
        # get fpline vectors
        ordfp_pix_meas = fpl_pix_meas[good_fp]
        ordfp_wave_ref = fpl_wave_ref[good_fp]
        # fit the solution to this order
        with warnings.catch_warnings(record=True) as _:
            ord_wave_sol, _ = mp.robust_polyfit(ordfp_pix_meas, ordfp_wave_ref,
                                                wavesol_fit_degree, nsig_cut)
        # add to wave coefficients
        wave_coeffs[order_num] = ord_wave_sol[::-1]
    # -------------------------------------------------------------------------
    # deal with removed orders (insert them by using a consistency check)
    if len(remove_orders) > 0:
        # fit the wave coefficients across orders for consistency
        wave_coeffs_new = np.zeros_like(wave_coeffs)
        # loop around coefficients
        for icoeff in range(wavesol_fit_degree + 1):
            # fit along orders
            fitcoeffs, _ = mp.robust_polyfit(orders, wave_coeffs[:, icoeff],
                                             9, 10)
            # update wave coeffs for all values
            wave_coeffs_new[:, icoeff] = np.polyval(fitcoeffs, orders)
        # insert the values for "removed orders"
        wave_coeffs = np.array(wave_coeffs)
        for order_num in remove_orders:
            wave_coeffs[order_num] = np.array(wave_coeffs_new[order_num])
    # -------------------------------------------------------------------------
    # generate the wave map from the coefficients
    wave_map = np.zeros([len(orders), int(nbxpix)])
    # loop around orders
    for order_num in orders:
        # generate wave map for order
        wave_map[order_num] = np.polyval(wave_coeffs[order_num][::-1], xpix)
    # -------------------------------------------------------------------------
    # update the fplines and hclines tables
    fplines['WAVE_MEAS'] = fpl_wave_meas
    fplines['PIXEL_MEAS'] = fpl_pix_meas
    fplines['PEAK_NUMBER'] = fpl_peak_num
    fplines['WAVE_REF'] = fpl_wave_ref
    hclines['WAVE_MEAS'] = hcl_wave_meas
    hclines['PIXEL_MEAS'] = hcl_pix_meas
    hclines['WAVE_REF'] = hcl_wave_ref
    hclines['NSIG'] = hcl_nsig
    # -------------------------------------------------------------------------
    # construct wave properties
    # -------------------------------------------------------------------------
    wprops = ParamDict()
    wprops['COEFFS'] = wave_coeffs
    wprops['WAVEMAP'] = wave_map
    wprops['NBO'] = len(orders)
    wprops['DEG'] = wavesol_fit_degree
    wprops['NBPIX'] = nbxpix
    wprops['CAVITY'] = cavity
    wprops['CAVITY_DEG'] = cavity_fit_degree
    wprops['MEAN_HC_VEL'] = mean_hc_vel
    wprops['ERR_HC_VEL'] = err_hc_vel
    # set source
    keys = ['WAVEMAP', 'NBO', 'DEG', 'COEFFS', 'NBPIX', 'CAVITY', 'CAVITY_DEG',
            'MEAN_HC_VEL', 'ERR_HC_VEL']
    wprops.set_sources(keys, func_name)
    # return wave properties
    return wprops


def process_fibers(params: ParamDict, recipe: DrsRecipe,
                   mprops: ParamDict, fp_outputs: Dict[str, DrsFitsFile],
                   hc_outputs: Dict[str, DrsFitsFile], fit_cavity: bool,
                   fit_achromatic: bool) -> Dict[str, ParamDict]:
    """
    Process all fibers (skip for master)

    other fibers are calculated similarly to master fiber but with
        fit_cavity = False
        fit_achromatic = False

    :param params: ParamDict, parameter dictionary of constants
    :param recipe: DrsRecipe instance, the recipe calling this function
    :param mprops: ParamDict, the wave properties of the master file
    :param fp_outputs: Dict of fp file inputs (e2ds files) for each fiber
    :param hc_outputs: Dict of hc file inputs (e2ds files) for each fiber
    :param fit_cavity: bool, if True fits the cavity width
    :param fit_achromatic: bool, if True fits the achromaticity

    :return: Dict of wave properties (ParamDict) for each fiber
    """
    # set function name
    func_name = display_func('process_fibers', __NAME__)
    # set up storage
    solutions = dict()
    # get wave master file (controller fiber)
    master_fiber = pcheck(params, 'WAVE_MASTER_FIBER', func=func_name)
    plot_order = pcheck(params, 'WAVE_FIBER_COMP_PLOT_ORD', func=func_name)
    # get the cavity file
    cavity = mprops['CAVITY']
    # get the master fiber lines
    # mhcl = mprops['HCLINES']
    # mfpl = mprops['FPLINES']
    # get the fiber types from a list parameter (or from inputs)
    fiber_types = drs_image.get_fiber_types(params)
    # loop around fibers
    for fiber in fiber_types:
        # log that we are processing fiber
        wargs = [fiber, master_fiber]
        WLOG(params, 'info', textentry('40-017-00043', args=wargs))
        # get the e2ds_files for this fiber
        hc_e2ds_file = hc_outputs[fiber]
        fp_e2ds_file = fp_outputs[fiber]
        # read these files
        hc_e2ds_file.read_file()
        fp_e2ds_file.read_file()
        # ---------------------------------------------------------------------
        # skip all this if this is the master fiber (its all been done)
        if fiber == master_fiber:
            solutions[fiber] = mprops
            continue
        # ---------------------------------------------------------------------
        # generate the hc reference lines
        hcargs = dict(e2dsfile=hc_e2ds_file, wavemap=mprops['WAVEMAP'],
                      iteration='1 fiber {0}'.format(fiber))
        hclines = calc_wave_lines(params, recipe, **hcargs)
        # generate the fp reference lines
        fpargs = dict(e2dsfile=fp_e2ds_file, wavemap=mprops['WAVEMAP'],
                      cavity_poly=cavity, iteration='1 fiber {0}'.format(fiber))
        fplines = calc_wave_lines(params, recipe, **fpargs)
        # ---------------------------------------------------------------------
        # calculate wave solution
        wprops = calc_wave_sol(params, recipe, hclines, fplines,
                               nbo=hc_e2ds_file.shape[0],
                               nbxpix=hc_e2ds_file.shape[1],
                               fit_cavity=fit_cavity,
                               fit_achromatic=fit_achromatic,
                               cavity_update=cavity,
                               iteration='1 fiber {0}'.format(fiber))
        # ---------------------------------------------------------------------
        # regenerate the hc reference lines
        hcargs = dict(e2dsfile=hc_e2ds_file, wavemap=wprops['WAVEMAP'],
                      iteration='2 fiber {0}'.format(fiber))
        hclines = calc_wave_lines(params, recipe, **hcargs)
        # re generate the fp reference lines
        fpargs = dict(e2dsfile=fp_e2ds_file, wavemap=wprops['WAVEMAP'],
                      cavity_poly=cavity, iteration='2 fiber {0}'.format(fiber))
        fplines = calc_wave_lines(params, recipe, **fpargs)
        # add lines to wave properties
        wprops['HCLINES'] = hclines
        wprops['FPLINES'] = fplines
        # add wave time and file
        wprops['WAVETIME'] = fp_e2ds_file.get_hkey('MJDMID', dtype=float)
        wprops['WAVEFILE'] = 'None'
        wprops['WAVESOURCE'] = func_name
        # set sources
        skeys = ['HCLINES', 'FPLINES', 'WAVETIME', 'WAVEFILE']
        wprops.set_sources(skeys, func_name)
        # ---------------------------------------------------------------------
        # append wave properties to solutions storage
        solutions[fiber] = wprops
    # ----------------------------------------------------------------------
    # plot comparison between master fiber and fibers
    # ----------------------------------------------------------------------
    recipe.plot('WAVE_FIBER_COMPARISON', solutions=solutions, master=mprops,
                order=None, masterfiber=master_fiber)
    recipe.plot('WAVE_FIBER_COMP', solutions=solutions, master=mprops,
                order=plot_order, masterfiber=master_fiber)
    recipe.plot('SUM_WAVE_FIBER_COMP', solutions=solutions, master=mprops,
                order=plot_order, masterfiber=master_fiber)
    # ----------------------------------------------------------------------
    # return all the solutions for all fibers
    return solutions


def update_smart_fp_mask(params: ParamDict, cavity: np.ndarray, **kwargs):
    # set function name
    func_name = display_func('update_smart_fp_mask', __NAME__)
    # get constants from params
    update_mask = pcheck(params, 'WAVE_CCF_UPDATE_MASK', 'update_mask', kwargs,
                         func_name)
    assetdir = pcheck(params, 'DRS_DATA_ASSETS', 'assetsdir', kwargs, func_name)
    ccfpath = pcheck(params, 'WAVE_CCF_MASK_PATH', 'ccfpath', kwargs, func_name)
    ccfmask = pcheck(params, 'WAVE_CCF_MASK', 'ccfmask', kwargs, func_name)
    dvwidth = pcheck(params, 'WAVE_CCF_SMART_MASK_WIDTH', 'dvwidth',
                     kwargs, func_name)
    mask_units = pcheck(params, 'WAVE_CCF_MASK_UNITS', 'mask_units', kwargs,
                        func_name)
    minlambda = pcheck(params, 'WAVE_CCF_SMART_MASK_MINLAM', 'minlambda',
                       kwargs, func_name)
    maxlambda = pcheck(params, 'WAVE_CCF_SMART_MASK_MAXLAM', 'maxlambda',
                       kwargs, func_name)
    nmin = pcheck(params, 'WAVE_CCF_SMART_MASK_TRIAL_NMIN', 'nmin', kwargs,
                  func_name)
    nmax = pcheck(params, 'WAVE_CCF_SMART_MASK_TRIAL_NMAX', 'nmax', kwargs,
                  func_name)
    threshold = pcheck(params, 'WAVE_CCF_SMART_MASK_DWAVE_THRES', 'threshold',
                       kwargs, func_name)
    # if we don't want to update the mask then don't
    if not update_mask:
        return
    # ----------------------------------------------------------------------
    # construct output filename
    outfile = os.path.join(assetdir, ccfpath, ccfmask)
    # ----------------------------------------------------------------------
    # start with a broader range of FP N values and clip later on
    n_fp_fpeak = np.arange(nmin, nmax)
    # placeholder for wavelength, needs to be iterated-on with
    #    the cavity length polynomial
    # the starting wavelength is the midpoint between the extremities of
    #    the domain
    wave_fp_peak = np.repeat(np.mean([minlambda, maxlambda]), len(n_fp_fpeak))
    # ----------------------------------------------------------------------
    # we perform the following loop
    #
    # Take the wavelength and derive a cavity length
    # Take the Nth peak and derive a line wavelength from the
    # cavity length
    # Take the new wavelength and dereive a new cavity length
    # Find an update wavelength for the Nth peak
    #  .... converge down to a 'threshold' error in wavelength
    dwave = np.inf
    while abs(dwave) > threshold:
        # keep track of the central line to check convergence
        prev = wave_fp_peak[len(wave_fp_peak) // 2]
        # derive a new wavelength for each fp peak
        wave_fp_peak = np.polyval(cavity, wave_fp_peak) / n_fp_fpeak
        # check convergnce
        dwave = prev - wave_fp_peak[len(wave_fp_peak) // 2]
    # ----------------------------------------------------------------------
    # keep lines within the domain
    keep = (wave_fp_peak > minlambda) & (wave_fp_peak < maxlambda)
    # ----------------------------------------------------------------------
    # apply keep mask to wavelength solution and n peak
    wave_fp_peak = wave_fp_peak[keep]
    # ----------------------------------------------------------------------
    # get unit object from mask units string
    try:
        unit = getattr(uu, mask_units)
    except Exception as e:
        # log error
        eargs = [mask_units, type(e), e, func_name]
        WLOG(params, 'error', textentry('09-020-00002', args=eargs))
        return
    # add units
    wave_fp_peak = wave_fp_peak * unit
    # convert to nanometers
    wave_fp_peak = wave_fp_peak.to(uu.nm).value
    # ----------------------------------------------------------------------
    # calculate wavelength bounds of line
    wavelower = wave_fp_peak * (1 - 0.5 * dvwidth / speed_of_light)
    waveupper = wave_fp_peak * (1 + 0.5 * dvwidth / speed_of_light)
    weights = np.repeat(1.0, len(wavelower))
    # ----------------------------------------------------------------------
    # Create table to store them in
    # ----------------------------------------------------------------------
    columnnames = ['WLOW', 'WHIGH', 'WEIGHT']
    columnvalues = [wavelower, waveupper, weights]
    # make table
    table = drs_table.make_table(params, columnnames, columnvalues)
    # print that we are saving smart fp header
    WLOG(params, '', textentry('40-017-00053', args=outfile))
    # write smart mask table to file
    drs_table.write_table(params, table, outfile, fmt='ascii.fast_no_header')


def update_w_rv_props(wprops: ParamDict, rvprops: ParamDict,
                      source: Union[str, None] = None
                      ) -> Tuple[ParamDict, ParamDict]:
    """
    Update the wave parameter dictionary (wprops) and the rv parameter
    dictionary (rvprops) with the correct values

    wprops feeds into the output wave files
    rvprops feeds into the outpout ccf (RV) files

    :param wprops: ParamDict, the parameter dictionary of wave data
    :param rvprops: ParamDict, the parameter dictionary of CCF (RV) data
    :param source: str, the source for these constants (if None uses here)

    :return:
    """
    # set function name
    func_name = display_func('update_w_rv_props', __NAME__)
    # deal with no source
    if source is None:
        source = str(func_name)
    # set wave properties from ccf (rv) properties for wave outputs
    wprops['WFP_DRIFT'] = rvprops['MEAN_RV']
    wprops['WFP_FWHM'] = rvprops['MEAN_FWHM']
    wprops['WFP_CONTRAST'] = rvprops['MEAN_CONTRAST']
    wprops['WFP_MASK'] = rvprops['CCF_MASK']
    wprops['WFP_LINES'] = rvprops['TOT_LINE']
    wprops['WFP_TARG_RV'] = rvprops['TARGET_RV']
    wprops['WFP_WIDTH'] = rvprops['CCF_WIDTH']
    wprops['WFP_STEP'] = rvprops['CCF_STEP']
    wprops['WFP_FILE'] = wprops['WAVEFILE']
    # add the rv stats (push from wprops to rvprops) for ccf outputs
    rvprops['RV_WAVEFILE'] = wprops['WAVEFILE']
    rvprops['RV_WAVETIME'] = wprops['WAVETIME']
    rvprops['RV_WAVESRCE'] = wprops['WAVESOURCE']
    rvprops['RV_TIMEDIFF'] = 'None'
    rvprops['RV_WAVE_FP'] = rvprops['MEAN_RV']
    rvprops['RV_SIMU_FP'] = 'None'
    rvprops['RV_DRIFT'] = 'None'
    rvprops['RV_OBJ'] = 'None'
    rvprops['RV_CORR'] = 'None'
    # set sources
    rkeys = ['RV_WAVEFILE', 'RV_WAVETIME', 'RV_WAVESRCE', 'RV_TIMEDIFF',
             'RV_WAVE_FP', 'RV_SIMU_FP', 'RV_DRIFT', 'RV_OBJ',
             'RV_CORR']
    wkeys = ['WFP_DRIFT', 'WFP_FWHM', 'WFP_CONTRAST', 'WFP_MASK',
             'WFP_LINES', 'WFP_TARG_RV', 'WFP_WIDTH', 'WFP_STEP',
             'WFP_FILE']
    wprops.set_sources(wkeys, source)
    rvprops.set_sources(rkeys, source)
    # return wave props and rv props
    return wprops, rvprops


def update_extract_files(params, recipe, extract_file, wprops, extname,
                         fiber, calibdbm):
    # ----------------------------------------------------------------------
    # find the extraction recipe
    extrecipe, _ = drs_startup.find_recipe(extname, params['INSTRUMENT'],
                                           mod=recipe.recipemod)
    extrecipe.params = params
    # ----------------------------------------------------------------------
    # get input to extract file
    input_filename = extract_file.get_hkey('INF1000')
    input_file = extract_file.intype
    # ----------------------------------------------------------------------
    # make a new copy of infileexclude_group
    infile = input_file.newcopy(params=params)
    infile.set_filename(input_filename)
    # ----------------------------------------------------------------------
    # get extraction files
    e2ds_file = extrecipe.outputs['E2DS_FILE'].newcopy(params=params,
                                                       fiber=fiber)
    e2dsff_file = extrecipe.outputs['E2DSFF_FILE'].newcopy(params=params,
                                                           fiber=fiber)
    e2dsll_file = extrecipe.outputs['E2DSLL_FILE'].newcopy(params=params,
                                                           fiber=fiber)
    s1dw_file = extrecipe.outputs['S1D_W_FILE'].newcopy(params=params,
                                                        fiber=fiber)
    s1dv_file = extrecipe.outputs['S1D_V_FILE'].newcopy(params=params,
                                                        fiber=fiber)
    # ----------------------------------------------------------------------
    # construct filename
    e2ds_file.construct_filename(infile=infile)
    e2dsff_file.construct_filename(infile=infile)
    e2dsll_file.construct_filename(infile=infile)
    s1dw_file.construct_filename(infile=infile)
    s1dv_file.construct_filename(infile=infile)
    # ----------------------------------------------------------------------
    # log that we are updating the file with wave params
    wargs = [e2ds_file.name, e2ds_file.filename]
    WLOG(params, '', textentry('40-017-00038', args=wargs))
    # update the e2ds file
    e2ds_file.read_file()
    e2ds_file.read_header()
    e2ds_file = add_wave_keys(e2ds_file, wprops)
    e2ds_file.infiles = [infile.basename]
    # define multi lists
    data_list, name_list = [], []
    # snapshot of parameters
    if params['PARAMETER_SNAPSHOT']:
        data_list += [params.snapshot_table(recipe, drsfitsfile=e2ds_file)]
        name_list += ['PARAM_TABLE']
    # write file
    e2ds_file.write_multi(data_list=data_list, name_list=name_list,
                          block_kind=recipe.out_block_str,
                          runstring=recipe.runstring)
    # add to output files (for indexing)
    recipe.add_output_file(e2ds_file)
    # ----------------------------------------------------------------------
    # log that we are updating the file with wave params
    wargs = [e2dsff_file.name, e2dsff_file.filename]
    WLOG(params, '', textentry('40-017-00038', args=wargs))
    # update the e2ds file
    e2dsff_file.read_file()
    e2dsff_file = add_wave_keys(e2dsff_file, wprops)
    e2dsff_file.infiles = [infile.basename]
    # define multi lists
    data_list, name_list = [], []
    # snapshot of parameters
    if params['PARAMETER_SNAPSHOT']:
        data_list += [params.snapshot_table(recipe, drsfitsfile=e2dsff_file)]
        name_list += ['PARAM_TABLE']
    # write file
    e2dsff_file.write_multi(data_list=data_list, name_list=name_list,
                            block_kind=recipe.out_block_str,
                            runstring=recipe.runstring)
    # add to output files (for indexing)
    recipe.add_output_file(e2dsff_file)
    # ----------------------------------------------------------------------
    # log that we are updating the file with wave params
    wargs = [e2dsll_file.name, e2dsll_file.filename]
    WLOG(params, '', textentry('40-017-00038', args=wargs))
    # update the e2ds file
    e2dsll_file.read_multi()
    e2dsll_file = add_wave_keys(e2dsll_file, wprops)
    e2dsll_file.infiles = [infile.basename]
    # define multi lists
    data_list, name_list = e2dsll_file.data_array, e2dsll_file.name_array
    if data_list is None:
        data_list, name_list = [], []
    # snapshot of parameters
    if params['PARAMETER_SNAPSHOT']:
        data_list += [params.snapshot_table(recipe, drsfitsfile=e2dsll_file)]
        # there should be a param_table from extraction
        if 'PARAM_TABLE' in name_list:
            name_list += ['PARAM_UPDATE']
        else:
            name_list += ['PARAM_TABLE']
    # write file
    e2dsll_file.write_multi(data_list=data_list, name_list=name_list,
                            block_kind=recipe.out_block_str,
                            runstring=recipe.runstring)
    # add to output files (for indexing)
    recipe.add_output_file(e2dsll_file)
    # ----------------------------------------------------------------------
    # Need to re-calculate the s1d files
    # ----------------------------------------------------------------------
    # load the blaze file for this fiber
    bout = flat_blaze.get_blaze(params, e2dsff_file.get_header(), fiber,
                                database=calibdbm)
    blaze_file, blaze_time, blaze = bout
    # calculate s1d file
    sargs = [wprops['WAVEMAP'], e2dsff_file.get_data(), blaze]
    swprops = extract.e2ds_to_s1d(params, recipe, *sargs, wgrid='wave',
                                  fiber=fiber, s1dkind='E2DSFF')
    svprops = extract.e2ds_to_s1d(params, recipe, *sargs,
                                  wgrid='velocity', fiber=fiber,
                                  s1dkind='E2DSFF')
    # ----------------------------------------------------------------------
    # plot the s1d plot
    recipe.plot('EXTRACT_S1D', params=params, props=svprops,
                fiber=fiber, kind='E2DSFF')
    # ----------------------------------------------------------------------
    # Store S1D_W in file
    # ----------------------------------------------------------------------
    # copy header from e2dsll file
    s1dw_file.copy_header(e2ds_file)
    s1dw_file.copy_hdict(e2ds_file)
    # set output key
    s1dw_file.add_hkey('KW_OUTPUT', value=s1dw_file.name)
    # add new header keys
    s1dw_file = extract.add_s1d_keys(s1dw_file, swprops)
    s1dw_file.infiles = [infile.basename]
    # copy data
    s1dw_file.data = swprops['S1DTABLE']
    # must change the datatype to 'table'
    s1dw_file.datatype = 'table'
    # ----------------------------------------------------------------------
    # log that we are updating the file with wave params
    wargs = [s1dw_file.name, s1dw_file.filename]
    WLOG(params, '', textentry('40-017-00038', args=wargs))
    # define multi lists
    data_list, name_list = [], []
    # snapshot of parameters
    if params['PARAMETER_SNAPSHOT']:
        data_list += [params.snapshot_table(recipe, drsfitsfile=s1dw_file)]
        name_list += ['PARAM_TABLE']
    # write image to file
    s1dw_file.write_multi(data_list=data_list, name_list=name_list,
                          block_kind=recipe.out_block_str,
                          runstring=recipe.runstring)
    # add to output files (for indexing)
    recipe.add_output_file(s1dw_file)
    # ----------------------------------------------------------------------
    # Store S1D_W in file
    # ----------------------------------------------------------------------
    # copy header from e2dsll file
    s1dv_file.copy_header(e2ds_file)
    s1dv_file.copy_hdict(e2ds_file)
    # add new header keys
    s1dv_file = extract.add_s1d_keys(s1dv_file, svprops)
    s1dv_file.infiles = [infile.basename]
    # set output key
    s1dv_file.add_hkey('KW_OUTPUT', value=s1dv_file.name)
    # copy data
    s1dv_file.data = svprops['S1DTABLE']
    # must change the datatype to 'table'
    s1dv_file.datatype = 'table'
    # ----------------------------------------------------------------------
    # log that we are updating the file with wave params
    wargs = [s1dv_file.name, s1dv_file.filename]
    WLOG(params, '', textentry('40-017-00038', args=wargs))
    # define multi lists
    data_list, name_list = [], []
    # snapshot of parameters
    if params['PARAMETER_SNAPSHOT']:
        data_list += [params.snapshot_table(recipe, drsfitsfile=s1dv_file)]
        name_list += ['PARAM_TABLE']
    # write image to file
    s1dv_file.write_multi(data_list=data_list, name_list=name_list,
                          block_kind=recipe.out_block_str,
                          runstring=recipe.runstring)
    # add to output files (for indexing)
    recipe.add_output_file(s1dv_file)
    # return e2dsff file
    return e2dsff_file


def generate_resolution_map(params: ParamDict, recipe: DrsRecipe,
                            wprops: ParamDict, hc_e2ds_file: DrsFitsFile,
                            nbin_order: Union[int, None] = None,
                            nbin_spatial: Union[int, None] = None,
                            filtersize: Union[int, None] = None,
                            velo_cutoff1: Union[float, None] = None,
                            velo_cutoff2: Union[float, None] = None
                            ) -> ParamDict:

    # set the function name
    func_name = display_func('generate_resolution_map', __NAME__)
    # -------------------------------------------------------------------------
    # get parameters from parameter dictionary
    # -------------------------------------------------------------------------
    # get number of order bins
    n_order_bin = pcheck(params, 'WAVE_RES_MAP_ORDER_BINS', func=func_name,
                         override=nbin_order)
    # get number of spatial bins
    n_spatial_bin = pcheck(params, 'WAVE_RES_MAP_ORDER_BINS', func=func_name,
                           override=nbin_spatial)
    # get low pass filter for hc e2ds file
    filtersize = pcheck(params, 'WAVE_RES_MAP_FILTER_SIZE', func=func_name,
                        override=filtersize)
    # get the velocity cut off for keeping lines close to our reference line
    velocity_cutoff1 = pcheck(params, 'WAVE_RES_VELO_CUTOFF1', func=func_name,
                              override=velo_cutoff1)
    # get the tight velocity cut off for keeping lines close to our
    #     reference line
    velocity_cutoff2 = pcheck(params, 'WAVE_RES_VELO_CUTOFF2', func=func_name,
                              override=velo_cutoff2)
    # get the y limit for the res plot
    res_ylim = pcheck(params, 'WAVE_HC_RESMAP_YLIM', func=func_name,
                      mapf='list', dtype=float)
    # define the way we fit line profiles
    fitmode = pcheck(params, 'WAVE_HC_RESMAP_FITTYPE', func=func_name)

    # -------------------------------------------------------------------------
    # get parameters from wprops
    wavemap = wprops['WAVEMAP']
    hclines = wprops['HCLINES']
    hc_pix_ref = hclines['PIXEL_REF']
    hc_order = hclines['ORDER']
    hc_wave_ref = hclines['WAVE_REF']
    hc_nsig = hclines['NSIG']
    # get the HC E2DS file
    hc_e2ds = np.array(hc_e2ds_file.data)
    # -------------------------------------------------------------------------
    # get number of orders and number of pixels from wavemap
    nbo, nbpix = wavemap.shape
    # get bin sizes
    bin_spatial = nbpix / n_spatial_bin
    bin_order = nbo / n_order_bin
    # -------------------------------------------------------------------------
    # low pass the HC E2DS files
    for order_num in range(nbo):
        # calculate the low frequency signal from the HC E2DS
        lowpass = mp.lowpassfilter(hc_e2ds[order_num], filtersize)
        # remove the low pass signal from the HC E2DS
        hc_e2ds[order_num] = hc_e2ds[order_num] - lowpass
    # -------------------------------------------------------------------------
    # storage for plotting / outputs
    map_dvs, map_fluxes, map_fits = dict(), dict(), dict()
    map_waves, map_orders, map_res_eff = dict(), dict(), dict()
    map_fwhm, map_amp, map_expo = dict(), dict(), dict()
    map_lower_ords, map_high_ords = dict(), dict()
    map_lower_pix, map_high_pix = dict(), dict()
    # get all orders and pixels
    orders = np.arange(nbo)
    xpix = np.arange(nbpix)
    # -------------------------------------------------------------------------
    # loop over number of bins in order direction
    for i_order_bin in range(n_order_bin):
        # loop over number of bins in spatial direction
        for i_spatial_bin in range(n_spatial_bin):
            # key for this iteration (order bin + spatial bin)
            mapkey = (i_order_bin, i_spatial_bin)
            # calculate which lines are valid
            valid_lines = (hc_pix_ref // bin_spatial == i_spatial_bin)
            valid_lines &= (hc_order // bin_order == i_order_bin)
            # get valid orders and pixels
            valid_orders = (orders // bin_order == i_order_bin)
            valid_pixels = (xpix // bin_spatial == i_spatial_bin)
            # only keep the best 100 lines in "nsig" (SNR) - if we have more
            #   than 100 finite values for SNR
            valid_lines &= np.isfinite(hc_nsig)
            if np.sum(valid_lines) > 100:
                sigcut = -np.sort(-hc_nsig[valid_lines])[100]
                valid_lines &= hc_nsig > sigcut
            # get the minimum and maximum value for orders
            map_lower_ords[mapkey] = np.min(orders[valid_orders])
            map_high_ords[mapkey] = np.max(orders[valid_orders])
            # get the minimum and maximum value for pixels
            map_lower_pix[mapkey] = np.min(xpix[valid_pixels])
            map_high_pix[mapkey] = np.max(xpix[valid_pixels])
            # print which bin we are processing
            # Processing order bin {0} spectral bin {1} Number lines: {2}
            # Orders {3} to {4} Pixels {5} to {6}
            margs = [i_order_bin, i_spatial_bin, np.sum(valid_lines),
                     map_lower_ords[mapkey], map_high_ords[mapkey],
                     map_lower_pix[mapkey], map_high_pix[mapkey]]
            WLOG(params, '', textentry('40-017-00059', args=margs))
            # mask order and wave ref for this bin set
            hc_order_i = hc_order[valid_lines]
            hc_wave_ref_i = hc_wave_ref[valid_lines]
            # -----------------------------------------------------------------
            # calculate the velocities for all valid lines in this bin
            # -----------------------------------------------------------------
            # loop around each line and work out the velocity of this line
            all_dv, all_flux, all_wave, all_order = [], [], [], []
            for line_it in range(len(hc_order_i)):
                # get the ratio between our wave map for this order and
                # reference wavelength for this line
                dwave = wavemap[hc_order_i[line_it]] / hc_wave_ref_i[line_it]
                # convert this to a velocity difference
                dv = (dwave - 1) * speed_of_light
                # only keep velocities close to zero
                keep = np.abs(dv) < velocity_cutoff1
                # get the flux for all valid lines in this order in the dv range
                flux = np.array(hc_e2ds[hc_order_i[line_it]][keep])
                # one keep valid line dvs
                dv = dv[keep]
                wavekeep = wavemap[hc_order_i[line_it]][keep]
                orderkeep = np.full_like(wavekeep, hc_order_i[line_it])
                # get a new dv cutoff
                dvmask = np.abs(dv) < velocity_cutoff2
                # subtract off the median flux for these lines
                #  this normalizes the flux
                with warnings.catch_warnings(record=True) as _:
                    flux = flux - np.nanmedian(flux[~dvmask])
                    flux = flux / np.nansum(flux[dvmask])
                # append all lines left to storage
                all_dv += list(dv)
                all_flux += list(flux)
                all_wave += list(wavekeep)
                all_order += list(orderkeep)
            # -----------------------------------------------------------------
            # Fit the line profiles for this bin
            # -----------------------------------------------------------------
            if fitmode == 'super-gaussian':
                fout = res_fit_super_gauss(params, mapkey,
                                           i_order_bin, i_spatial_bin,
                                           valid_lines, all_dv,
                                           all_flux, all_wave, all_order,
                                           map_lower_ords, map_high_ords,
                                           map_lower_pix, map_high_pix)
                # get super gauss returns
                fwhm, amp, expo, res_eff, fluxfit2 = fout[:5]
                all_dv, all_flux, all_wave, all_order = fout[5:]
            else:
                fout = res_fit_gauss(params, mapkey, i_order_bin, i_spatial_bin,
                                     valid_lines, all_dv, all_flux, all_wave,
                                     all_order, map_lower_ords, map_high_ords,
                                     map_lower_pix, map_high_pix)
                # get gauss returns
                fwhm, amp, expo, res_eff, fluxfit2 = fout[:5]
                all_dv, all_flux, all_wave, all_order = fout[5:]
            # -----------------------------------------------------------------
            # log parameters: FWHM={0:.2f} km/s, effective resolution={1:.2f},
            #     expo={2:.2f}
            margs = [fwhm, expo, res_eff]
            WLOG(params, '', textentry('40-017-00060', margs))
            # storage for plotting
            map_dvs[mapkey] = np.array(all_dv)
            map_fluxes[mapkey] = np.array(all_flux)
            map_waves[mapkey] = np.array(all_wave)
            map_orders[mapkey] = np.array(all_order)
            map_fits[mapkey] = np.array(fluxfit2)
            map_fwhm[mapkey] = float(fwhm)
            map_expo[mapkey] = float(expo)
            map_amp[mapkey] = float(amp)
            map_res_eff[mapkey] = float(res_eff)
    # -------------------------------------------------------------------------
    # produce the large plot
    # -------------------------------------------------------------------------
    # get xlim based on all fwhm values
    maxfwhm = np.max(list(map_fwhm.values()))
    xlim = [-2 * maxfwhm, 2 * maxfwhm]
    # map line profile map
    recipe.plot('WAVE_RESMAP', params=params, n_order_bin=n_order_bin,
                n_spatial_bin=n_spatial_bin, map_dvs=map_dvs,
                map_fluxes=map_fluxes, map_fits=map_fits,
                map_res_eff=map_res_eff, map_lower_ords=map_lower_ords,
                map_high_ords=map_high_ords, map_lower_pix=map_lower_pix,
                map_high_pix=map_high_pix, xlim=xlim, ylim=res_ylim)
    # -------------------------------------------------------------------------
    # push to wprops
    wprops['RES_MAP_DVS'] = map_dvs
    wprops['RES_MAP_LINES'] = map_fluxes
    wprops['RES_MAP_WAVES'] = map_waves
    wprops['RES_MAP_ORDERS'] = map_orders
    wprops['RES_MAP_FITS'] = map_fits
    wprops['RES_MAP_LOW_ORD'] = map_lower_ords
    wprops['RES_MAP_HIGH_ORD'] = map_high_ords
    wprops['RES_MAP_LOW_PIX'] = map_lower_pix
    wprops['RES_MAP_HIGH_PIX'] = map_high_pix
    wprops['RES_MAP_FWHM'] = map_fwhm
    wprops['RES_MAP_EXPO'] = map_expo
    wprops['RES_MAP_AMP'] = map_amp
    wprops['RES_MAP_EFFRES'] = map_res_eff
    wprops['RES_MAP_NBIN_ORD'] = n_order_bin
    wprops['RES_MAP_NBIN_PIX'] = n_spatial_bin
    wprops['RES_NBO'] = nbo
    wprops['RES_NBPIX'] = nbpix
    # set source
    keys = ['RES_MAP_DVS', 'RES_MAP_LINES', 'RES_MAP_FITS', 'RES_MAP_LOW_ORD',
            'RES_MAP_HIGH_ORD', 'RES_MAP_LOW_PIX', 'RES_MAP_HIGH_PIX',
            'RES_MAP_FWHM', 'RES_MAP_EXPO', 'RES_MAP_AMP', 'RES_MAP_EFFRES',
            'RES_MAP_NBIN_ORD', 'RES_MAP_NBIN_PIX']
    wprops.set_sources(keys, func_name)
    # -------------------------------------------------------------------------
    # return updated wprops
    return wprops


def res_fit_super_gauss(params: ParamDict, mapkey: Tuple[int, int],
                        i_order_bin: int, i_spatial_bin: int,
                        valid_lines: np.ndarray, all_dv: List[float],
                        all_flux: List[float], all_wave: List[float],
                        all_order: List[float],
                        map_lower_ords: dict, map_high_ords: dict,
                        map_lower_pix: dict, map_high_pix: dict):
    # set function name
    func_name = display_func('res_fit_super_gauss', __NAME__)
    # -----------------------------------------------------------------
    # get sigma clip
    sigclipthres = pcheck(params, 'WAVE_HC_RESMAP_SIGCLIP', func=func_name)
    # -----------------------------------------------------------------
    # prepare all dvs and flux for fitting
    # -----------------------------------------------------------------
    # initial guess: fwhm, amp, expo
    guess = [3.5, 0.5, 2.0]
    # sort dvs and fluxes by dvs
    sort = np.argsort(all_dv)
    all_dv, all_flux = np.array(all_dv)[sort], np.array(all_flux)[sort]
    all_wave = np.array(all_wave)[sort]
    all_order = np.array(all_order)[sort]
    # mask values to only keep good values (flux is normalize)
    mask = (all_flux > -0.1) & (all_flux < 1.0)
    mask &= np.isfinite(all_flux)
    # apply mask to dv and flux
    all_dv, all_flux = all_dv[mask], all_flux[mask]
    all_wave, all_order = all_wave[mask], all_order[mask]
    # -----------------------------------------------------------------
    # fit the dvs
    # -----------------------------------------------------------------
    try:
        # attempt a first fit on the flux
        cargs = [mp.centered_super_gauss, all_dv, all_flux]
        with warnings.catch_warnings(record=True) as _:
            pcoeffs1, _ = curve_fit(*cargs, p0=guess)
        # calculate the residuals between flux and fit
        fluxfit1 = mp.centered_super_gauss(all_dv, *pcoeffs1)
        residuals = all_flux - fluxfit1
        # sigma clip the residuals
        sigclip = np.abs(residuals) < sigclipthres
        # update the all_dv and all_flux vectors
        all_dv, all_flux = all_dv[sigclip], all_flux[sigclip]
        all_wave, all_order = all_wave[sigclip], all_order[sigclip]
        # re-fit based on sigma clipped vectors
        cargs = [mp.centered_super_gauss, all_dv, all_flux]
        with warnings.catch_warnings(record=True) as _:
            pcoeffs2, _ = curve_fit(*cargs, p0=guess)
        # calculate fit
        fluxfit2 = mp.centered_super_gauss(all_dv, *pcoeffs2)
        # calculate resolution
        fwhm, amp, expo = pcoeffs2
        res_eff = speed_of_light / fwhm
    except ValueError as e:
        # set values to NaN
        fwhm, amp, expo, res_eff = np.nan, np.nan, np.nan, np.nan
        fluxfit2 = np.full_like(all_dv, np.nan)
        # Fit failed for order bin {0} spectral bin {1}
        wargs = [i_order_bin, i_spatial_bin, np.sum(valid_lines),
                 map_lower_ords[mapkey], map_high_ords[mapkey],
                 map_lower_pix[mapkey], map_high_pix[mapkey],
                 type(e), str(e)]
        WLOG(params, 'warning', textentry('10-017-00013', wargs),
             sublevel=4)
    except RuntimeError as e:
        # set values to NaN
        fwhm, amp, expo, res_eff = np.nan, np.nan, np.nan, np.nan
        fluxfit2 = np.full_like(all_dv, np.nan)
        # Fit failed for order bin {0} spectral bin {1}
        wargs = [i_order_bin, i_spatial_bin, np.sum(valid_lines),
                 map_lower_ords[mapkey], map_high_ords[mapkey],
                 map_lower_pix[mapkey], map_high_pix[mapkey],
                 type(e), str(e)]
        WLOG(params, 'warning', textentry('10-017-00013', wargs),
             sublevel=4)
    # return outputs
    fout = [fwhm, amp, expo, res_eff, fluxfit2, all_dv, all_flux,
            all_wave, all_order]
    return fout


def res_fit_gauss(params: ParamDict, mapkey: Tuple[int, int],
                  i_order_bin: int, i_spatial_bin: int,
                  valid_lines: np.ndarray, all_dv: List[float],
                  all_flux: List[float], all_wave: List[float],
                  all_order: List[float],
                  map_lower_ords: dict, map_high_ords: dict,
                  map_lower_pix: dict, map_high_pix: dict):
    # set function name
    func_name = display_func('res_fit_gauss', __NAME__)
    # -----------------------------------------------------------------
    # get sigma clip
    sigclipthres = pcheck(params, 'WAVE_HC_RESMAP_SIGCLIP', func=func_name)
    # -----------------------------------------------------------------
    # prepare all dvs and flux for fitting
    # -----------------------------------------------------------------
    # sort dvs and fluxes by dvs
    sort = np.argsort(all_dv)
    all_dv, all_flux = np.array(all_dv)[sort], np.array(all_flux)[sort]
    all_wave = np.array(all_wave)[sort]
    all_order = np.array(all_order)[sort]
    # mask values to only keep good values (flux is normalize)
    mask = (all_flux > -0.1) & (all_flux < 1.0)
    mask &= np.isfinite(all_flux)
    # apply mask to dv and flux
    all_dv, all_flux = all_dv[mask], all_flux[mask]
    all_wave, all_order = all_wave[mask], all_order[mask]
    # initial guess: amp, position, sigma, dc]
    guess = [0.5, 0.0, 3.5, 0.0]
    # -----------------------------------------------------------------
    # fit the dvs
    # -----------------------------------------------------------------
    try:
        # attempt a first fit on the flux
        cargs = [mp.gauss_function, all_dv, all_flux]
        with warnings.catch_warnings(record=True) as _:
            pcoeffs1, _ = curve_fit(*cargs, p0=guess)
        # calculate the residuals between flux and fit
        fluxfit1 = mp.gauss_function(all_dv, *pcoeffs1)
        residuals = all_flux - fluxfit1
        # sigma clip the residuals
        sigclip = np.abs(residuals) < sigclipthres
        # update the all_dv and all_flux vectors
        all_dv, all_flux = all_dv[sigclip], all_flux[sigclip]
        all_wave, all_order = all_wave[sigclip], all_order[sigclip]
        # re-fit based on sigma clipped vectors
        cargs = [mp.gauss_function, all_dv, all_flux]
        with warnings.catch_warnings(record=True) as _:
            pcoeffs2, _ = curve_fit(*cargs, p0=guess)
        # calculate fit
        fluxfit2 = mp.gauss_function(all_dv, *pcoeffs2)
        # calculate resolution
        amp, _, sigma, _ = pcoeffs2
        fwhm = sigma * np.sqrt(2 * np.log(2)) * 2
        res_eff = speed_of_light / fwhm
    except ValueError as e:
        # set values to NaN
        fwhm, amp, expo, res_eff = np.nan, np.nan, np.nan, np.nan
        fluxfit2 = np.full_like(all_dv, np.nan)
        # Fit failed for order bin {0} spectral bin {1}
        wargs = [i_order_bin, i_spatial_bin, np.sum(valid_lines),
                 map_lower_ords[mapkey], map_high_ords[mapkey],
                 map_lower_pix[mapkey], map_high_pix[mapkey],
                 type(e), str(e)]
        WLOG(params, 'warning', textentry('10-017-00013', wargs),
             sublevel=4)
    except RuntimeError as e:
        # set values to NaN
        fwhm, amp, expo, res_eff = np.nan, np.nan, np.nan, np.nan
        fluxfit2 = np.full_like(all_dv, np.nan)
        # Fit failed for order bin {0} spectral bin {1}
        wargs = [i_order_bin, i_spatial_bin, np.sum(valid_lines),
                 map_lower_ords[mapkey], map_high_ords[mapkey],
                 map_lower_pix[mapkey], map_high_pix[mapkey],
                 type(e), str(e)]
        WLOG(params, 'warning', textentry('10-017-00013', wargs),
             sublevel=4)
    # return outputs
    fout = [fwhm, amp, 2.0, res_eff, fluxfit2, all_dv, all_flux,
            all_wave, all_order]

    return fout


def get_echelle_orders(params: ParamDict, wprops: ParamDict) -> ParamDict:
    """
    Get the Echelle orders for a wave map

    :param params: ParamDict, the parameter dictionary of constants
    :param wprops: ParamDict, the wave properties parameter dictionary

    :return: ParamDict, the updated wprops
    """
    # set function name
    func_name = display_func('get_echelle_orders', __NAME__)
    # -------------------------------------------------------------------------
    # get wave map from wprops
    wavemap = wprops['WAVEMAP']
    # get the central wavelength of each order
    central_waveval = wavemap[:, wavemap.shape[1] // 2]
    # -------------------------------------------------------------------------
    # echelle orders lambda / delta lambda
    echelle_orders = (central_waveval[1:] / np.diff(central_waveval)) - 1
    # are slightly off integers due to non-perfect wave solution
    echelle_orders = np.round(echelle_orders).astype(int)
    # correction for "weird" orders
    sign = np.median(np.sign(np.gradient(echelle_orders)))
    # get the deviation
    dev = sign * np.arange(len(echelle_orders))
    # recalculate the echelle orders using the median (assuming most orders
    #   are good)
    echelle_orders = np.median(echelle_orders - dev) + dev
    # are slightly off integers due to non-perfect wave solution
    echelle_orders = np.round(echelle_orders).astype(int)
    # -------------------------------------------------------------------------
    # need to add the first order
    diff = np.mean(np.diff(echelle_orders))
    echelle_orders = np.append(echelle_orders[0] - diff, echelle_orders)
    # are slightly off integers due to non-perfect wave solution
    echelle_orders = np.round(echelle_orders).astype(int)
    # -------------------------------------------------------------------------
    # sanity check that we have the correct number of orders
    if len(echelle_orders) != wavemap.shape[0]:
        # log error:  Number of Echelle orders (={0}) must be the same as
        #             number of orders (={1}) \n\t Function = {2}
        eargs = [len(echelle_orders), wavemap.shape[0], func_name]
        WLOG(params, 'error', textentry('00-017-00013', args=eargs))
    # -------------------------------------------------------------------------
    # add back to wprops
    wprops['EORDERS'] = echelle_orders.astype(int)
    wprops.set_source('EORDERS', func_name)
    return wprops


def wave_meas_diff(params: ParamDict, master_fiber: str,
                   wprops_all: Dict[str, ParamDict],
                   rvs_all: Dict[str, ParamDict]) -> Dict[str, ParamDict]:
    """
    Work out the difference in wave measured as a dv (in m/s)

    :param params:
    :param master_fiber:
    :param wprops_all:
    :param rvs_all:
    :return:
    """
    # set function name
    func_name = display_func('wave_meas_diff', __NAME__)
    # set for consistency
    ref_wmeas, ref_peakn, ref_orders = [], [], []
    # loop around each fiber
    for fiber in rvs_all:
        # choose which wprops to use
        wprops = wprops_all[fiber]
        # deal with master fiber
        if fiber == master_fiber:
            # get wave meas for fplines
            ref_wmeas = np.array(wprops['FPLINES']['WAVE_MEAS'])
            ref_peakn = np.array(wprops['FPLINES']['PEAK_NUMBER'])
            ref_orders = np.array(wprops['FPLINES']['ORDER'])
            # dv of master fiber is zero by definition
            wm_dv = 0.0
        else:
            # get wave meas for fplines
            wmeas = np.array(wprops['FPLINES']['WAVE_MEAS'])
            peakn = np.array(wprops['FPLINES']['PEAK_NUMBER'])
            orders = np.array(wprops['FPLINES']['ORDER'])
            # -----------------------------------------------------------------
            # deal with matching lines
            #    assumes 1. they are sorted by peakn 2. there are no duplicates
            mask1, mask2 = match_fplines(ref_orders, ref_peakn, orders, peakn)
            # -----------------------------------------------------------------
            # get dv for wave meas between master fiber and this fiber
            wratio = np.nanmedian(ref_wmeas[mask1] / wmeas[mask2])
            # wave meas dv in m/s
            wm_dv = (1 - wratio) * speed_of_light_ms
            # -----------------------------------------------------------------
            # print dv measurement: DV({0} - {1}): {2:.3f} m/s'
            margs = [master_fiber, fiber, wm_dv]
            WLOG(params, 'info', textentry('40-017-00067', args=margs))
        # ---------------------------------------------------------------------
        # add to rv props
        rvs_all[fiber].set('WM_DV', value=wm_dv, source=func_name)
    # return all rv props
    return rvs_all


def match_fplines(orders1: np.ndarray, peakn1: np.ndarray,
                  orders2: np.ndarray, peakn2: np.ndarray
                  ) -> Tuple[np.ndarray, np.ndarray]:
    """
    Match two sets of peak numbers based on the peak numbers in two fibers

    :param orders1: np.ndarray - which order each fp line belongs to in fiber 1
    :param peakn1: np.ndarray - the peak number of each fp line in fiber 1
    :param orders2: np.ndarray - which order each fp line belongs to in fiber 2
    :param peakn2: np.ndarray - the peak number of each fp line in fiber 2

    :return: tuple, 1. the
    """
    mask1 = []
    mask2 = []
    # this has to be done per order to avoid matching between orders
    for order_num in set(orders1):
        # get the masks for each set of orders
        order_mask1 = order_num == orders1
        order_mask2 = order_num == orders2
        # get the peak numbering for this order
        opeakn1 = peakn1[order_mask1]
        opeakn2 = peakn2[order_mask2]
        # get the minimum length of two lists
        minlen = np.min([len(opeakn1), len(opeakn2)])
        # work out the offset beween the two lists
        offset = int(np.median(opeakn1[:minlen] - opeakn2[:minlen]))
        # if offset is negative list 2 needs offsetting
        if offset < 0:
            indices1 = np.arange(minlen + offset)
            indices2 = indices1 - offset
        # if offset is positive list 1 needs offsetting
        elif offset > 0:
            indices2 = np.arange(minlen - offset)
            indices1 = indices2 + offset
        # if offset is zero nothing needs offsetting
        else:
            indices1, indices2 = np.arange(minlen), np.arange(minlen)
        # add to the two masks we are returning
        mask1 += list(indices1)
        mask2 += list(indices2)
    # return masks as numpy arrays
    return np.array(mask1), np.array(mask2)


# =============================================================================
# Define writing functions
# =============================================================================
def wave_quality_control(params: ParamDict, solutions: Dict[str, ParamDict],
                         rvprops: Dict[str, ParamDict]) -> List[list]:
    """
    Quality control for the wave solutions (all fibers)

    :param params: ParamDict, parameter dictionary of constants
    :param solutions: list of ParamDicts, wave properties for each fiber
    :param rvprops: list of ParamDicts, rv properties for each fiber

    :return: list of lists - the quality control lists (qc_names,
             qc_values, qc_logic, qc_pass)
    """
    # set function name
    func_name = display_func('wave_quality_control', __NAME__)
    # get parameters from params / inputs
    master_fiber = pcheck(params, 'WAVE_MASTER_FIBER', func=func_name)
    rv_thres = pcheck(params, 'WAVE_CCF_RV_THRES_QC', func=func_name)
    # get the fiber types from a list parameter (or from inputs)
    fiber_types = drs_image.get_fiber_types(params)
    # --------------------------------------------------------------
    # set passed variable and fail message list
    fail_msg = []
    qc_names, qc_values, qc_logic, qc_pass = [], [], [], []
    # --------------------------------------------------------------
    # check the difference between consecutive orders is always positive
    # get the differences
    # --------------------------------------------------------------
    # loop around fibers
    for fiber in fiber_types:
        wprops = solutions[fiber]
        # --------------------------------------------------------------------
        # y-direction (across orders)
        # --------------------------------------------------------------------
        # get wave difference
        wave_diff = wprops['WAVEMAP'][1:] - wprops['WAVEMAP'][:-1]
        if mp.nanmin(wave_diff) < 0:
            fail_msg.append(textentry('40-017-00030'))
            qc_pass.append(0)
        else:
            qc_pass.append(1)
        # add to qc header lists
        qc_values.append(mp.nanmin(wave_diff))
        qc_names.append('MIN YWAVE DIFF {0}'.format(fiber))
        qc_logic.append('MIN YWAVE DIFF {0} < 0'.format(fiber))
        # --------------------------------------------------------------------
        # x-direction (along orders)
        # --------------------------------------------------------------------
        # get wave difference
        wave_diff = wprops['WAVEMAP'][:, 1:] - wprops['WAVEMAP'][:, :-1]
        if mp.nanmin(wave_diff) < 0:
            fail_msg.append(textentry('40-017-00055'))
            qc_pass.append(0)
        else:
            qc_pass.append(1)
        # add to qc header lists
        qc_values.append(mp.nanmin(wave_diff))
        qc_names.append('MIN XWAVE DIFF {0}'.format(fiber))
        qc_logic.append('MIN XWAVE DIFF {0} < 0'.format(fiber))

    # --------------------------------------------------------------
    # rv quality controls between fibers from fplines file
    # --------------------------------------------------------------
    for fiber in fiber_types:
        # do not compare master to master
        if fiber == master_fiber:
            continue
        # get wave measured rv difference in wave meas
        rvdiff = rvprops[fiber]['WM_DV']
        # add to qc header lists
        qc_values.append(rvdiff)
        qc_names.append('DV[{0} - {1}]'.format(master_fiber, fiber))
        qargs = [master_fiber, fiber, rv_thres]
        qc_logic.append('abs(DV[{0} - {1}]) > {2} m/s'.format(*qargs))
        # deal with rv threshold
        if np.abs(rvdiff) > rv_thres:
            qc_pass.append(0)
            fail_msg.append('abs(DV[{0} - {1}]) > {2} m/s'.format(*qargs))
        else:
            qc_pass.append(1)

    # --------------------------------------------------------------
    # rv quality controls between fibers (from ccf)
    # --------------------------------------------------------------
    # get master RV [km/s] --> [m/s]
    master_rvs = rvprops[master_fiber]['CCF_FIT_COEFFS'][:, 1] * 1000

    # get the fiber types from a list parameter (or from inputs)
    fiber_types = drs_image.get_fiber_types(params)
    # loop around fibers
    for fiber in fiber_types:
        # do not compare master to master
        if fiber == master_fiber:
            continue
        # get rv for this fiber [km/s] --> [m/s]
        fiber_rvs = rvprops[fiber]['CCF_FIT_COEFFS'][:, 1] * 1000
        # get the differences for each order
        rvdiff = master_rvs - fiber_rvs
        # get the median difference
        meddiff = np.nanmedian(rvdiff)
        # deal with rv threshold
        if np.abs(meddiff) > rv_thres:
            qc_pass.append(0)
        else:
            qc_pass.append(1)
        # add to qc header lists
        qc_values.append(meddiff)
        qc_names.append('CCFRV[{0}] - CCFRV[{1}]'.format(master_fiber, fiber))
        qargs = [master_fiber, fiber, rv_thres]
        qc_logic.append('abs(CCFRV[{0}] - CCFRV[{1}]) > {2} m/s'.format(*qargs))
        # print to screen
        pargs = [master_fiber, fiber, meddiff]
        # as a warning if QC fails
        if qc_pass[-1] == 0:
            WLOG(params, 'warning', textentry('40-017-00068', args=pargs),
                 sublevel=6)
        else:
            WLOG(params, 'info', textentry('40-017-00068', args=pargs))

    # --------------------------------------------------------------
    # finally log the failed messages and set QC = 1 if we pass the
    #     quality control QC = 0 if we fail quality control
    if np.sum(qc_pass) == len(qc_pass):
        WLOG(params, 'info', textentry('40-005-10001'))
    else:
        for farg in fail_msg:
            WLOG(params, 'warning', textentry('40-005-10002') + farg,
                 sublevel=6)
    # store in qc_params
    qc_params = [qc_names, qc_values, qc_logic, qc_pass]
    # return qc_params
    return qc_params


def write_wavesol(params: ParamDict, recipe: DrsRecipe, fiber: str,
                  wprops: ParamDict, hcfile: DrsFitsFile,
                  fpfile: DrsFitsFile, combine: bool,
                  rawhcfiles: List[str], rawfpfiles: List[str],
                  qc_params: List[list], master: bool = False) -> DrsFitsFile:
    """
    Write the wave solution to file (adding headers where needed)

    :param params: ParamDict, parameter dictionary of constants
    :param recipe: DrsRecipe instance, the recipe calling this function
    :param fiber: str, the fiber for this wave solution
    :param wprops: ParamDict, the wave properties for this fiber
    :param hcfile: DrsFitsFile, the input e2ds HC file instance
    :param fpfile: DrsFitsFile, the input e2ds FP file instance
    :param combine: bool, if True, e2ds inputs were combined
    :param rawhcfiles: list of strings, the raw input HC pp files
    :param rawfpfiles: list of strings, the raw input FP pp files
    :param qc_params: list of lists the quality control parameters
    :param master: bool, if True we write a master wave solution

    :return: DrsFitsFile, the wave solution instance
    """
    # ------------------------------------------------------------------
    # get copy of instance of wave file (WAVE_HCMAP)
    if master:
        wavefile = recipe.outputs['WAVESOL_MASTER'].newcopy(params=params,
                                                            fiber=fiber)
    else:
        wavefile = recipe.outputs['WAVEMAP_NIGHT'].newcopy(params=params,
                                                           fiber=fiber)
    # construct the filename from file instance
    wavefile.construct_filename(infile=fpfile)
    # set some wave keys as "SELF" (i.e. from this wave solution)
    wprops['WAVEFILE'] = wavefile.basename
    sargs = [recipe.name, params['DRS_VERSION']]
    wprops['WAVESOURCE'] = '{0} [{1}]'.format(*sargs)
    wprops['WFP_FILE'] = wavefile.basename

    # ------------------------------------------------------------------
    # Make wave coefficient table
    # ------------------------------------------------------------------
    # get number of orders
    nbo = wprops['COEFFS'].shape[0]
    # add order column
    wave_cols = ['ORDER']
    wave_vals = [np.arange(nbo)]
    # add coefficients columns
    for w_it in range(wprops['COEFFS'].shape[1]):
        wave_cols.append('COEFFS_{0}'.format(w_it))
        wave_vals.append(wprops['COEFFS'][:, w_it])
    wave_table = drs_table.make_table(params, columns=wave_cols,
                                      values=wave_vals)
    # ----------------------------------------------------------------------
    # copy original keys from fp file
    wavefile.copy_original_keys(fpfile)
    # add version
    wavefile.add_hkey('KW_VERSION', value=params['DRS_VERSION'])
    # add dates
    wavefile.add_hkey('KW_DRS_DATE', value=params['DRS_DATE'])
    wavefile.add_hkey('KW_DRS_DATE_NOW', value=params['DATE_NOW'])
    # add process id
    wavefile.add_hkey('KW_PID', value=params['PID'])
    # add output tag
    wavefile.add_hkey('KW_OUTPUT', value=wavefile.name)
    wavefile.add_hkey('KW_FIBER', value=fiber)
    # ------------------------------------------------------------------
    # set input header keys
    # ------------------------------------------------------------------
    # add input hc files (and deal with combining or not combining)
    if combine:
        hfiles1 = rawhcfiles
    else:
        hfiles1 = [hcfile.basename]
    wavefile.add_hkey_1d('KW_INFILE1', values=hfiles1, dim1name='file')
    # add input fp files (and deal with combining or not combining)
    if combine:
        hfiles2 = rawfpfiles
    else:
        hfiles2 = [fpfile.basename]
    wavefile.add_hkey_1d('KW_INFILE2', values=hfiles2, dim1name='file')
    # add infiles to outfile
    wavefile.infiles = list(hfiles1) + list(hfiles2)
    # ------------------------------------------------------------------
    # add the order num, fit degree and fit coefficients etc
    wavefile = add_wave_keys(wavefile, wprops)
    # ------------------------------------------------------------------
    # add qc parameters
    wavefile.add_qckeys(qc_params)
    # copy data
    wavefile.data = wprops['WAVEMAP']
    # ------------------------------------------------------------------
    # log that we are saving rotated image
    wargs = [fiber, wavefile.filename]
    WLOG(params, '', textentry('40-017-00037', args=wargs))
    # define multi lists
    data_list = [wave_table]
    datatype_list = ['table']
    name_list = ['COEFF_TABLE']
    # snapshot of parameters
    if params['PARAMETER_SNAPSHOT']:
        data_list += [params.snapshot_table(recipe, drsfitsfile=wavefile)]
        name_list += ['PARAM_TABLE']
        datatype_list += ['table']
    # write image to file
    wavefile.write_multi(data_list=data_list, name_list=name_list,
                         datatype_list=datatype_list,
                         block_kind=recipe.out_block_str,
                         runstring=recipe.runstring)
    # add to output files (for indexing)
    recipe.add_output_file(wavefile)
    # ------------------------------------------------------------------
    # return wavefile
    return wavefile


def add_wave_keys(infile: DrsFitsFile, props: ParamDict) -> DrsFitsFile:
    """
    Add wave keys to wave solution

    :param infile: DrsFitsFile, the wave file to write keys to
    :param props: ParamDict, the parameter dictionary of wave data

    :return: DrsFitsFile, the updated wave file instance
    """
    # set function name
    _ = display_func('add_wave_keys', __NAME__)
    # add wave parameters
    infile.add_hkey('KW_WAVEFILE', value=props['WAVEFILE'])
    infile.add_hkey('KW_WAVETIME', value=props['WAVETIME'])
    infile.add_hkey('KW_WAVESOURCE', value=props['WAVESOURCE'])
    infile.add_hkey('KW_WAVE_NBO', value=props['NBO'])
    infile.add_hkey('KW_WAVE_DEG', value=props['DEG'])
    infile.add_hkey_2d('KW_WAVECOEFFS', values=props['COEFFS'],
                       dim1name='order', dim2name='coeffs')
    # add echelle order conversions
    infile.add_hkey_1d('KW_WAVE_ECHELLE', values=props['EORDERS'],
                       dim1name='order')
    # add wave fp parameters
    infile.add_hkey('KW_WFP_FILE', value=props['WFP_FILE'])
    infile.add_hkey('KW_WFP_DRIFT', value=props['WFP_DRIFT'])
    infile.add_hkey('KW_WFP_FWHM', value=props['WFP_FWHM'])
    infile.add_hkey('KW_WFP_CONTRAST', value=props['WFP_CONTRAST'])
    infile.add_hkey('KW_WFP_MASK', value=props['WFP_MASK'])
    # WFP_LINES should be a list of ints or None or 'None'
    #     (deal with it either way)
    if props['WFP_LINES'] is None:
        infile.add_hkey('KW_WFP_LINES', None)
    elif isinstance(props['WFP_LINES'], str):
        infile.add_hkey('KW_WFP_LINES', value=props['WFP_LINES'])
    else:
        infile.add_hkey('KW_WFP_LINES', value=mp.nansum(props['WFP_LINES']))
    infile.add_hkey('KW_WFP_TARG_RV', value=props['WFP_TARG_RV'])
    infile.add_hkey('KW_WFP_WIDTH', value=props['WFP_WIDTH'])
    infile.add_hkey('KW_WFP_STEP', value=props['WFP_STEP'])
    # add some other wave keys
    infile.add_hkey_1d('KW_CAVITY_WIDTH', values=props['CAVITY'],
                         dim1name='coeffs')
    infile.add_hkey('KW_CAVITY_DEG', value=props['CAVITY_DEG'])
    infile.add_hkey('KW_WAVE_MEANHC', value=props['MEAN_HC_VEL'])
    infile.add_hkey('KW_WAVE_EMEANHC', value=props['ERR_HC_VEL'])
    # return infile
    return infile


def write_wave_lines(params: ParamDict, recipe: DrsRecipe,
                     hce2ds: DrsFitsFile, fpe2ds: DrsFitsFile,
                     wavefile: DrsFitsFile, hclines: Table,
                     fplines: Table, fiber: str, master: bool = False,
                     # TODO: REMOVE LATER
                     file_kind=None):
    """
    Write the HC and FP lines table to file

    :param params: ParamDict, the parameter dictionary of constants
    :param recipe: DrsRecipe instance, the recipe that called this function
    :param hce2ds: DrsFitsFile, the HC input e2ds file instance
    :param fpe2ds: DrsFitsFile, the FP input e2ds file instnace
    :param wavefile: DrsFitsFile, the wave solution file instance
    :param hclines: Table
    :param fplines: Table
    :param fiber: str, the fiber that we are processing
    :param master: bool, if this is a master recipe
    :param file_kind: str temp file naming override (remove later)

    :return: None - writes to file
    """
    # set function name
    _ = display_func('write_master_lines', __NAME__)
    # ------------------------------------------------------------------
    # write hc lines
    # ------------------------------------------------------------------
    # get copy of instance of wave file (WAVE_HCMAP)
    if master:
        hcfile = recipe.outputs['WAVEM_HCLIST'].newcopy(params=params,
                                                        fiber=fiber)
    else:
        hcfile = recipe.outputs['WAVE_HCLIST'].newcopy(params=params,
                                                       fiber=fiber)
    # construct the filename from file instance
    hcfile.construct_filename(infile=hce2ds)
    # ------------------------------------------------------------------
    # copy keys from hcwavefile
    hcfile.copy_hdict(wavefile)
    hcfile.copy_header(wavefile)
    # set infile
    hcfile.infiles = list(wavefile.infiles)
    # set output key
    hcfile.add_hkey('KW_OUTPUT', value=hcfile.name)
    # set data
    hcfile.data = hclines
    hcfile.datatype = 'table'
    # ------------------------------------------------------------------
    # TODO: remove later
    if file_kind is not None:
        path = hcfile.filename.split(hcfile.basename)[0]
        hcfile.basename = '{0}_{1}'.format(file_kind, hcfile.basename)
        hcfile.filename = os.path.join(path, hcfile.basename)
    # log that we are saving rotated image
    wargs = [fiber, hcfile.filename]
    WLOG(params, '', textentry('40-017-00039', args=wargs))
    # define multi lists
    data_list, name_list = [], []
    # snapshot of parameters
    if params['PARAMETER_SNAPSHOT']:
        data_list += [params.snapshot_table(recipe, drsfitsfile=hcfile)]
        name_list += ['PARAM_TABLE']
    # write image to file
    hcfile.write_multi(data_list=data_list, name_list=name_list,
                       block_kind=recipe.out_block_str,
                       runstring=recipe.runstring)
    # add to output files (for indexing)
    recipe.add_output_file(hcfile)
    # ------------------------------------------------------------------
    # write fp lines
    # ------------------------------------------------------------------
    # get copy of instance of wave file (WAVE_HCMAP)
    if master:
        fpfile = recipe.outputs['WAVEM_FPLIST'].newcopy(params=params,
                                                        fiber=fiber)
    else:
        fpfile = recipe.outputs['WAVE_FPLIST'].newcopy(params=params,
                                                       fiber=fiber)
    # construct the filename from file instance
    fpfile.construct_filename(infile=fpe2ds)
    # ------------------------------------------------------------------
    # copy keys from hcwavefile
    fpfile.copy_hdict(wavefile)
    fpfile.copy_header(wavefile)
    # set infile
    fpfile.infiles = list(wavefile.infiles)
    # set output key
    fpfile.add_hkey('KW_OUTPUT', value=fpfile.name)
    # set data
    fpfile.data = fplines
    fpfile.datatype = 'table'
    # ------------------------------------------------------------------
    # TODO: remove later
    if file_kind is not None:
        path = fpfile.filename.split(fpfile.basename)[0]
        fpfile.basename = '{0}_{1}'.format(file_kind, fpfile.basename)
        fpfile.filename = os.path.join(path, fpfile.basename)
    # log that we are saving rotated image
    wargs = [fiber, fpfile.filename]
    WLOG(params, '', textentry('40-017-00039', args=wargs))
    # define multi lists
    data_list, name_list = [], []
    # snapshot of parameters
    if params['PARAMETER_SNAPSHOT']:
        data_list += [params.snapshot_table(recipe, drsfitsfile=fpfile)]
        name_list += ['PARAM_TABLE']
    # write image to file
    fpfile.write_multi(data_list=data_list, name_list=name_list,
                       block_kind=recipe.out_block_str,
                       runstring=recipe.runstring)
    # add to output files (for indexing)
    recipe.add_output_file(fpfile)
    # ------------------------------------------------------------------
    # return hc  and fp line files
    return hcfile, fpfile


def write_fplines(params: ParamDict, recipe: DrsRecipe, rfpl: Table,
                  infile: DrsFitsFile, hfile: DrsFitsFile,
                  fiber: str, out_kind: Union[str, None] = None):
    """
    Write the FP lines to file - this is used outside the wave code
    i.e. in the extraction process

    :param params: ParamDict, the parameter dictionary of constants
    :param recipe: DrsRecipe instance, the recipe that called this function
    :param rfpl: astropy.table.Table, the input FP lines table
    :param infile: DrsFitsFile, the drs fits file instance to base the
                   output file instance on
    :param hfile: DrsFitsFile, the drs fits file instance to copy the header
                  from
    :param fiber: str, the fiber the FP lines is associated with
    :param out_kind: str or None, if set this is the output kind (i.e. one of
                     the keys defined in recipe.outputs) which points to a
                     drs fits file for output (if None uses WAVE_FPLIST)

    :return: None, writes to file
    """
    # deal with no kind set
    if out_kind is None:
        out_kind = 'WAVE_FPLIST'
    # get copy of instance of wave file (WAVE_HCMAP)
    fplfile = recipe.outputs[out_kind].newcopy(params=params, fiber=fiber)
    # construct the filename from file instance
    fplfile.construct_filename(infile=infile)
    # ------------------------------------------------------------------
    # copy keys from hfile
    fplfile.copy_hdict(hfile)
    # set output key
    fplfile.add_hkey('KW_OUTPUT', value=infile.name)
    # set data
    fplfile.data = rfpl
    fplfile.datatype = 'table'
    # ------------------------------------------------------------------
    # log that we are saving rotated image
    wargs = [fiber, fplfile.filename]
    WLOG(params, '', textentry('40-017-00039', args=wargs))
    # define multi lists
    data_list, name_list = [], []
    # snapshot of parameters
    if params['PARAMETER_SNAPSHOT']:
        data_list += [params.snapshot_table(recipe, drsfitsfile=fplfile)]
        name_list += ['PARAM_TABLE']
    # write image to file
    fplfile.write_multi(data_list=data_list, name_list=name_list,
                        block_kind=recipe.out_block_str,
                        runstring=recipe.runstring)
    # add to output files (for indexing)
    recipe.add_output_file(fplfile)


def write_cavity_file(params: ParamDict, recipe: DrsRecipe,
                      fpe2ds: DrsFitsFile, wavefile: DrsFitsFile,
                      cavity: np.ndarray) -> DrsFitsFile:
    """
    Write the cavity file to disk

    :param params: ParamDict, parameter dictionary of constants
    :param recipe: DrsRecipe, the recipe that called this function
    :param fpe2ds: DrsFitsFile, the FP e2ds fits file instance
    :param wavefile: DrsFitsFile, the wave solution file instance
    :param cavity: np.array, the cavity solution to save to file

    :return: DrsFitsFile, the cavity file instance
    """
    # set function name
    _ = display_func('write_cavity_file', __NAME__)
    # ------------------------------------------------------------------
    # write hc lines
    # ------------------------------------------------------------------
    # get copy of instance of wave file (WAVE_HCMAP)
    cavfile = recipe.outputs['WAVEM_CAVITY'].newcopy(params=params)
    # construct the filename from file instance
    cavfile.construct_filename(infile=fpe2ds)
    # ------------------------------------------------------------------
    # copy keys from hcwavefile
    cavfile.copy_header(wavefile)
    cavfile.copy_hdict(wavefile)
    # set infile
    cavfile.infiles = list(wavefile.infiles)
    # set output key
    cavfile.add_hkey('KW_OUTPUT', value=cavfile.name)
    # set data
    cavfile.data = cavity
    cavfile.datatype = 'image'
    # ------------------------------------------------------------------
    # log that we are saving rotated image
    wargs = [cavfile.filename]
    WLOG(params, '', textentry('40-017-00054', args=wargs))
    # define multi lists
    data_list, name_list = [], []
    # snapshot of parameters
    if params['PARAMETER_SNAPSHOT']:
        data_list += [params.snapshot_table(recipe, drsfitsfile=cavfile)]
        name_list += ['PARAM_TABLE']
    # write image to file
    cavfile.write_multi(data_list=data_list, name_list=name_list,
                        block_kind=recipe.out_block_str,
                        runstring=recipe.runstring)
    # add to output files (for indexing)
    recipe.add_output_file(cavfile)
    # ------------------------------------------------------------------
    # return hc  and fp line files
    return cavfile


def write_resolution_map(params: ParamDict, recipe: DrsRecipe,
                         fpe2ds: DrsFitsFile, fiber: str,
                         wavefile: DrsFitsFile, wprops: ParamDict):
    # set function name
    _ = display_func('write_cavity_file', __NAME__)

    # get maps from wprops
    map_dvs = wprops['RES_MAP_DVS']
    map_fluxes = wprops['RES_MAP_LINES']
    map_waves = wprops['RES_MAP_WAVES']
    map_orders = wprops['RES_MAP_ORDERS']
    map_fits = wprops['RES_MAP_FITS']
    map_lower_ords = wprops['RES_MAP_LOW_ORD']
    map_high_ords = wprops['RES_MAP_HIGH_ORD']
    map_lower_pix = wprops['RES_MAP_LOW_PIX']
    map_high_pix = wprops['RES_MAP_HIGH_PIX']
    map_fwhm = wprops['RES_MAP_FWHM']
    map_expo = wprops['RES_MAP_EXPO']
    map_amp = wprops['RES_MAP_AMP']
    map_res_eff = wprops['RES_MAP_EFFRES']
    n_order_bin = wprops['RES_MAP_NBIN_ORD']
    n_spatial_bin = wprops['RES_MAP_NBIN_PIX']
    nbo = wprops['RES_NBO']
    nbpix = wprops['RES_NBPIX']

    # ------------------------------------------------------------------
    # Make stats table
    # ------------------------------------------------------------------
    # set columns for stats table
    columns = ['ORDER_START', 'ORDER_END', 'PIX_START', 'PIX_END',
               'FWHM', 'AMP', 'EXPO', 'RESOLUTION']
    # push dictionaries into lists
    values = [list(map_lower_ords.values()),
              list(map_high_ords.values()),
              list(map_lower_pix.values()),
              list(map_high_pix.values()),
              list(map_fwhm.values()),
              list(map_amp.values()),
              list(map_expo.values()),
              list(map_res_eff.values())]
    stat_table = drs_table.make_table(params, columns, values)
    # ------------------------------------------------------------------
    # Make sector tables (DV, FLUX, FIT FLUX)
    # ------------------------------------------------------------------
    tables, table_names, table_headers = [], [], []
    # loop around keys
    for key in map_dvs:
        # set columns
        columns = ['DV', 'FLUX', 'FITFLUX', 'WAVE', 'ORDER']
        # push vectors into values
        values = [np.array(map_dvs[key]), np.array(map_fluxes[key]),
                  np.array(map_fits[key]), np.array(map_waves[key]),
                  np.array(map_orders[key])]
        # make the tables
        tables.append(drs_table.make_table(params, columns, values))
        # get properties for this sector
        ordlow, ordhigh = map_lower_ords[key], map_high_ords[key]
        pixlow, pixhigh = map_lower_pix[key], map_high_pix[key]
        fwhm, amp = map_fwhm[key], map_amp[key]
        expo, res_eff = map_expo[key], map_res_eff[key]
        # generate name
        name = 'Ord{0}_{1}_Pix{2}_{3}'.format(ordlow, ordhigh, pixlow, pixhigh)
        table_names.append(name)
        # header
        header = drs_fits.Header()
        # add nbo and nbpix
        header = res_map_hdr(params, header, 'KW_RESMAP_NBO', value=nbo)
        header = res_map_hdr(params, header, 'KW_RESMAP_NBPIX', value=nbpix)
        # add the bin position in order direction
        header = res_map_hdr(params, header, 'KW_RESMAP_BINORD', key[0])
        header = res_map_hdr(params, header, 'KW_RESMAP_NBINORD', n_order_bin)
        # add the bin position in spatial direction
        header = res_map_hdr(params, header, 'KW_RESMAP_BINPIX', key[1])
        header = res_map_hdr(params, header, 'KW_RESMAP_NBINPIX', n_spatial_bin)
        # add order low
        header = res_map_hdr(params, header, 'KW_RES_MAP_ORDLOW', ordlow)
        # add order high
        header = res_map_hdr(params, header, 'KW_RES_MAP_ORDHIGH', ordhigh)
        # add pix low
        header = res_map_hdr(params, header, 'KW_RES_MAP_PIXLOW', pixlow)
        # add pix high
        header = res_map_hdr(params, header, 'KW_RES_MAP_PIXHIGH', pixhigh)
        # add fwhm
        header = res_map_hdr(params, header, 'KW_RES_MAP_FWHM', fwhm)
        # add amp
        header = res_map_hdr(params, header, 'KW_RES_MAP_AMP', amp)
        # add expo
        header = res_map_hdr(params, header, 'KW_RES_MAP_EXPO', expo)
        # add effective resolution
        header = res_map_hdr(params, header, 'KW_RES_MAP_RESEFF', res_eff)
        # add the headers
        table_headers.append(header)
    # ------------------------------------------------------------------
    # write resolution map
    # ------------------------------------------------------------------
    # get copy of instance of wave file (WAVE_HCMAP)
    resfile = recipe.outputs['WAVEM_RES'].newcopy(params=params,
                                                  fiber=fiber)
    # construct the filename from file instance
    resfile.construct_filename(infile=fpe2ds)
    # ------------------------------------------------------------------
    # copy keys from hcwavefile
    resfile.copy_header(wavefile)
    # set output key
    resfile.add_hkey('KW_OUTPUT', value=resfile.name)
    # add some basic keys to know whats in this file
    resfile.add_hkey('KW_RESMAP_NBO', value=nbo)
    resfile.add_hkey('KW_RESMAP_NBPIX', value=nbpix)
    resfile.add_hkey('KW_RESMAP_NBINORD', value=n_order_bin)
    resfile.add_hkey('KW_RESMAP_NBINPIX', value=n_spatial_bin)
    # set data
    resfile.data = stat_table
    resfile.datatype = 'table'
    # ------------------------------------------------------------------
    # log that we are saving rotated image
    wargs = [fiber, resfile.filename]
    WLOG(params, '', textentry('40-017-00020', args=wargs))
    # define multi lists
    data_list, name_list = tables, table_names
    header_list = table_headers
    # snapshot of parameters
    if params['PARAMETER_SNAPSHOT']:
        data_list += [params.snapshot_table(recipe, drsfitsfile=resfile)]
        name_list += ['PARAM_TABLE']
        header_list += [None]
    # write image to file
    resfile.write_multi(data_list=data_list, header_list=header_list,
                        name_list=name_list,
                        block_kind=recipe.out_block_str,
                        runstring=recipe.runstring)
    # add to output files (for indexing)
    recipe.add_output_file(resfile)


def res_map_hdr(params: ParamDict, header: drs_fits.Header,
                drs_key: str, value: Any) -> drs_fits.Header:
    # get keystore information
    key, _, comment = params[drs_key]
    # load header
    header[key] = (value, comment)
    # return header
    return header


def wave_summary(recipe, params, props, fiber, qc_params):
    # add qc params (fiber specific)
    recipe.plot.add_qc_params(qc_params, fiber=fiber)
    # add stats
    recipe.plot.add_stat('KW_VERSION', value=params['DRS_VERSION'],
                         fiber=fiber)
    recipe.plot.add_stat('KW_DRS_DATE', value=params['DRS_DATE'],
                         fiber=fiber)
    # add constants used (for reproduction)
    recipe.plot.add_stat('KW_WAVEFILE', value=props['WAVEFILE'])
    recipe.plot.add_stat('KW_WAVETIME', value=props['WAVETIME'])
    recipe.plot.add_stat('KW_WAVESOURCE', value=props['WAVESOURCE'])
    recipe.plot.add_stat('KW_WAVE_NBO', value=props['NBO'])
    recipe.plot.add_stat('KW_WAVE_DEG', value=props['DEG'])
    recipe.plot.add_stat('KW_WFP_FILE', value=props['WFP_FILE'])
    recipe.plot.add_stat('KW_WFP_DRIFT', value=props['WFP_DRIFT'])
    recipe.plot.add_stat('KW_WFP_FWHM', value=props['WFP_FWHM'])
    recipe.plot.add_stat('KW_WFP_CONTRAST', value=props['WFP_CONTRAST'])
    recipe.plot.add_stat('KW_WFP_MASK', value=props['WFP_MASK'])


# =============================================================================
# Start of code
# =============================================================================
if __name__ == "__main__":
    # print hello world
    print('Hello World')

# =============================================================================
# End of code
# =============================================================================
