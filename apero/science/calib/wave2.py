#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
# CODE NAME HERE

# CODE DESCRIPTION HERE

Created on 

@author: 
"""
from astropy.table import Table
from astropy import constants as cc
from astropy import units as uu
import numpy as np
import os
from typing import Dict, List, Tuple, Union
import warnings

from apero.core import constants
from apero.core import math as mp
from apero import lang
from apero.core.core import drs_log
from apero.core.core import drs_file
from apero.core.core import drs_database
from apero.core.utils import drs_recipe
from apero.core.utils import drs_data
from apero.core.utils import drs_startup
from apero.io import drs_image
from apero.io import drs_fits
from apero.io import drs_table
from apero.science.calib import general
from apero.science import velocity

# =============================================================================
# Define variables
# =============================================================================
__NAME__ = 'science.calib.wave2.py'
__INSTRUMENT__ = 'None'
# Get constants
Constants = constants.load(__INSTRUMENT__)
# Get version and author
__version__ = Constants['DRS_VERSION']
__author__ = Constants['AUTHORS']
__date__ = Constants['DRS_DATE']
__release__ = Constants['DRS_RELEASE']
# get param dict
ParamDict = constants.ParamDict
DrsFitsFile = drs_file.DrsFitsFile
DrsRecipe = drs_recipe.DrsRecipe
# get calibration database
CalibDB = drs_database.CalibrationDatabase
# Get Logging function
WLOG = drs_log.wlog
# alias pcheck
pcheck = constants.PCheck(wlog=WLOG)
# Get the text types
textentry = lang.textentry
# Speed of light
# noinspection PyUnresolvedReferences
speed_of_light_ms = cc.c.to(uu.m / uu.s).value
# noinspection PyUnresolvedReferences
speed_of_light = cc.c.to(uu.km / uu.s).value
# Get function string
display_func = drs_log.display_func


# =============================================================================
# Define getting file functions
# =============================================================================
def get_masterwave_filename(params: ParamDict, fiber: str,
                            database: Union[CalibDB, None] = None) -> str:
    """
    Load the master wave solution

    Order of preference: WAVEM_FP >> WAVEM_HC >> WAVEM_D

    :param params:
    :param fiber:
    :param database:
    :return:
    """
    # set function name
    func_name = display_func(params, 'get_masterwave_filename', __NAME__)
    # get pseudo constants
    pconst = constants.pload()
    # deal with fibers that we don't have
    usefiber = pconst.FIBER_WAVE_TYPES(fiber)
    # ------------------------------------------------------------------------
    # load database
    if database is None:
        calibdbm = drs_database.CalibrationDatabase(params)
        calibdbm.load_db()
    else:
        calibdbm = database
    # ------------------------------------------------------------------------
    # get file definition (order of preference)
    keys = ['WAVEM_FP', 'WAVEM_HC', 'WAVEM_D']
    filename = None
    # loop around possible wave master keys
    for k_it in range(len(keys)):
        # first check for wave masters generated by the drs
        out_wave = drs_startup.get_file_definition(keys[k_it],
                                                   params['INSTRUMENT'],
                                                   kind='red', required=False)
        # if out_wave is None we need to check other keys
        if out_wave is None:
            continue
        # get calibration key
        key = out_wave.get_dbkey()
        # ---------------------------------------------------------------------
        # load master key
        filename = calibdbm.get_calib_file(key, no_times=True, nentries=1,
                                           required=False, fiber=usefiber)
        # stop loop if we have found our master file
        if filename is not None:
            break
    # if we still have None we have a problem
    if filename is None:
        eargs = [', '.join(keys), func_name]
        WLOG(params, 'error', textentry('09-017-00007', args=eargs))
        return ''
    else:
        # return the last valid wave entry
        return str(filename)


WaveReturn = Tuple[DrsFitsFile, Union[np.ndarray, None], str, float]


def get_wave_solution_from_wavefile(params: ParamDict,
                                    usefiber: str, inwavefile: str,
                                    header: drs_fits.Header,
                                    database: Union[CalibDB, None] = None,
                                    master: bool = False) -> WaveReturn:
    """
    Get wave solution from a given wave filename

    :param params: ParamDict, parameter dictionary of constants
    :param usefiber: str, the fiber for this wave file
    :param inwavefile: str, the wave filename
    :param header: fits.Header, the header for this wave file
    :param database: calibration database instance or None - just so we don't
                     have to load it if already loaded
    :param master: bool, if True we require the master file (overrides the
                   wave filename

    :return: wave file instance, wave map, wave file name and mid exp time
    """
    # ------------------------------------------------------------------------
    # get file definitions (wave solution FP and wave solution HC)
    out_wave_fp = drs_startup.get_file_definition('WAVEM_FP',
                                                  params['INSTRUMENT'],
                                                  kind='red')
    out_wave_hc = drs_startup.get_file_definition('WAVEM_HC',
                                                  params['INSTRUMENT'],
                                                  kind='red')
    # ------------------------------------------------------------------------
    # deal with master = True
    if master is True:
        # get master path
        inwavefile = get_masterwave_filename(params, fiber=usefiber,
                                             database=database)
        source = 'master'
    else:
        # ---------------------------------------------------------------------
        # setup calib db keys
        # ---------------------------------------------------------------------
        # get calibration key
        key_fp = out_wave_fp.get_dbkey()
        key_hc = out_wave_hc.get_dbkey()
        # ---------------------------------------------------------------------
        if database is None:
            # load the calibration database
            calibdbm = drs_database.CalibrationDatabase(params)
            calibdbm.load_db()
        else:
            calibdbm = database
        # ---------------------------------------------------------------------
        # load filename from inputs/calibDB
        # ---------------------------------------------------------------------
        lkwargs = dict(userinputkey='WAVEFILE', database=calibdbm, key=key_fp,
                       inheader=header, filename=inwavefile, fiber=usefiber,
                       return_filename=True, required=False, return_source=True)
        # load wave fp file
        fout = general.load_calib_file(params, **lkwargs)
        # get filename and source from outputs
        inwavefile, source = fout
        if isinstance(source, str):
            source += '[FP]'
        # ---------------------------------------------------------------------
        # then check hc solution (if we don't have an fp solution filename
        if inwavefile is None:
            # need to re-add filename (may have changed value)
            lkwargs['filename'] = inwavefile
            lkwargs['key'] = key_hc
            # load wave hc file
            fout = general.load_calib_file(params, **lkwargs)
            # get filename and source from outputs
            filename, source = fout
            if isinstance(source, str):
                source += '[FP]'
        # ---------------------------------------------------------------------
        # if inwavefile is still None
        if inwavefile is None:
            # get master path
            inwavefile = get_masterwave_filename(params, fiber=usefiber,
                                                 database=database)
    # -------------------------------------------------------------------------
    # construct new infile instance (first fp solution then hc solutions)
    if out_wave_fp.suffix in str(inwavefile):
        wavefile = out_wave_fp.newcopy(filename=inwavefile, params=params,
                                       fiber=usefiber)
    else:
        wavefile = out_wave_hc.newcopy(filename=inwavefile, params=params,
                                       fiber=usefiber)
    # read data/header
    wavefile.read_file()
    # get wave map
    wavemap = wavefile.get_data(copy=True)
    # set wave source of wave file
    wavesource = source
    # get wave time
    wavetime = wavefile.get_hkey('KW_MID_OBS_TIME', dtype=float,
                                 has_default=True, default=0.0)
    # return to main get_wave function
    return wavefile, wavemap, wavesource, wavetime


def get_wave_solution_from_inheader(params: ParamDict, recipe: DrsRecipe,
                                    infile: DrsFitsFile,
                                    header: drs_fits.Header,
                                    usefiber: str) -> WaveReturn:
    # set function
    func_name = display_func(params, 'get_wave_solution_from_inheader',
                             __NAME__)
    # ------------------------------------------------------------------------
    # type 1: just from header
    if infile is None:
        # get keywords from params
        outputkey = params['KW_OUTPUT'][0]
        dprtypekey = params['KW_DPRTYPE'][0]
        # first see if we are dealing with a reduced file
        if outputkey in header:
            # get filetype from header (KW_OUTPUT)
            filetype = header[outputkey]
            # set kind
            kind = 'red'
        # else we can't have a wavelength solution
        else:
            # get filetype from header (dprtype)
            filetype = header[dprtypekey]
            # log error
            eargs = [outputkey, dprtypekey, filetype, func_name]
            WLOG(params, 'error', textentry('00-017-00008', args=eargs))
            kind = None
        # get wave file instance
        wavefile = drs_startup.get_file_definition(filetype,
                                                   params['INSTRUMENT'],
                                                   kind=kind, fiber=usefiber)
        # set wave file properties (using header)
        wavefile.recipe = recipe
        wavefile.header = header
        wavefile.filename = header[params['KW_WAVEFILE'][0]]
        # if we have a wave time use it
        if params['KW_WAVETIME'][0] in header:
            wavetime = header[params['KW_WAVETIME'][0]]
        else:
            wavetime = header[params['KW_MID_OBS_TIME'][0]]
        # set the wave file data
        wavefile.data = np.zeros((header['NAXIS2'], header['NAXIS1']))
        # set the source as header
        wavesource = 'header'
        # get wave map
        wavemap = None
    # ------------------------------------------------------------------------
    # type 2: from infile DrsFitsFile
    else:
        wavefile = infile.completecopy(infile)
        # set the file name to the wave file
        wavefile.filename = wavefile.get_hkey('KW_WAVEFILE')
        # if we have a wave time use it
        if params['KW_WAVETIME'][0] in header:
            wavetime = wavefile.get_hkey('KW_WAVETIME')
        else:
            wavetime = wavefile.get_hkey('KW_MID_OBS_TIME', dtype=float,
                                         has_default=True, default=0.0)
        # wave source is the infile
        wavesource = 'infile'
        # get wave map
        wavemap = None

    assert isinstance(wavefile, DrsFitsFile)
    # ------------------------------------------------------------------------
    return wavefile, wavemap, wavesource, wavetime


def get_wavesolution(params: ParamDict, recipe: DrsRecipe,
                     header: Union[drs_fits.Header, None] = None,
                     infile: Union[DrsFitsFile, None] = None,
                     fiber: Union[str, None] = None,
                     master: bool = False,
                     database: Union[CalibDB, None] = None,
                     **kwargs) -> ParamDict:
    """
    Get the wavelength solution

    1. From file (if "filename" set in call)
    2. From file (if --wavefile set in sys.argv from params['INPUTS'])
    3. From calibDB if force=True or master=True or keys missing from
       infile/header
    4. From header if not None and keys present
    5. From infile if not None and keys present

    :param params: parameter dictionary, ParamDict containing constants
    :param recipe: DrsRecipe instance, the recipe instance used
    :param header: FitsHeader or None, the header to use
    :param infile: DrsFitsFile or None, the infile associated with the header
                   can be used instead of header
    :param fiber: str, the fiber to get the wave solution for
    :param master: bool, if True forces use of the master wavelength solution
    :param database: calib database or None, if set avoids reloading the
                     calibration database
    :param kwargs: keyword arguments passed to function

    :keyword force: bool, if True forces wave solution to come from calibDB
    :keyword filename: str or None, the filename to get wave solution from
                       this will overwrite all other options
    :return:
    """
    # set function name
    func_name = display_func(params, 'get_wavesolution', __NAME__)
    # get parameters from params/kwargs
    inwavefile = kwargs.get('filename', None)
    force = pcheck(params, 'CALIB_DB_FORCE_WAVESOL', 'force', kwargs,
                   func_name)
    # ------------------------------------------------------------------------
    # get pseudo constants
    pconst = constants.pload()
    # deal with which fiber to use
    if kwargs.get('forcefiber', False):
        usefiber = str(fiber)
    elif master:
        usefiber = pconst.FIBER_WAVE_TYPES(fiber)
    else:
        usefiber = str(fiber)
    # ------------------------------------------------------------------------
    # deal with infile vs header (need one for either forced or unforced)
    #    exception is when we are getting a master
    # ------------------------------------------------------------------------
    # check infile is instance of DrsFitsFile
    if infile is not None:
        if not isinstance(infile, drs_file.DrsFitsFile):
            eargs = [type(infile), func_name]
            WLOG(params, 'error', textentry('00-017-00001', args=eargs))
    # ------------------------------------------------------------------------
    # deal with no header but an infile
    if header is None and infile is not None:
        header = infile.get_header()
    # we need a header unless master is True
    if not master and header is None:
        WLOG(params, 'error', textentry('00-017-00009', args=[func_name]))
    # ------------------------------------------------------------------------
    # Get in wave file
    # ------------------------------------------------------------------------
    # check whether we need to force from database
    force = force or master
    if master is False:
        force = force or (params['KW_WAVE_NBO'][0] not in header)
        force = force or (params['KW_WAVE_DEG'][0] not in header)
        force = force or (params['KW_CDBWAVE'][0] not in header)
        # deal with header having different fiber value that usefiber
        if not force and (params['KW_FIBER'][0] in header):
            if header[params['KW_FIBER'][0]] != usefiber:
                force = True
    # ------------------------------------------------------------------------
    # Mode 1: forced from input filename or calibDB i.e. from a wave file
    # ------------------------------------------------------------------------
    if force:
        wargs = [usefiber, inwavefile, header, database, master]
        wout = get_wave_solution_from_wavefile(params, *wargs)
        wavefile, wavemap, wavesource, wavetime = wout
    # ------------------------------------------------------------------------
    # Mode 2: using header or infile only i.e. from the input files header
    # ------------------------------------------------------------------------
    else:
        wargs = [infile, header, usefiber]
        wout = get_wave_solution_from_inheader(params, recipe, *wargs)
        wavefile, wavemap, wavesource, wavetime = wout
    # ------------------------------------------------------------------------
    # Log progress
    # -------------------------------------------------------------------------
    wargs = [wavesource, wavefile.filename]
    WLOG(params, '', textentry('40-017-00036', args=wargs))
    # ------------------------------------------------------------------------
    # Now deal with using wavefile
    # -------------------------------------------------------------------------
    # wavefile must have params set
    wavefile.params = params
    # extract keys from header
    nbo = wavefile.get_hkey('KW_WAVE_NBO', dtype=int)
    deg = wavefile.get_hkey('KW_WAVE_DEG', dtype=int)
    # get the wfp keys
    wfp_file = wavefile.get_hkey('KW_WFP_FILE', dtype=str,
                                 required=False)
    wfp_drift = wavefile.get_hkey('KW_WFP_DRIFT', dtype=float,
                                  required=False)
    wfp_fwhm = wavefile.get_hkey('KW_WFP_FWHM', dtype=float,
                                 required=False)
    wfp_contrast = wavefile.get_hkey('KW_WFP_CONTRAST', dtype=float,
                                     required=False)
    wfp_mask = wavefile.get_hkey('KW_WFP_MASK', dtype=float,
                                 required=False)
    wfp_lines = wavefile.get_hkey('KW_WFP_LINES', dtype=float,
                                  required=False)
    wfp_target_rv = wavefile.get_hkey('KW_TARG_RV', dtype=float,
                                      required=False)
    wfp_width = wavefile.get_hkey('KW_WFP_WIDTH', dtype=float,
                                  required=False)
    wfp_step = wavefile.get_hkey('KW_WFP_STEP', dtype=float,
                                 required=False)
    # extract cofficients from header
    wave_coeffs = wavefile.get_hkey_2d('KW_WAVECOEFFS',
                                       dim1=nbo, dim2=deg + 1)
    # -------------------------------------------------------------------------
    # if wavemap is unset create it from wave coefficients
    if wavemap is None:
        # get image dimensions
        if infile is not None:
            nby, nbx = infile.get_data().shape
        else:
            nby, nbx = header['NAXIS2'], header['NAXIS1']
        wavemap = get_wavemap_from_coeffs(wave_coeffs, nbo, nbx)
    # -------------------------------------------------------------------------
    # store wave properties in parameter dictionary
    wprops = ParamDict()
    wprops['WAVEFILE'] = wavefile.filename
    wprops['WAVEINIT'] = wavefile.filename
    wprops['WAVESOURCE'] = wavesource
    wprops['NBO'] = nbo
    if wavemap is not None:
        wprops['NBPIX'] = wavemap.shape[1]
    else:
        wprops['NBPIX'] = None
    wprops['DEG'] = deg
    wprops['COEFFS'] = wave_coeffs
    wprops['WAVEMAP'] = wavemap
    wprops['WAVEINST'] = wavefile.completecopy(wavefile)
    wprops['WAVETIME'] = wavetime
    # add the wfp keys
    wfp_keys = ['WFP_FILE', 'WFP_DRIFT', 'WFP_FWHM', 'WFP_CONTRAST', 'WFP_MASK',
                'WFP_LINES', 'WFP_TARG_RV', 'WFP_WIDTH', 'WFP_STEP']
    wfp_values = [wfp_file, wfp_drift, wfp_fwhm, wfp_contrast, wfp_mask,
                  wfp_lines, wfp_target_rv, wfp_width, wfp_step]
    # add keys accounting for 'None' and blanks
    for wfpi in range(len(wfp_keys)):
        if wfp_values[wfpi] == '' or wfp_values[wfpi] == 'None':
            wprops[wfp_keys[wfpi]] = None
        else:
            wprops[wfp_keys[wfpi]] = wfp_values[wfpi]
    # set the source
    keys = ['WAVEMAP', 'WAVEFILE', 'WAVEINIT', 'WAVESOURCE', 'NBO', 'DEG',
            'COEFFS', 'WAVETIME', 'WAVEINST', 'NBPIX'] + wfp_keys
    wprops.set_sources(keys, func_name)
    # -------------------------------------------------------------------------
    # return the map and properties
    return wprops


def get_wavemap_from_coeffs(wave_coeffs: np.ndarray, nbo: int,
                            nbx: int) -> np.ndarray:
    # set up storage
    wavemap = np.zeros((nbo, nbx))
    xpixels = np.arange(nbx)
    # loop aroun each order
    for order_num in range(nbo):
        # get this order coefficients
        ocoeffs = wave_coeffs[order_num][::-1]
        # calculate polynomial values and push into wavemap
        wavemap[order_num] = np.polyval(ocoeffs, xpixels)
    return wavemap


def get_cavity_file(params: ParamDict, recipe: DrsRecipe,
                    header: Union[drs_fits.Header, None] = None,
                    filename: Union[str, None] = None,
                    infile: Union[DrsFitsFile, None] = None,
                    database: Union[CalibDB, None] = None
                    ) -> Union[np.array, None]:
    """
    Get the cavity file

    :param params: ParamDict, parameter dictionary of constants
    :param recipe: Drs Recipe instance, the recipe running this function
    :param header: the header from an input file (required because we may have
                   multiple cavity files in the calibration database)
    :param filename: str, the filename linked to the header
    :param infile: DrsFitsFile, instead of header + filename you can give a
                   DrsFitsFile instance (which has header and filename
                   internally)
    :param database: calibration database instance or None, stops us reloading
                     the calibration database when already loaded

    :return: the cavity polynomial coefficients (as a numpy array)
    """
    # get cavity file
    cavity_file = recipe.outputs['WAVEM_CAVITY'].newcopy(params=params)
    # deal with infile (instead of header/filename)
    if infile is not None:
        header = infile.header
        filename = infile.filename
    # ---------------------------------------------------------------------
    # setup calib db keys
    # ---------------------------------------------------------------------
    # get calibration key
    cavity_key = cavity_file.get_dbkey()
    # ---------------------------------------------------------------------
    if database is None:
        # load the calibration database
        calibdbm = drs_database.CalibrationDatabase(params)
        calibdbm.load_db()
    else:
        calibdbm = database
    # ---------------------------------------------------------------------
    # load filename from inputs/calibDB
    # ---------------------------------------------------------------------
    lkwargs = dict(userinputkey='CAVITYFILE', database=calibdbm, key=cavity_key,
                   inheader=header, filename=filename, return_source=True,
                   required=False)
    # load wave fp file
    cout = general.load_calib_file(params, **lkwargs)
    if cout is None:
        return None
    else:
        cimage, cheader, cfilename, csource = cout
    # ---------------------------------------------------------------------
    # return cavity image
    return np.array(cimage)


# =============================================================================
# Define line functions
# =============================================================================
def calc_wave_lines(params: ParamDict, recipe: DrsRecipe,
                    e2dsfile: DrsFitsFile, wavemap: np.array,
                    cavity_poly: Union[np.ndarray, None] = None,
                    hclines: Union[Table, None] = None,
                    fplines: Union[Table, None] = None,
                    iteration: Union[int, None] = None):
    # set the function name
    func_name = display_func(params, 'get_master_lines', __NAME__)
    # -------------------------------------------------------------------------
    # get parameters from params and kwargs
    # -------------------------------------------------------------------------
    # Define the initial value of FP effective cavity width 2xd in nm
    guess_cavity_width = pcheck(params, 'WAVE_GUESS_CAVITY_WIDTH',
                                func=func_name)
    # Define the cavity fit polynomial fit degree for wave solution
    cavity_fit_degree = pcheck(params, 'WAVE_CAVITY_FIT_DEGREE',
                               func=func_name)
    # min SNR to consider the line
    nsig_min = pcheck(params, 'WAVEREF_NSIG_MIN', func=func_name)
    # minimum distance to the edge of the array to consider a line
    wmax = pcheck(params, 'WAVEREF_EDGE_WMAX', func=func_name)
    # value in pixel (+/-) for the box size around each HC line to perform fit
    hcboxsize = pcheck(params, 'WAVEREF_HC_BOXSIZE', func=func_name)
    # get valid hc dprtypes (string list separated by commas)
    hcfibtypes = pcheck(params, 'WAVEREF_HC_FIBTYPES', 'hcfibtypes',
                        func=func_name, mapf='list', dtype=str)
    # get valid fp dprtypes (string list separated by commas)
    fpfibtypes = pcheck(params, 'WAVEREF_FP_FIBTYPES', 'fpfibtypes',
                        func=func_name, mapf='list', dtype=str)
    # get the degree to fix master wavelength to in hc mode
    fitdeg = pcheck(params, 'WAVEREF_FITDEG', 'fitdeg', func=func_name)
    # define the lowest N for fp peaks
    fp_nlow = pcheck(params, 'WAVEREF_FP_NLOW', 'fp_nlow', func=func_name)
    # define the highest N for fp peaks
    fp_nhigh = pcheck(params, 'WAVEREF_FP_NHIGH', 'fp_nhigh', func=func_name)
    # define the number of iterations required to do the FP polynomial inversion
    fp_inv_itr = pcheck(params, 'WAVEREF_FP_POLYINV', 'fp_inv_itr',
                        func=func_name)
    # ------------------------------------------------------------------
    # get psuedo constants
    pconst = constants.pload(params['INSTRUMENT'])
    # get the shape from the wavemap
    nbo, nbpix = wavemap.shape
    # get dprtype
    dprtype = e2dsfile.get_hkey('KW_DPRTYPE', dtype=str)
    # get fiber type
    fiber = e2dsfile.get_hkey('KW_FIBER', dtype=str)
    # get fiber type
    fibtype = pconst.FIBER_DPR_POS(dprtype, fiber)
    # set up the xpixels
    xpix = np.arange(nbpix)
    # ----------------------------------------------------------------------
    # get the lines for HC files from hclines input
    # ----------------------------------------------------------------------
    if hclines is not None:
        list_waves = hclines['WAVE_REF']
        list_orders = hclines['ORDER']
        list_pixels = hclines['PIXEL_REF']
        list_wfit = hclines['WFIT']
        peak_number = hclines['PEAK_NUMBER']
    # ----------------------------------------------------------------------
    # get the lines for HC files from fplines input
    # ----------------------------------------------------------------------
    elif fplines is not None:
        list_waves = fplines['WAVE_REF']
        list_orders = fplines['ORDER']
        list_pixels = fplines['PIXEL_REF']
        list_wfit = fplines['WFIT']
        peak_number = fplines['PEAK_NUMBER']
    # ----------------------------------------------------------------------
    # get the lines for HC files
    # ----------------------------------------------------------------------
    elif fibtype in hcfibtypes:
        # print progress Running get ref lines for HC
        WLOG(params, 'info', textentry('40-017-00049'))
        # load the line list
        wavell, ampll = drs_data.load_linelist(params)
        # storage for outputs
        list_waves, list_orders, list_pixels = [], [], []
        # loop around orders and get the lines that fall within each
        #    diffraction order
        for order_num in range(nbo):
            # we have a wavelength value, we get an approximate pixel
            # value by fitting wavelength to pixel
            owave = wavemap[order_num]
            with warnings.catch_warnings(record=True) as _:
                fit_reverse = np.polyfit(owave, xpix, fitdeg)
            # we find lines within the order
            good = (wavell > np.min(owave)) & (wavell < np.max(owave))
            # we check that there is at least 1 line and append our line list
            if np.sum(good) != 0:
                # get the pixels positions based on out owave fit
                pixfit = np.polyval(fit_reverse, wavell[good])
                # append lists
                list_waves += list(wavell[good])
                list_orders += list(np.repeat(order_num, np.sum(good)))
                list_pixels += list(pixfit)
        # make line lists np arrays
        list_waves = np.array(list_waves)
        list_orders = np.array(list_orders)
        list_pixels = np.array(list_pixels)
        # keep lines that are  not too close to image edge
        keep = (list_pixels > wmax) & (list_pixels < (nbpix - wmax))
        # apply to list arrays
        list_waves = list_waves[keep]
        list_orders = list_orders[keep]
        list_pixels = list_pixels[keep]
        # set wfit to a constant for HC
        list_wfit = np.repeat(hcboxsize, len(list_pixels))

        # just for the sake of consistency, we need to attribute a fractional
        # FP cavity number to HC peaks. This ensures that the table saved at
        # then end of this code has the same format as for FPs.
        peak_number = np.repeat(np.nan, len(list_pixels))
    # ----------------------------------------------------------------------
    # get the lines for FP files
    # ----------------------------------------------------------------------
    elif fibtype in fpfibtypes:
        # print progress Running get ref lines for FP
        WLOG(params, 'info', textentry('40-017-00050'))
        # ------------------------------------------------------------------
        # deal with getting cavity poly
        if cavity_poly is not None:
            cavity_length_poly = np.array(cavity_poly)
        else:
            # load the first guess cavity polynomial from file
            _, fit_ll = drs_data.load_cavity_files(params)
            cavity_length_poly = fit_ll * 2
        # ------------------------------------------------------------------
        # range of the N FP peaks
        nth_peak = np.arange(fp_nlow, fp_nhigh)
        # storage for the wavelength centers
        wave0 = np.ones_like(nth_peak, dtype=float)
        # start the wave inversion of the polynomial at a sensible value
        wave0 = wave0 * np.nanmean(wavemap)
        # need a few iterations to invert polynomial relations
        for _ in range(fp_inv_itr):
            wave0 = np.polyval(cavity_length_poly, wave0)
            wave0 = wave0 / nth_peak
        # keep lines within the master_wavelength domain
        keep = (wave0 > np.min(wavemap)) & (wave0 < np.max(wavemap))
        wave0 = wave0[keep]
        # sort by wavelength
        wave0 = wave0[np.argsort(wave0)]
        # storage for outputs
        list_waves, list_orders, list_pixels, list_wfit = [], [], [], []
        # loop around orders and get the lines that fall within each
        #    diffraction order
        for order_num in range(nbo):
            # we have a wavelength value, we get an approximate pixel
            # value by fitting wavelength to pixel
            owave = wavemap[order_num]
            with warnings.catch_warnings(record=True) as _:
                # fit_reverse = np.polyfit(owave, xpix, fitdeg)

                ord_owave = np.argsort(owave)
                spline_fit_reverse = mp.iuv_spline(owave[ord_owave],
                                                   xpix[ord_owave])

            # we find lines within the order
            good = (wave0 > np.min(owave)) & (wave0 < np.max(owave))
            # we check that there is at least 1 line and append our line list
            if np.sum(good) != 0:
                # get the pixels positions based on out owave fit
                # pixfit = np.polyval(fit_reverse, wave0[good])
                pixfit = spline_fit_reverse(wave0[good])
                # get the dpix coeffs
                dpixc = np.polyfit(pixfit[1:], pixfit[1:] - pixfit[:-1], 2)
                # use this to get the rounded width?
                wfit = np.ceil(np.polyval(dpixc, pixfit))
                # append to the lists
                list_waves += list(wave0[good])
                list_orders += list(np.repeat(order_num, np.sum(good)))
                list_pixels += list(pixfit)
                list_wfit += list(wfit)
        # make line lists np arrays
        list_waves = np.array(list_waves)
        list_orders = np.array(list_orders)
        list_pixels = np.array(list_pixels)
        list_wfit = np.array(list_wfit, dtype=int)
        # keep lines that are  not too close to image edge
        keep = (list_pixels > wmax) & (list_pixels < (nbpix - wmax))
        # apply to list arrays
        list_waves = list_waves[keep]
        list_orders = list_orders[keep]
        list_pixels = list_pixels[keep]
        list_wfit = list_wfit[keep]

        # Once we have a cavity length, we find the integer FP peak number.
        # This will be compiled in the table later and used for nightly
        # wavelength solutions by changing the achromatic part of the cavity
        # length relative to the master night. By construction, this is
        # always an integer.
        cavfit = np.polyval(cavity_length_poly, list_waves)
        peak_number = np.array(cavfit / list_waves, dtype=int)
    # ----------------------------------------------------------------------
    # else we break
    # ----------------------------------------------------------------------
    else:
        # log error and break
        eargs = [e2dsfile.name, dprtype, fiber, func_name, hcfibtypes,
                 fpfibtypes]
        WLOG(params, 'error', textentry('00-017-00012', args=eargs))
        list_waves = []
        list_orders = []
        list_pixels = []
        list_wfit = []
        peak_number = []
    # ----------------------------------------------------------------------
    # Fit the peaks
    # ----------------------------------------------------------------------
    # set up storage
    pixel_m = np.array(list_pixels)
    wave_m = np.zeros_like(list_waves)
    ewidth = np.zeros_like(list_pixels)
    amp = np.zeros_like(list_pixels)
    nsig = np.repeat(np.nan, len(list_pixels))
    # ----------------------------------------------------------------------
    # loop around orders
    for order_num in range(nbo):
        # get the order spectrum
        sorder = e2dsfile.data[order_num]
        # find all lines in this order
        good = np.where(list_orders == order_num)[0]
        # get order lines
        order_waves = list_waves[good]
        order_pixels = list_pixels[good]
        order_wfit = list_wfit[good]
        # ------------------------------------------------------------------
        # loop around lines
        valid_lines = 0
        for it in range(len(order_waves)):
            # get the x pixel position
            xpixi = int(np.round(order_pixels[it]))
            # get the width
            wfit = int(np.round(order_wfit[it]))
            # get the pixels within this peak
            index = np.arange(xpixi - wfit, xpixi + wfit + 1)
            # Need to check that index is in bounds
            if (np.min(index) < 0) or (np.max(index) >= nbpix):
                eargs = [order_num, it, index, xpixi, wfit, func_name]
                WLOG(params, 'warning', textentry('09-017-00005', args=eargs))
                continue
            # get the flux value in this peak
            ypix = sorder[index]
            # deal with less points than fit (shouldn't happen but worth
            #    catching before an exception happens in fit_gauss_with_slope)
            if len(ypix) < 5:
                eargs = [order_num, it, index, ypix]
                WLOG(params, 'warning', textentry('09-017-00006', args=eargs))
                continue
            # --------------------------------------------------------------
            # only continue if we have some finite values
            if np.all(np.isfinite(ypix)):
                # try fitting a gaussian with a slope
                try:
                    # get ypix max and min
                    ymax, ymin = mp.nanmax(ypix), mp.nanmin(ypix)
                    # get up a gauss fit guess
                    guess = [ymax - ymin, xpixi, 1, ymin, 0]
                    # if HC fit a gaussian with a slope
                    if fibtype in hcfibtypes:
                        out = mp.fit_gauss_with_slope(index, ypix, guess, True)
                        # get parameters from fit
                        popt, pcov, model = out
                        # get width condition
                        cond2 = (popt[2] < 2) and (popt[2] > 0.5)
                    # else fit ea airy function to FP
                    else:
                        out = velocity.fit_fp_peaks(index, ypix, wfit,
                                                    return_model=True)
                        # get parameters from fit
                        p0, popt, pcov, warns, model = out
                        # get width condition
                        cond2 = np.abs(popt[2] / wfit - 1) < 0.5
                    # calculate the RMS of the fit
                    rms = mp.nanstd(ypix - model)
                    # if we find 'good' values add to storage
                    cond1 = np.abs(popt[1] - xpixi) < wfit
                    if cond1 and cond2:
                        amp[good[it]] = popt[0]
                        pixel_m[good[it]] = popt[1]
                        ewidth[good[it]] = popt[2]
                        nsig[good[it]] = popt[0] / rms
                        # line is valid
                        valid_lines += 1
                # ignore any bad lines
                except RuntimeError:
                    pass
        # log progress: Order {0}/{1} Fiber {2} Valid lines: {3}/{4} (type={5})
        eargs = [order_num, nbo - 1, fiber, valid_lines, len(order_waves),
                 fibtype]
        WLOG(params, '', textentry('40-017-00051', args=eargs))

    # lines that are not at a high enough SNR are flagged as NaN
    # we do NOT remove these lines as we want all tables to have
    # exactly the same length
    with warnings.catch_warnings(record=True) as _:
        bad = ~(nsig > nsig_min)
    nsig[bad] = np.nan
    ewidth[bad] = np.nan
    amp[bad] = np.nan
    pixel_m[bad] = np.nan
    wave_m[bad] = np.nan
    # calculate the difference
    diffpix = pixel_m - list_pixels
    # ----------------------------------------------------------------------
    # Plot the expected lines vs measured line positions
    # ----------------------------------------------------------------------
    # debug plot expected lines vs measured positions
    recipe.plot('WAVEREF_EXPECTED', orders=list_orders, wavemap=list_waves,
                diff=diffpix, fiber=fiber, nbo=nbo, fibtype=fibtype,
                iteration=iteration)
    # ----------------------------------------------------------------------
    # Create table to store them in
    # ----------------------------------------------------------------------
    columnnames = ['WAVE_REF', 'WAVE_MEAS', 'PIXEL_REF', 'PIXEL_MEAS',
                   'ORDER', 'WFIT', 'EWIDTH_MEAS', 'AMP_MEAS', 'NSIG',
                   'DIFF', 'PEAK_NUMBER']
    columnvalues = [list_waves, wave_m, list_pixels, pixel_m, list_orders,
                    list_wfit, ewidth, amp, nsig, diffpix, peak_number]
    # make table
    table = drs_table.make_table(params, columnnames, columnvalues)
    # return table
    return table


def calc_wave_sol(params: ParamDict, recipe: DrsRecipe,
                  hclines: Table, fplines: Table,
                  nbxpix: int, fit_cavity: bool = True,
                  fit_achromatic: bool = True,
                  cavity_update: Union[np.ndarray, None] = None,
                  wavesol_fit_degree: Union[int, None] = None,
                  cavity_fit_degree: Union[int, None] = None,
                  nsig_cut: Union[float, None] = None):
    """
    Calculate the wave solution using a table of hclines and fplines

    each lines table (hclines and fplines) must contain the following columns:
        - WAVE_REF - the line catalogue reference wavelength
        - WAVE_MEAS - the measured line wavelength (can be empty)
        - PIXEL_MEAS - the measured pixel position
        - ORDER - the order each line belongs to
        - NSIG - the uncertainty on the line measurement
        - PEAK_NUMBER - the peak number (blank for HC)

    Original Author: Etienne Artigau

    :param params: ParamDict, parameter dictionary of constants
    :param recipe: DrsRecipe instance, the recipe that called this function
    :param hclines: Table, HC line table (see above description)
    :param fplines: Table, FP line table (see above description)
    :param nbxpix: int, the number of pixels in the along-order direction
    :param fit_cavity: bool, if True fits cavity width
    :param fit_achromatic: bool, if True fits achromatic part of cavity
    :param cavity_update: np.array or None - if sets the cavity file
    :param wavesol_fit_degree: int, the polynomial degree fit order for the
                               wave solution fit
    :param cavity_fit_degree: int, the polynomial degree fit order for the
                              cavity fit

    :param nsig_cut: int, the number of sigmas to cut in the robust polyfits

    :return: ParamDict, the wave properties
    """
    # set function name
    func_name = display_func(params, 'calc_wave_sol', __NAME__)
    # -------------------------------------------------------------------------
    # get parameters from params / inputs
    # -------------------------------------------------------------------------
    # Define the wave solution polynomial fit degree
    wavesol_fit_degree = pcheck(params, 'WAVE_WAVESOL_FIT_DEGREE',
                                func=func_name, override=wavesol_fit_degree)
    # Define the cavity fit polynomial fit degree for wave solution
    cavity_fit_degree = pcheck(params, 'WAVE_CAVITY_FIT_DEGREE',
                               func=func_name, override=cavity_fit_degree)
    # Define the number of sigmas to use in wave sol robust fits
    nsig_cut = pcheck(params, 'WAVE_NSIG_CUT', func=func_name,
                      override=nsig_cut)
    # Define the minimum number of HC lines in an order to try to find
    #   absolute numbering
    min_hc_lines = pcheck(params, 'WAVE_MIN_HC_LINES', func=func_name)
    # Define the maximum offset in FP peaks to explore when FP peak counting
    max_fp_c_offset = pcheck(params, 'WAVE_MAX_FP_COUNT_OFFSET', func=func_name)
    # Define the number of iterations required to converge the FP peak counting
    #   offset loop
    fp_count_offset_iterations = pcheck(params, 'WAVE_FP_COUNT_OFFSET_ITRS',
                                        func=func_name)
    # Define the number of iterations required to converge on a cavity fit
    #  (first time this is done)
    cavity_fit_iterations1 = pcheck(params, 'WAVE_CAVITY_FIT_ITRS1',
                                    func=func_name)
    # Define the number of iterations required to check order offset
    order_offset_iterations = pcheck(params, 'WAVE_ORDER_OFFSET_ITRS',
                                     func=func_name)
    # Define the maximum bulk offset of lines in a order can have
    max_ord_bulk_offset = pcheck(params, 'WAVE_MAX_ORDER_BULK_OFFSET',
                                 func=func_name)
    # Define the required precision that the cavity width change must converge
    #   to (will be a fraction of the error)
    cavity_change_err_thres = pcheck(params, 'WAVE_CAVITY_CHANGE_ERR_THRES',
                                     func=func_name)
    # Define the number of iterations required to converge on a cavity fit
    #  (second time this is done)
    cavity_fit_iterations2 = pcheck(params, 'WAVE_CAVITY_FIT_ITRS2',
                                    func=func_name)
    # Define the odd ratio that is used in generating the weighted mean
    odd_ratio = pcheck(params, 'WAVE_HC_VEL_ODD_RATIO', func=func_name)
    # Define the number of iterations required to do the final fplines
    #   wave solution
    fwavesol_iterations = pcheck(params, 'WAVE_FWAVESOL_ITRS', func=func_name)
    # -------------------------------------------------------------------------
    # setup parameters
    # -------------------------------------------------------------------------
    # order list
    orders = np.unique(fplines['ORDER'])
    # -------------------------------------------------------------------------
    # only keep pixels that have finite positions
    # it is fine to have orders with no valid lines
    hclines = hclines[np.isfinite(hclines['PIXEL_MEAS'])]
    fplines = fplines[np.isfinite(fplines['PIXEL_MEAS'])]
    # -------------------------------------------------------------------------
    # to get started, we assume that we do not know the wavelength of FP lines
    fplines['WAVE_MEAS'] = np.repeat(np.nan, len(fplines))

    # copy out of table (for consistence) - only update the table at the end
    fpl_order = np.array(fplines['ORDER'])
    fpl_wave_meas = np.array(fplines['WAVE_MEAS'])
    fpl_pix_meas = np.array(fplines['PIXEL_MEAS'])
    fpl_peak_num = np.array(fplines['PEAK_NUMBER'])
    fpl_wave_ref = np.array(fplines['WAVE_REF'])

    hcl_order = np.array(hclines['ORDER'])
    hcl_wave_meas = np.array(hclines['WAVE_MEAS'])
    hcl_pix_meas = np.array(hclines['PIXEL_MEAS'])
    hcl_wave_ref = np.array(hclines['WAVE_REF'])
    hcl_nsig= np.array(hclines['NSIG'])

    # -------------------------------------------------------------------------
    # Part 1: We do not know the wavelength of FP lines --> measure it for
    #         all FP lines (using the HC lines if there are enough)
    # -------------------------------------------------------------------------
    # loop around orders
    for order_num in orders:
        # log that we are processing an order
        # TODO: move to language database
        WLOG(params, '', 'Measure the wavelength Order {0}'.format(order_num))
        # find the hc and fp lines for the current oder
        good_fp = fpl_order == order_num
        good_hc = hcl_order == order_num
        # get the fplines for this order
        ordfp_pix_meas = fpl_pix_meas[good_fp]
        ordfp_peak_num = fpl_peak_num[good_fp]
        # mask the hclines
        ordhc_pix_meas = hcl_pix_meas[good_hc]
        ordhc_wave_ref = hcl_wave_ref[good_hc]
        # ---------------------------------------------------------------------
        # express step in pixels as a polynomial fit. This is used to count
        # fp peaks afterward
        xfit1 = ordfp_pix_meas[1:]
        yfit1 = ordfp_pix_meas[1:] - ordfp_pix_meas[:-1]
        # fit the step between FP lines
        fit_step, _ = mp.robust_polyfit(xfit1, yfit1, wavesol_fit_degree,
                                        nsig_cut)
        # ---------------------------------------------------------------------
        # counting steps backward
        # maybe first step is wrong, we'll see later by x-matching with HC lines
        # after this step, we know that lines within the order have
        # *relative* numbers that are ok
        for step_fp in range(1, len(ordfp_pix_meas)):
            # find expected step between previous and current FP peak
            # We start numbering at 1 as the 0th serves as a relative
            # starting point
            diff = ordfp_pix_meas[step_fp] - ordfp_pix_meas[step_fp - 1]
            dfit = np.polyval(fit_step, ordfp_pix_meas[step_fp - 1])
            dnum = diff / dfit
            # dnum is always very close to an integer value, we round it
            # we subtract the steps, FP peaks go in decreasing number
            rdnum = np.round(dnum)
            ordfp_peak_num[step_fp] = ordfp_peak_num[step_fp - 1] - rdnum
        # ---------------------------------------------------------------------
        # if we don't have more than "min_hc_lines" hc lines, we store the
        #   new values and skip to next order
        # ---------------------------------------------------------------------
        if np.sum(good_hc) <= min_hc_lines:
            # put into the table
            fpl_pix_meas[good_fp] = ordfp_pix_meas
            fpl_peak_num[good_fp] = ordfp_peak_num
            # skip to next order
            continue
        # ---------------------------------------------------------------------
        # if we have more than "min_hc_lines" hc lines, we try to find
        #     the absolute numbering
        # ---------------------------------------------------------------------
        # we fit an approximate wavelength solution
        hc_wave_fit, _ = mp.robust_polyfit(ordhc_pix_meas, ordhc_wave_ref,
                                           wavesol_fit_degree, nsig_cut)
        # we find the steps in FP lines at the position of all HC lines
        step_hc = np.polyval(fit_step, ordhc_pix_meas)
        # get the derivative of the wave fit
        d_hc_wave_fit = np.polyder(hc_wave_fit)
        # get the step in waves
        step_hc_wave = np.polyval(d_hc_wave_fit, ordhc_pix_meas) * step_hc
        # -----------------------------------------------------------------
        # convert step in cavity through the order. We assume a constant
        #    cavity through the order
        cavity_per_order = mp.nanmedian(ordhc_wave_ref ** 2 / step_hc_wave)
        # copy this
        cavity_per_order0 = np.array(cavity_per_order)
        # -----------------------------------------------------------------
        # we explore integer offset in FP peak counting and find the
        #     offset that defines the wavelength solution leading to the
        #     smallest RMS between predicted and catalog HC peak positions
        offset = np.arange(-max_fp_c_offset, max_fp_c_offset + 1)
        # set up storage of sigmas
        osigmas = np.zeros_like(offset, dtype=float)
        # loop around offsets
        for o_it in range(len(offset)):
            # reset the cavity per order
            cavity_per_order = np.array(cavity_per_order0)
            # get the peak number offset
            peak_num_offset = ordfp_peak_num + offset[o_it]
            # get a temporary wave sol
            wave_tmp = cavity_per_order / peak_num_offset
            # fit this wave solution for FP lines
            ofpwave_fit = np.polyfit(ordfp_pix_meas, wave_tmp,
                                     wavesol_fit_degree)
            # -----------------------------------------------------------------
            # loop iteratively to converge cavity per order
            for _ in range(fp_count_offset_iterations):
                # get a temporary wave sol
                wave_tmp = cavity_per_order / peak_num_offset
                # fit this wave solution for FP lines
                ofpwave_fit = np.polyfit(ordfp_pix_meas, wave_tmp,
                                         wavesol_fit_degree)
                # fit the inverse for the hc lines
                ohcwave_fit = np.polyval(ofpwave_fit, ordhc_pix_meas)
                # work out the median of the residuals to the fit for the
                #   hc lines
                med_hc_res = mp.nanmedian(1 - ordhc_wave_ref / ohcwave_fit)
                # update the cavity per order by 1 - the median of the res
                cavity_per_order = cavity_per_order * (1 - med_hc_res)
            # -----------------------------------------------------------------
            # if the inverse for the hc lines once more
            ohcwave_fit = np.polyval(ofpwave_fit, ordhc_pix_meas)
            # calculate the hc residuals
            hc_res = 1 - ordhc_wave_ref / ohcwave_fit
            # calculate the offset sigma for this offset (and express as
            #   velocity)
            osigma = mp.estimate_sigma(hc_res * speed_of_light_ms, 1.0)
            # store in osgimas
            osigmas[o_it] = osigma
        # ---------------------------------------------------------------------
        # we apply the offset that leads to the smallest HC (o-c) RMS
        ordfp_peak_num = ordfp_peak_num + offset[np.argmin(osigmas)]
        # get a temporary wave sol
        wave_tmp = cavity_per_order / ordfp_peak_num
        # ---------------------------------------------------------------------
        # we find the best cavity length estimate
        for _ in range(cavity_fit_iterations1):
            # we force the cavity length to lead to a median HC peak position
            # error of zero.
            # we could use a better sigma-clipping, but this is hard with a
            # small number of lines
            # -----------------------------------------------------------------
            # get a temporary wave sol
            wave_tmp = cavity_per_order / ordfp_peak_num
            # fit this wave solution
            wave_fit = np.polyfit(ordfp_pix_meas, wave_tmp, wavesol_fit_degree)
            # inverse this fit using the HC lines
            ohcwave_fit = np.polyval(wave_fit, ordhc_pix_meas)
            # work out the residuals
            med_hc_res = mp.nanmedian(1 - ordhc_wave_ref / ohcwave_fit)
            # update the cavity per order by 1 - the median of the res
            cavity_per_order = cavity_per_order * (1 - med_hc_res)
        # ---------------------------------------------------------------------
        # we now have a best-guess of the wavelength solution, we update
        #  the WAVE_MEAS in the FP line list. This will be used to constrain the
        # cavity length below
        wave_fit = np.polyfit(ordfp_pix_meas, wave_tmp, wavesol_fit_degree)
        # re-fit wave solution on all lines --> measured wave sol
        ordfp_wave_meas = np.polyval(wave_fit, ordfp_pix_meas)
        # ---------------------------------------------------------------------
        # put into the table. If we had enough HC lines, the WAVE_MEAS has
        #    been updated if not, at least the FP peak counting is valid.
        fpl_pix_meas[good_fp] = ordfp_pix_meas
        fpl_peak_num[good_fp] = ordfp_peak_num
        fpl_wave_meas[good_fp] = ordfp_wave_meas
    # -------------------------------------------------------------------------
    # save some information for plotting later
    fp_peak_num_1 = np.array(fpl_peak_num)
    fp_wave_meas_1 = np.array(fpl_wave_meas)
    fp_wave_ref_1 = np.array(fpl_wave_ref)
    # -------------------------------------------------------------------------
    # Loop 2: Find offsets
    # -------------------------------------------------------------------------
    # loop around order offset iterations
    for o_jt in range(order_offset_iterations):
        # log that we are processing an order
        # TODO: move to language database
        msg = 'Locating offsets: iteartion {0}/ {1}'
        margs = [o_jt + 1, order_offset_iterations]
        WLOG(params, '', msg.format(*margs))
        # loop around orders
        # skip first order, and check order to order if the cavity
        # is consistent with previous. Order=1 is compared to Order=0, then
        # Order=2 to Order=1...
        for order_num in orders[1:]:
            # get mask for previous order
            good_prev_fp = fpl_order == order_num - 1
            good_fp = fpl_order == order_num
            # get vectors for this order
            ordfp_wave_meas = fpl_wave_meas[good_fp]
            ordfp_peak_num = fpl_peak_num[good_fp]
            # get vectors for previous order
            prevfp_wave_meas = fpl_wave_meas[good_prev_fp]
            prevfp_peak_num = fpl_peak_num[good_prev_fp]
            # -----------------------------------------------------------------
            # current peak numbers if you take the previous order cavity
            #    length and assume it's the same of current order while using
            #    the current order wavelength solution.
            current_numbering = ordfp_peak_num
            # The median between the two should be close to zero
            #    (extrapolated_numbering can be float, not int as
            #     current_numbering). If the is a mis-counting, then you get
            #     a median very close to an integer value. This tells you the
            #     offset to be applied to have a consistent cavity length
            # get the median of previous order
            med_prev = mp.nanmedian(prevfp_wave_meas * prevfp_peak_num)
            # user median of previous order to extrapolate to this order
            extrapolated_numbering = med_prev / ordfp_wave_meas
            # -----------------------------------------------------------------
            # work out the offset between current numbering and those
            #   extrapolated from previous order
            offset = mp.nanmedian(current_numbering - extrapolated_numbering)
            # subtract this offset off the order values
            if np.isfinite(offset):
                ordfp_peak_num = ordfp_peak_num - offset
                # add the peak num back to fplines
                fpl_peak_num[good_fp] = ordfp_peak_num
        # ---------------------------------------------------------------------
        # now that we have patched the order-to-order glitches, we look for
        #     a bulk offset in the counts that minimizes the dispersion in
        #     cavity length.
        global_offset = np.arange(-max_ord_bulk_offset, max_ord_bulk_offset + 1)
        # set up storage of sigmas
        gosigmas = np.zeros_like(global_offset, dtype=float)
        # loop around offsets
        for goffset in range(len(global_offset)):
            # apply global offset
            peak_num = fpl_peak_num + global_offset[goffset]
            # calculate cavity
            cavity_widths = fpl_wave_meas * peak_num
            # work out sigma
            gosigmas[goffset] = mp.estimate_sigma(cavity_widths, 1.0)
        # best guess at offset
        best_offset = global_offset[np.argmin(gosigmas)]
        # update peak number with best offset (from gosigmas)
        fpl_peak_num = fpl_peak_num + best_offset
    # -------------------------------------------------------------------------
    # now we have valid numbering and best-guess WAVE_MEAS, we find the
    #    cavity length
    wavepeak = fpl_wave_meas * fpl_peak_num
    cavity, _ = mp.robust_polyfit(fpl_wave_meas, wavepeak,
                                  cavity_fit_degree, nsig_cut)
    # -------------------------------------------------------------------------
    # save some information for plotting later
    fp_peak_num_2 = np.array(fpl_peak_num)
    fp_wave_meas_2 = np.array(fpl_wave_meas)
    fp_wave_ref_2 = np.array(fpl_wave_ref)
    # -------------------------------------------------------------------------
    # plot the wavelength vs cavity width plot
    recipe.plot('WAVE_WL_CAV', cavity=cavity,
                fp_wave_meas1=fp_wave_meas_1, fp_peak_num_1=fp_peak_num_1,
                fp_wave_meas2=fp_wave_meas_2, fp_peak_num_2=fp_peak_num_2,
                fp_wave_ref_1=fp_wave_ref_1, fp_wave_ref_2=fp_wave_ref_2)
    # -------------------------------------------------------------------------
    # if fit_cavity is False and a file exists we load this file
    # (otherwise we save this cavity file later)
    if not fit_cavity:
        # deal with having a cavity update file only if it existed
        if cavity_update is not None:
            # update the cavity array
            cavity = np.array(cavity_update)
    # -------------------------------------------------------------------------
    # copy the cavity fit
    cavity0 = np.array(cavity)
    # set the mean2error to infinite
    mean2error = np.inf
    # set up diff_hc and hc sigma
    diff_hc = np.zeros_like(hcl_wave_meas)
    hcsigma = np.zeros_like(hcl_wave_meas)
    # -------------------------------------------------------------------------
    # we change the achromatic cavity length term to force HC peaks to have a
    #    zero velocity error.

    # loop until
    # TODO: PROBLEM: This currently diverges
    #	 Mean HC position  -0.20+-0.89 m/s
    #	 Mean HC position  -0.42+-0.89 m/s
    #	 Mean HC position  -0.89+-0.89 m/s
    #	 Mean HC position  -1.90+-0.89 m/s
    #	 Mean HC position  -4.04+-0.88 m/s
    #	 Mean HC position  -8.61+-0.89 m/s
    #	 Mean HC position -18.30+-0.88 m/s
    #	 Mean HC position -38.84+-0.95 m/s
    #	 Mean HC position -79.57+-1.17 m/s
    #	 Mean HC position -148.08+-1.68 m/s
    #	 Mean HC position -236.02+-2.41 m/s
    #	 Mean HC position -333.31+-3.24 m/s
    #	 Mean HC position -435.13+-4.15 m/s
    #	 Mean HC position -538.93+-5.09 m/s
    #	 Mean HC position -643.93+-6.04 m/s
    #	 Mean HC position -749.71+-7.01 m/s
    #	 Mean HC position -855.97+-7.97 m/s
    #	 Mean HC position -962.71+-8.92 m/s
    #	 Mean HC position -1069.99+-9.90 m/s
    #	 Mean HC position -1177.40+-10.89 m/s
    count = 0
    while mean2error > cavity_change_err_thres and count < 20:
        # get the proper cavity length from the cavity polynomial
        for _ in range(cavity_fit_iterations2):
            # update wave ref based on the fit
            fpl_wave_ref = np.polyval(cavity, fpl_wave_ref) / fpl_peak_num
        # ---------------------------------------------------------------------
        # get the wavelength solution for the order and the HC line position
        #     that it implies. The diff between the HC position found here and
        #     the catalog one is used to change the cavity length
        # ---------------------------------------------------------------------
        # loop around order
        for order_num in orders:
            # find the hc and fp lines for the current oder
            good_fp = fpl_order == order_num
            good_hc = hcl_order == order_num
            # get the fplines for this order
            ordfp_pix_meas = fpl_pix_meas[good_fp]
            ordfp_wave_ref = fpl_wave_ref[good_fp]
            # mask the hclines
            ordhc_pix_meas = hcl_pix_meas[good_hc]
            # get wave fit
            wave_fit, _ = mp.robust_polyfit(ordfp_pix_meas, ordfp_wave_ref,
                                            wavesol_fit_degree, nsig_cut)
            # update wave measure from this fit
            fpl_wave_meas[good_fp] = np.polyval(wave_fit, ordfp_pix_meas)
            # if we have some HC lines update these too
            if np.sum(good_hc) > 0:
                hcl_wave_meas[good_hc] = np.polyval(wave_fit, ordhc_pix_meas)
        # ---------------------------------------------------------------------
        # in velocity, diff between measured and catalog HC line positions
        res = hcl_wave_meas / hcl_wave_ref
        diff_hc = (1 - res) * speed_of_light_ms
        # model of the errors in the HC line positions. We assume that
        # they decrease as 1/NSIG
        hcsigma = mp.estimate_sigma(diff_hc * hcl_nsig) / hcl_nsig
        # get smart mean of the velocity error
        mean_hc_vel, err_hc_vel = mp.odd_ratio_mean(diff_hc, hcsigma,
                                                    odd_ratio=odd_ratio)
        # ---------------------------------------------------------------------
        # if we are allowed to change the achromatic cavity length, then
        #    we do it, else we just keep track of how much we would have
        #    changed it.
        if fit_achromatic:
            # recalculate mean to error ratio
            mean2error = np.abs(mean_hc_vel / err_hc_vel)
            # update last coefficient of the cavity fit
            cavity[-1] = cavity[-1] * (1 + mean2error / speed_of_light_ms)
        # else set the mean2error to zero
        else:
            mean2error = 0.0
        # ---------------------------------------------------------------------
        # TODO: move to language database
        msg = 'Iteration {0}: Mean HC position {1:6.2f}+-{2:.2f} m/s'
        margs = [count + 1, mean_hc_vel, err_hc_vel]
        WLOG(params, '', msg.format(*margs))

        count += 1
    # -------------------------------------------------------------------------
    # TODO: move to language database
    msg = 'Change in cavity length {0:6.2f} nm'
    margs = [cavity[-1] - cavity0[-1]]
    WLOG(params, '', msg.format(*margs))
    # -------------------------------------------------------------------------
    # plot the wavelength hc diff histograms
    recipe.plot('WAVE_HC_DIFF_HIST', diff_hc=diff_hc, error=hcsigma)
    # -------------------------------------------------------------------------
    # update wave solution for fplines
    for _ in range(fwavesol_iterations):
        # get wave / peak
        wavepeak = fpl_wave_ref / fpl_peak_num
        # update fplines
        fpl_wave_ref = np.polyval(cavity, wavepeak)
    # -------------------------------------------------------------------------
    # Construct the wavelength coefficients / wave map
    # -------------------------------------------------------------------------
    wave_coeffs = np.zeros([len(orders), wavesol_fit_degree])
    wave_map = np.zeros([len(orders), nbxpix])
    # get xpix
    xpix = np.arange(nbxpix)
    # loop around orders
    for order_num in orders:
        # get the fp lines for this order
        good_fp = fpl_order == order_num
        # get fpline vectors
        ordfp_pix_meas = fpl_pix_meas[good_fp]
        ordfp_wave_ref = fpl_wave_ref[good_fp]
        # fit the solution to this order
        ord_wave_sol, _ = mp.robust_polyfit(ordfp_pix_meas, ordfp_wave_ref,
                                            wavesol_fit_degree, nsig_cut)
        # add to wave coefficients
        wave_coeffs[order_num] = ord_wave_sol[::-1]
        # generate wave map for order
        wave_map[order_num] = np.polyval(ord_wave_sol, xpix)
    # -------------------------------------------------------------------------
    # update the fplines and hclines tables
    fplines['WAVE_MEAS'] = fpl_wave_meas
    fplines['PIXEL_MEAS'] = fpl_pix_meas
    fplines['PEAK_NUMBER'] = fpl_peak_num
    fplines['WAVE_REF'] = fpl_wave_ref
    hclines['WAVE_MEAS'] = hcl_wave_meas
    hclines['PIXEL_MEAS'] = hcl_pix_meas
    hclines['WAVE_REF'] = hcl_wave_ref
    hclines['NSIG'] = hcl_nsig
    # -------------------------------------------------------------------------
    # construct wave properties
    # -------------------------------------------------------------------------
    wprops = ParamDict()
    wprops['COEFFS'] = wave_coeffs
    wprops['WAVEMAP'] = wave_map
    wprops['NBO'] = len(orders)
    wprops['DEG'] = wavesol_fit_degree
    wprops['NBPIX'] = nbxpix
    wprops['CAVITY'] = cavity
    wprops['CAVITY_DEG'] = cavity_fit_degree
    # set source
    keys = ['WAVEMAP', 'NBO', 'DEG', 'COEFFS', 'NBPIX', 'CAVITY', 'CAVITY_DEG']
    wprops.set_sources(keys, func_name)
    # return wave properties
    return wprops


def process_fibers(params: ParamDict, recipe: DrsRecipe,
                   mprops: ParamDict, fp_outputs: Dict[str, DrsFitsFile],
                   hc_outputs: Dict[str, DrsFitsFile]) -> Dict[str, ParamDict]:
    """
    Process all fibers (skip for master)

    other fibers are calculated similarly to master fiber but with
        fit_cavity = False
        fit_achromatic = False

    :param params: ParamDict, parameter dictionary of constants
    :param recipe: DrsRecipe instance, the recipe calling this function
    :param mprops: ParamDict, the wave properties of the master file
    :param fp_outputs: Dict of fp file inputs (e2ds files) for each fiber
    :param hc_outputs: Dict of hc file inputs (e2ds files) for each fiber

    :return: Dict of wave properties (ParamDict) for each fiber
    """
    # set function name
    func_name = display_func(params, 'process_fibers', __NAME__)
    # set up storage
    solutions = dict()
    # get wave master file (controller fiber)
    master_fiber = pcheck(params, 'WAVE_MASTER_FIBER', func=func_name)
    plot_order = pcheck(params, 'WAVE_FIBER_COMP_PLOT_ORD', func=func_name)
    # get the cavity file
    cavity = mprops['CAVITY']
    # get the master fiber lines
    mhcl = mprops['HCLINES']
    mfpl = mprops['FPLINES']
    # get the fiber types from a list parameter (or from inputs)
    fiber_types = drs_image.get_fiber_types(params)
    # loop around fibers
    for fiber in fiber_types:
        # log that we are processing fiber
        wargs = [fiber, master_fiber]
        WLOG(params, 'info', textentry('40-017-00043', args=wargs))
        # get the e2ds_files for this fiber
        hc_e2ds_file = hc_outputs[fiber]
        fp_e2ds_file = fp_outputs[fiber]
        # ---------------------------------------------------------------------
        # skip all this if this is the master fiber (its all been done)
        if fiber == master_fiber:
            solutions[fiber] = mprops
        # ---------------------------------------------------------------------
        # generate the hc reference lines
        hcargs = dict(e2dsfile=hc_e2ds_file, wavemap=mprops['WAVEMAP'],
                      hclines=mhcl, fplines=mfpl, iteration=1)
        hclines = calc_wave_lines(params, recipe, **hcargs)
        # generate the fp reference lines
        fpargs = dict(e2dsfile=fp_e2ds_file, wavemap=mprops['WAVEMAP'],
                      cavity_poly=cavity, iteration=1)
        fplines = calc_wave_lines(params, recipe, **fpargs)
        # ---------------------------------------------------------------------
        # other fiber + master wave setup
        fit_cavity = False
        fit_achromatic = False
        # calculate wave solution
        wprops = calc_wave_sol(params, recipe, hclines, fplines, fit_cavity,
                               fit_achromatic, cavity_update=cavity)
        # ---------------------------------------------------------------------
        # regenerate the hc reference lines
        hcargs = dict(e2dsfile=hc_e2ds_file, wavemap=mprops['WAVEMAP'],
                      hclines=mhcl, fplines=mfpl, iteration=2)
        hclines = calc_wave_lines(params, recipe, **hcargs)
        # re generate the fp reference lines
        fpargs = dict(e2dsfile=fp_e2ds_file, wavemap=mprops['WAVEMAP'],
                      cavity_poly=cavity, iteration=2)
        fplines = calc_wave_lines(params, recipe, **fpargs)
        # add lines to wave properties
        wprops['HCLINES'] = hclines
        wprops['FPLINES'] = fplines
        # add wave time and file
        wprops['WAVETIME'] = fp_e2ds_file.get_hkey('MJDMID', dtype=float)
        wprops['WAVEFILE'] = 'None'
        # set sources
        skeys = ['HCLINES', 'FPLINES', 'WAVETIME', 'WAVEFILE']
        wprops.set_sources(skeys, func_name)
        # ---------------------------------------------------------------------
        # append wave properties to solutions storage
        solutions[fiber] = wprops
    # ----------------------------------------------------------------------
    # plot comparison between master fiber and fibers
    # ----------------------------------------------------------------------
    recipe.plot('WAVE_FIBER_COMPARISON', solutions=solutions, master=mprops,
                order=None, masterfiber=master_fiber)
    recipe.plot('WAVE_FIBER_COMP', solutions=solutions, master=mprops,
                order=plot_order, masterfiber=master_fiber)
    recipe.plot('SUM_WAVE_FIBER_COMP', solutions=solutions, master=mprops,
                order=plot_order, masterfiber=master_fiber)
    # ----------------------------------------------------------------------
    # return all the solutions for all fibers
    return solutions


def update_smart_fp_mask(params: ParamDict, cavity: np.ndarray, **kwargs):
    # set function name
    func_name = display_func(params, 'update_smart_fp_mask', __NAME__)
    # get constants from params
    update_mask = pcheck(params, 'WAVE_CCF_UPDATE_MASK', 'update_mask', kwargs,
                         func_name)
    assetdir = pcheck(params, 'DRS_DATA_ASSETS', 'assetsdir', kwargs, func_name)
    ccfpath = pcheck(params, 'WAVE_CCF_MASK_PATH', 'ccfpath', kwargs, func_name)
    ccfmask = pcheck(params, 'WAVE_CCF_MASK', 'ccfmask', kwargs, func_name)
    dvwidth = pcheck(params, 'WAVE_CCF_SMART_MASK_WIDTH', 'dvwidth',
                     kwargs, func_name)
    mask_units = pcheck(params, 'WAVE_CCF_MASK_UNITS', 'mask_units', kwargs,
                        func_name)
    minlambda = pcheck(params, 'WAVE_CCF_SMART_MASK_MINLAM', 'minlambda',
                       kwargs, func_name)
    maxlambda = pcheck(params, 'WAVE_CCF_SMART_MASK_MAXLAM', 'maxlambda',
                       kwargs, func_name)
    nmin = pcheck(params, 'WAVE_CCF_SMART_MASK_TRIAL_NMIN', 'nmin', kwargs,
                  func_name)
    nmax = pcheck(params, 'WAVE_CCF_SMART_MASK_TRIAL_NMAX', 'nmax', kwargs,
                  func_name)
    threshold = pcheck(params, 'WAVE_CCF_SMART_MASK_DWAVE_THRES', 'threshold',
                       kwargs, func_name)
    # if we don't want to update the mask then don't
    if not update_mask:
        return
    # ----------------------------------------------------------------------
    # construct output filename
    outfile = os.path.join(assetdir, ccfpath, ccfmask)
    # ----------------------------------------------------------------------
    # start with a broader range of FP N values and clip later on
    n_fp_fpeak = np.arange(nmin, nmax)
    # placeholder for wavelength, needs to be iterated-on with
    #    the cavity length polynomial
    # the starting wavelength is the midpoint between the extremities of
    #    the domain
    wave_fp_peak = np.repeat(np.mean([minlambda, maxlambda]), len(n_fp_fpeak))
    # ----------------------------------------------------------------------
    # we perform the following loop
    #
    # Take the wavelength and derive a cavity length
    # Take the Nth peak and derive a line wavelength from the
    # cavity length
    # Take the new wavelength and dereive a new cavity length
    # Find an update wavelength for the Nth peak
    #  .... converge down to a 'threshold' error in wavelength
    dwave = np.inf
    while abs(dwave) > threshold:
        # keep track of the central line to check convergence
        prev = wave_fp_peak[len(wave_fp_peak) // 2]
        # derive a new wavelength for each fp peak
        wave_fp_peak = np.polyval(cavity, wave_fp_peak) / n_fp_fpeak
        # check convergnce
        dwave = prev - wave_fp_peak[len(wave_fp_peak) // 2]
    # ----------------------------------------------------------------------
    # keep lines within the domain
    keep = (wave_fp_peak > minlambda) & (wave_fp_peak < maxlambda)
    # ----------------------------------------------------------------------
    # apply keep mask to wavelength solution and n peak
    wave_fp_peak = wave_fp_peak[keep]
    # ----------------------------------------------------------------------
    # get unit object from mask units string
    try:
        unit = getattr(uu, mask_units)
    except Exception as e:
        # log error
        eargs = [mask_units, type(e), e, func_name]
        WLOG(params, 'error', textentry('09-020-00002', args=eargs))
        return
    # add units
    wave_fp_peak = wave_fp_peak * unit
    # convert to nanometers
    wave_fp_peak = wave_fp_peak.to(uu.nm).value
    # ----------------------------------------------------------------------
    # calculate wavelength bounds of line
    wavelower = wave_fp_peak * (1 - 0.5 * dvwidth / speed_of_light)
    waveupper = wave_fp_peak * (1 + 0.5 * dvwidth / speed_of_light)
    weights = np.repeat(1.0, len(wavelower))
    # ----------------------------------------------------------------------
    # Create table to store them in
    # ----------------------------------------------------------------------
    columnnames = ['WLOW', 'WHIGH', 'WEIGHT']
    columnvalues = [wavelower, waveupper, weights]
    # make table
    table = drs_table.make_table(params, columnnames, columnvalues)
    # print that we are saving smart fp header
    WLOG(params, '', textentry('40-017-00053', args=outfile))
    # write smart mask table to file
    drs_table.write_table(params, table, outfile, fmt='ascii.fast_no_header')


# =============================================================================
# Define writing functions
# =============================================================================
def wave_quality_control(params: ParamDict, solutions: Dict[str, ParamDict],
                         rvprops: Dict[str, ParamDict]) -> List[list]:
    """
    Quality control for the wave solutions (all fibers)

    :param params: ParamDict, parameter dictionary of constants
    :param solutions: list of ParamDicts, wave properties for each fiber
    :param rvprops: list of ParamDicts, rv properties for each fiber

    :return: list of lists - the quality control lists (qc_names,
             qc_values, qc_logic, qc_pass)
    """
    # set function name
    func_name = display_func(params, 'wave_quality_control', __NAME__)
    # get parameters from params / inputs
    master_fiber = pcheck(params, 'WAVE_MASTER_FIBER', func=func_name)
    rv_thres = pcheck(params, 'WAVE_CCF_RV_THRES_QC', func=func_name)
    # get the fiber types from a list parameter (or from inputs)
    fiber_types = drs_image.get_fiber_types(params)
    # --------------------------------------------------------------
    # set passed variable and fail message list
    fail_msg = []
    qc_names, qc_values, qc_logic, qc_pass = [], [], [], []
    # --------------------------------------------------------------
    # check the difference between consecutive orders is always positive
    # get the differences
    # --------------------------------------------------------------
    # loop around fibers
    for fiber in fiber_types:
        wprops = solutions[fiber]
        # --------------------------------------------------------------------
        # y-direction (across orders)
        # --------------------------------------------------------------------
        # get wave difference
        wave_diff = wprops['WAVEMAP'][1:] - wprops['WAVEMAP'][:-1]
        if mp.nanmin(wave_diff) < 0:
            fail_msg.append(textentry('40-017-00030'))
            qc_pass.append(0)
        else:
            qc_pass.append(1)
        # add to qc header lists
        qc_values.append(mp.nanmin(wave_diff))
        qc_names.append('MIN YWAVE DIFF {0}'.format(fiber))
        qc_logic.append('MIN YWAVE DIFF {0} < 0'.format(fiber))
        # --------------------------------------------------------------------
        # x-direction (along orders)
        # --------------------------------------------------------------------
        # get wave difference
        wave_diff = wprops['WAVEMAP'][:, 1:] - wprops['WAVEMAP'][:, :-1]
        if mp.nanmin(wave_diff) < 0:
            fail_msg.append(textentry('40-017-00055'))
            qc_pass.append(0)
        else:
            qc_pass.append(1)
        # add to qc header lists
        qc_values.append(mp.nanmin(wave_diff))
        qc_names.append('MIN XWAVE DIFF {0}'.format(fiber))
        qc_logic.append('MIN XWAVE DIFF {0} < 0'.format(fiber))

    # --------------------------------------------------------------
    # rv quality controls between fibers
    # --------------------------------------------------------------
    # get master RV [km/s] --> [m/s]
    master_rv = rvprops[master_fiber]['MEAN_RV'] * 1000
    # loop around fibers
    for fiber in fiber_types:
        # do not compare master to master
        if fiber == master_fiber:
            continue
        # get rv for this fiber [km/s] --> [m/s]
        rvfiber = rvprops[fiber]['MEAN_RV'] * 1000
        # deal with rv threshold
        if np.abs(master_rv - rvfiber) > rv_thres:
            qc_pass.append(0)
        else:
            qc_pass.append(1)
        # add to qc header lists
        qc_values.append(master_rv - rvfiber)
        qc_names.append('RV[{0} - {1}]'.format(master_fiber, fiber))
        qargs = [master_fiber, fiber, rv_thres]
        qc_logic.append('abs(RV[{0} - {1}]) > {2} m/s'.format(*qargs))
    # --------------------------------------------------------------
    # finally log the failed messages and set QC = 1 if we pass the
    #     quality control QC = 0 if we fail quality control
    if np.sum(qc_pass) == len(qc_pass):
        WLOG(params, 'info', textentry('40-005-10001'))
    else:
        for farg in fail_msg:
            WLOG(params, 'warning', textentry('40-005-10002') + farg)
    # store in qc_params
    qc_params = [qc_names, qc_values, qc_logic, qc_pass]
    # return qc_params
    return qc_params


def write_wave_sol(params: ParamDict, recipe: DrsRecipe, fiber: str,
                   wprops: ParamDict, hcfile: DrsFitsFile, fpfile: DrsFitsFile,
                   combine: bool, rawhcfiles: List[str], rawfpfiles: List[str],
                   qc_params: List[list]) -> DrsFitsFile:
    """
    Write the wave solution to file (adding headers where needed)

    :param params: ParamDict, parameter dictionary of constants
    :param recipe: DrsRecipe instance, the recipe calling this function
    :param fiber: str, the fiber for this wave solution
    :param wprops: ParamDict, the wave properties for this fiber
    :param hcfile: DrsFitsFile, the input e2ds HC file instance
    :param fpfile: DrsFitsFile, the input e2ds FP file instance
    :param combine: bool, if True, e2ds inputs were combined
    :param rawhcfiles: list of strings, the raw input HC pp files
    :param rawfpfiles: list of strings, the raw input FP pp files
    :param qc_params: list of lists the quality control parameters

    :return: DrsFitsFile, the wave solution instance
    """
    # ------------------------------------------------------------------
    # get copy of instance of wave file (WAVE_HCMAP)
    wavefile = recipe.outputs['WAVESOL_MASTER'].newcopy(params=params,
                                                        fiber=fiber)
    # construct the filename from file instance
    wavefile.construct_filename(infile=fpfile)
    # set some wave keys as "SELF" (i.e. from this wave solution)
    wprops['WAVEFILE'] = wavefile.basename
    sargs = [recipe.name, params['DRS_VERSION']]
    wprops['WAVESOURCE'] = '{0} [{1}]'.format(*sargs)
    wprops['WFP_FILE'] = wavefile.basename
    # ------------------------------------------------------------------
    # Make wave coefficient table
    # ------------------------------------------------------------------
    # get number of orders
    nbo = wprops['COEFFS'].shape[0]
    # add order column
    wave_cols = ['ORDER']
    wave_vals = [np.arange(nbo)]
    # add coefficients columns
    for w_it in range(wprops['COEFFS'].shape[1]):
        wave_cols.append('COEFFS_{0}'.format(w_it))
        wave_vals.append(wprops['COEFFS'][:, w_it])
    wave_table = drs_table.make_table(params, columns=wave_cols,
                                      values=wave_vals)
    # ------------------------------------------------------------------
    # set input header keys
    # ------------------------------------------------------------------
    # add input hc files (and deal with combining or not combining)
    if combine:
        hfiles = rawhcfiles
    else:
        hfiles = [hcfile.basename]
    wavefile.add_hkey_1d('KW_INFILE1', values=hfiles, dim1name='file')
    # add input fp files (and deal with combining or not combining)
    if combine:
        hfiles = rawfpfiles
    else:
        hfiles = [fpfile.basename]
    wavefile.add_hkey_1d('KW_INFILE2', values=hfiles, dim1name='file')
    # ------------------------------------------------------------------
    # add the order num, fit degree and fit coefficients etc
    wavefile = add_wave_keys(params, wavefile, wprops)
    # ------------------------------------------------------------------
    # add qc parameters
    wavefile.add_qckeys(qc_params)
    # copy data
    wavefile.data = wprops['WAVEMAP']
    # ------------------------------------------------------------------
    # log that we are saving rotated image
    wargs = [fiber, wavefile.filename]
    WLOG(params, '', textentry('40-017-00037', args=wargs))
    # write image to file
    wavefile.write_multi(data_list=[wave_table], datatype_list=['table'],
                         name_list=['COEFF_TABLE'],
                         kind=recipe.outputtype, runstring=recipe.runstring)
    # add to output files (for indexing)
    recipe.add_output_file(wavefile)
    # ------------------------------------------------------------------
    # return wavefile
    return wavefile


def add_wave_keys(params, infile, props):
    # set function name
    _ = display_func(params, 'add_wave_keys', __NAME__)
    # add wave parameters
    infile.add_hkey('KW_WAVEFILE', value=props['WAVEFILE'])
    infile.add_hkey('KW_WAVETIME', value=props['WAVETIME'])
    infile.add_hkey('KW_WAVESOURCE', value=props['WAVESOURCE'])
    infile.add_hkey('KW_WAVE_NBO', value=props['NBO'])
    infile.add_hkey('KW_WAVE_DEG', value=props['DEG'])
    infile.add_hkey_2d('KW_WAVECOEFFS', values=props['COEFFS'],
                       dim1name='order', dim2name='coeffs')
    # add wave fp parameters
    infile.add_hkey('KW_WFP_FILE', value=props['WFP_FILE'])
    infile.add_hkey('KW_WFP_DRIFT', value=props['WFP_DRIFT'])
    infile.add_hkey('KW_WFP_FWHM', value=props['WFP_FWHM'])
    infile.add_hkey('KW_WFP_CONTRAST', value=props['WFP_CONTRAST'])
    infile.add_hkey('KW_WFP_MASK', value=props['WFP_MASK'])
    # WFP_LINES should be a list of ints or None or 'None'
    #     (deal with it either way)
    if props['WFP_LINES'] is None:
        infile.add_hkey('KW_WFP_LINES', None)
    elif isinstance(props['WFP_LINES'], str):
        infile.add_hkey('KW_WFP_LINES', value=props['WFP_LINES'])
    else:
        infile.add_hkey('KW_WFP_LINES', value=mp.nansum(props['WFP_LINES']))
    infile.add_hkey('KW_WFP_TARG_RV', value=props['WFP_TARG_RV'])
    infile.add_hkey('KW_WFP_WIDTH', value=props['WFP_WIDTH'])
    infile.add_hkey('KW_WFP_STEP', value=props['WFP_STEP'])
    # return infile
    return infile


def write_wave_lines(params: ParamDict, recipe: DrsRecipe,
                     hce2ds: DrsFitsFile, fpe2ds: DrsFitsFile,
                     wavefile: DrsFitsFile, hclines: Table,
                     fplines: Table, fiber: str,
                     #TODO: REMOVE LATER
                     kind=None):
    """
    Write the HC and FP lines table to file

    :param params: ParamDict, the parameter dictionary of constants
    :param recipe: DrsRecipe instance, the recipe that called this function
    :param hce2ds: DrsFitsFile, the HC input e2ds file instance
    :param fpe2ds: DrsFitsFile, the FP input e2ds file instnace
    :param wavefile: DrsFitsFile, the wave solution file instance
    :param hclines: Table
    :param fplines: Table
    :param fiber: str, the fiber that we are processing

    :return: None - writes to file
    """
    # set function name
    _ = display_func(params, 'write_master_lines', __NAME__)
    # ------------------------------------------------------------------
    # write hc lines
    # ------------------------------------------------------------------
    # get copy of instance of wave file (WAVE_HCMAP)
    hcfile = recipe.outputs['WAVEM_HCLIST'].newcopy(recipe=recipe,
                                                    fiber=fiber)
    # construct the filename from file instance
    hcfile.construct_filename(params, infile=hce2ds)
    # ------------------------------------------------------------------
    # copy keys from hcwavefile
    hcfile.copy_hdict(wavefile, None)
    # set output key
    hcfile.add_hkey('KW_OUTPUT', value=hcfile.name)
    # set data
    hcfile.data = hclines
    hcfile.datatype = 'table'
    # ------------------------------------------------------------------
    # log that we are saving rotated image
    wargs = [fiber, hcfile.filename]
    WLOG(params, '', textentry('40-017-00039', args=wargs))
    # write image to file
    hcfile.write_file()
    # add to output files (for indexing)
    recipe.add_output_file(hcfile)
    # ------------------------------------------------------------------
    # write fp lines
    # ------------------------------------------------------------------
    # get copy of instance of wave file (WAVE_HCMAP)
    fpfile = recipe.outputs['WAVEM_FPLIST'].newcopy(recipe=recipe, fiber=fiber)
    # construct the filename from file instance
    fpfile.construct_filename(params, infile=fpe2ds)
    # ------------------------------------------------------------------
    # copy keys from hcwavefile
    fpfile.copy_hdict(wavefile)
    # set output key
    fpfile.add_hkey('KW_OUTPUT', value=fpfile.name)
    # set data
    fpfile.data = fplines
    fpfile.datatype = 'table'
    # ------------------------------------------------------------------
    # log that we are saving rotated image
    wargs = [fiber, fpfile.filename]
    WLOG(params, '', textentry('40-017-00039', args=wargs))

    # TODO: remove later
    if kind is not None:
        path = fpfile.filename.split(fpfile.basename)[0]
        fpfile.basename = '{0}_{1}'.format(kind, fpfile.basename)
        fpfile.filename = os.path.join(path, fpfile.basename)

    # write image to file
    fpfile.write_file()
    # add to output files (for indexing)
    recipe.add_output_file(fpfile)
    # ------------------------------------------------------------------
    # return hc  and fp line files
    return hcfile, fpfile


def write_cavity_file(params: ParamDict, recipe: DrsRecipe,
                      fpe2ds: DrsFitsFile, wavefile: DrsFitsFile,
                      cavity: np.ndarray) -> DrsFitsFile:
    """
    Write the cavity file to disk

    :param params: ParamDict, parameter dictionary of constants
    :param recipe: DrsRecipe, the recipe that called this function
    :param fpe2ds: DrsFitsFile, the FP e2ds fits file instance
    :param wavefile: DrsFitsFile, the wave solution file instance
    :param cavity: np.array, the cavity solution to save to file

    :return: DrsFitsFile, the cavity file instance
    """
    # set function name
    _ = display_func(params, 'write_cavity_file', __NAME__)
    # ------------------------------------------------------------------
    # write hc lines
    # ------------------------------------------------------------------
    # get copy of instance of wave file (WAVE_HCMAP)
    cavfile = recipe.outputs['WAVEM_CAVITY'].newcopy(recipe=recipe)
    # construct the filename from file instance
    cavfile.construct_filename(params, infile=fpe2ds)
    # ------------------------------------------------------------------
    # copy keys from hcwavefile
    cavfile.copy_hdict(wavefile)
    # set output key
    cavfile.add_hkey('KW_OUTPUT', value=cavfile.name)
    # set data
    cavfile.data = cavity
    cavfile.datatype = 'image'
    # ------------------------------------------------------------------
    # log that we are saving rotated image
    wargs = [cavfile.filename]
    WLOG(params, '', textentry('40-017-00054', args=wargs))
    # write image to file
    cavfile.write_file()
    # add to output files (for indexing)
    recipe.add_output_file(cavfile)
    # ------------------------------------------------------------------
    # return hc  and fp line files
    return cavfile


# =============================================================================
# Start of code
# =============================================================================
if __name__ == "__main__":
    # print hello world
    print('Hello World')

# =============================================================================
# End of code
# =============================================================================
